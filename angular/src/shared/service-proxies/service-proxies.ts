/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param inputNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, inputNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssumptionForEdit(id: string | null | undefined): Observable<GetAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Assumptions/GetAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssumptionForEdit(response: HttpResponseBase): Observable<GetAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAssumptionForEditOutput.fromJS(resultData200) : new GetAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }

    /**
     * @param ouId (optional) 
     * @return Success
     */
    getAffiliateNameFromId(ouId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetAffiliateNameFromId?";
        if (ouId !== undefined)
            url_ += "ouId=" + encodeURIComponent("" + ouId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateNameFromId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateNameFromId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliateNameFromId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getMacroeconomicVariableList(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetMacroeconomicVariableList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMacroeconomicVariableList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMacroeconomicVariableList(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMacroeconomicVariableList(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class EadInputAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param inputNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, inputNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetEadInputAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EadInputAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEadInputAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEadInputAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEadInputAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetEadInputAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetEadInputAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEadInputAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEadInputAssumptionForEdit(id: string | null | undefined): Observable<GetEadInputAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EadInputAssumptions/GetEadInputAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEadInputAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEadInputAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEadInputAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEadInputAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEadInputAssumptionForEdit(response: HttpResponseBase): Observable<GetEadInputAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEadInputAssumptionForEditOutput.fromJS(resultData200) : new GetEadInputAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEadInputAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditEadInputAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EadInputAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EadInputAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EclSharedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEclForWorkspace(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAllEclForWorkspaceDto> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAllEclForWorkspace?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEclForWorkspace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEclForWorkspace(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAllEclForWorkspaceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAllEclForWorkspaceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEclForWorkspace(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllEclForWorkspaceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetAllEclForWorkspaceDto.fromJS(resultData200) : new PagedResultDtoOfGetAllEclForWorkspaceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllEclForWorkspaceDto>(<any>null);
    }

    /**
     * @return Success
     */
    getFrameworkAssumptionSnapshot(framework: FrameworkEnum): Observable<AssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetFrameworkAssumptionSnapshot?";
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrameworkAssumptionSnapshot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrameworkAssumptionSnapshot(<any>response_);
                } catch (e) {
                    return <Observable<AssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFrameworkAssumptionSnapshot(response: HttpResponseBase): Observable<AssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssumptionDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getEadInputAssumptionSnapshot(framework: FrameworkEnum): Observable<EadInputAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetEadInputAssumptionSnapshot?";
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEadInputAssumptionSnapshot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEadInputAssumptionSnapshot(<any>response_);
                } catch (e) {
                    return <Observable<EadInputAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EadInputAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEadInputAssumptionSnapshot(response: HttpResponseBase): Observable<EadInputAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EadInputAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EadInputAssumptionDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLgdInputAssumptionSnapshot(framework: FrameworkEnum): Observable<LgdAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetLgdInputAssumptionSnapshot?";
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLgdInputAssumptionSnapshot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLgdInputAssumptionSnapshot(<any>response_);
                } catch (e) {
                    return <Observable<LgdAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LgdAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLgdInputAssumptionSnapshot(response: HttpResponseBase): Observable<LgdAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LgdAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LgdAssumptionDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAffiliateAssumption(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAllAffiliateAssumptionDto> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAllAffiliateAssumption?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAffiliateAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAffiliateAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAllAffiliateAssumptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAllAffiliateAssumptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAffiliateAssumption(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllAffiliateAssumptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetAllAffiliateAssumptionDto.fromJS(resultData200) : new PagedResultDtoOfGetAllAffiliateAssumptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllAffiliateAssumptionDto>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliateFrameworkAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<AssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliateFrameworkAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateFrameworkAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateFrameworkAssumption(<any>response_);
                } catch (e) {
                    return <Observable<AssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliateFrameworkAssumption(response: HttpResponseBase): Observable<AssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssumptionDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliateEadAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<EadInputAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliateEadAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateEadAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateEadAssumption(<any>response_);
                } catch (e) {
                    return <Observable<EadInputAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EadInputAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliateEadAssumption(response: HttpResponseBase): Observable<EadInputAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EadInputAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EadInputAssumptionDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliateLgdAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<LgdAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliateLgdAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateLgdAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateLgdAssumption(<any>response_);
                } catch (e) {
                    return <Observable<LgdAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LgdAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliateLgdAssumption(response: HttpResponseBase): Observable<LgdAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LgdAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LgdAssumptionDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliatePdAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<PdInputAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliatePdAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliatePdAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliatePdAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PdInputAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PdInputAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliatePdAssumption(response: HttpResponseBase): Observable<PdInputAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdInputAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PdInputAssumptionDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliatePdMacroeconomicInputAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<PdInputAssumptionMacroeconomicInputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliatePdMacroeconomicInputAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliatePdMacroeconomicInputAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliatePdMacroeconomicInputAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PdInputAssumptionMacroeconomicInputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PdInputAssumptionMacroeconomicInputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliatePdMacroeconomicInputAssumption(response: HttpResponseBase): Observable<PdInputAssumptionMacroeconomicInputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdInputAssumptionMacroeconomicInputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PdInputAssumptionMacroeconomicInputDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliatePdMacroeconomicProjectionAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<PdInputAssumptionMacroeconomicProjectionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliatePdMacroeconomicProjectionAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliatePdMacroeconomicProjectionAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliatePdMacroeconomicProjectionAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PdInputAssumptionMacroeconomicProjectionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PdInputAssumptionMacroeconomicProjectionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliatePdMacroeconomicProjectionAssumption(response: HttpResponseBase): Observable<PdInputAssumptionMacroeconomicProjectionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdInputAssumptionMacroeconomicProjectionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PdInputAssumptionMacroeconomicProjectionDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliatePdNonInternalModelAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<PdInputAssumptionNonInternalModelDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliatePdNonInternalModelAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliatePdNonInternalModelAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliatePdNonInternalModelAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PdInputAssumptionNonInternalModelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PdInputAssumptionNonInternalModelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliatePdNonInternalModelAssumption(response: HttpResponseBase): Observable<PdInputAssumptionNonInternalModelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdInputAssumptionNonInternalModelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PdInputAssumptionNonInternalModelDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliatePdNplIndexAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<PdInputAssumptionNplIndexDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliatePdNplIndexAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliatePdNplIndexAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliatePdNplIndexAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PdInputAssumptionNplIndexDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PdInputAssumptionNplIndexDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliatePdNplIndexAssumption(response: HttpResponseBase): Observable<PdInputAssumptionNplIndexDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdInputAssumptionNplIndexDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PdInputAssumptionNplIndexDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAffiliatePdSnpCummulativeAssumption(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<PdInputSnPCummulativeDefaultRateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAffiliatePdSnpCummulativeAssumption?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliatePdSnpCummulativeAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliatePdSnpCummulativeAssumption(<any>response_);
                } catch (e) {
                    return <Observable<PdInputSnPCummulativeDefaultRateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PdInputSnPCummulativeDefaultRateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliatePdSnpCummulativeAssumption(response: HttpResponseBase): Observable<PdInputSnPCummulativeDefaultRateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PdInputSnPCummulativeDefaultRateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PdInputSnPCummulativeDefaultRateDto[]>(<any>null);
    }

    /**
     * @param affiliateOuId (optional) 
     * @return Success
     */
    getAllPdAssumptionsForAffiliate(affiliateOuId: number | null | undefined, framework: FrameworkEnum): Observable<GetAllPdAssumptionsDto> {
        let url_ = this.baseUrl + "/api/services/app/EclShared/GetAllPdAssumptionsForAffiliate?";
        if (affiliateOuId !== undefined)
            url_ += "AffiliateOuId=" + encodeURIComponent("" + affiliateOuId) + "&"; 
        if (framework === undefined || framework === null)
            throw new Error("The parameter 'framework' must be defined and cannot be null.");
        else
            url_ += "Framework=" + encodeURIComponent("" + framework) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPdAssumptionsForAffiliate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPdAssumptionsForAffiliate(<any>response_);
                } catch (e) {
                    return <Observable<GetAllPdAssumptionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllPdAssumptionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPdAssumptionsForAffiliate(response: HttpResponseBase): Observable<GetAllPdAssumptionsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAllPdAssumptionsDto.fromJS(resultData200) : new GetAllPdAssumptionsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPdAssumptionsDto>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEdition(input: CreateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateEdition(input: UpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LgdAssumptionUnsecuredRecoveriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param inputNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, inputNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LgdAssumptionUnsecuredRecoveries/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLgdAssumptionUnsecuredRecoveryForEdit(id: string | null | undefined): Observable<GetLgdAssumptionUnsecuredRecoveryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LgdAssumptionUnsecuredRecoveries/GetLgdAssumptionUnsecuredRecoveryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLgdAssumptionUnsecuredRecoveryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLgdAssumptionUnsecuredRecoveryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLgdAssumptionUnsecuredRecoveryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLgdAssumptionUnsecuredRecoveryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLgdAssumptionUnsecuredRecoveryForEdit(response: HttpResponseBase): Observable<GetLgdAssumptionUnsecuredRecoveryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLgdAssumptionUnsecuredRecoveryForEditOutput.fromJS(resultData200) : new GetLgdAssumptionUnsecuredRecoveryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLgdAssumptionUnsecuredRecoveryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLgdAssumptionUnsecuredRecoveryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LgdAssumptionUnsecuredRecoveries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LgdAssumptionUnsecuredRecoveries/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MacroeconomicVariablesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMacroeconomicVariableForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MacroeconomicVariables/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMacroeconomicVariableForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMacroeconomicVariableForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMacroeconomicVariableForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMacroeconomicVariableForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetMacroeconomicVariableForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMacroeconomicVariableForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMacroeconomicVariableForEdit(id: number | null | undefined): Observable<GetMacroeconomicVariableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MacroeconomicVariables/GetMacroeconomicVariableForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMacroeconomicVariableForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMacroeconomicVariableForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMacroeconomicVariableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMacroeconomicVariableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMacroeconomicVariableForEdit(response: HttpResponseBase): Observable<GetMacroeconomicVariableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMacroeconomicVariableForEditOutput.fromJS(resultData200) : new GetMacroeconomicVariableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMacroeconomicVariableForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMacroeconomicVariableDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MacroeconomicVariables/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MacroeconomicVariables/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ObeEclApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclApprovalForEdit(id: string | null | undefined): Observable<GetObeEclApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclApprovals/GetObeEclApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclApprovalForEdit(response: HttpResponseBase): Observable<GetObeEclApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclApprovalForEditOutput.fromJS(resultData200) : new GetObeEclApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclApprovalObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclApprovals/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclApprovalObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclApprovalObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclApprovalObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclApprovalObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclApprovalObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclApprovalObeEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclAssumptionApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param assumptionTypeFilter (optional) 
     * @param oldValueFilter (optional) 
     * @param newValueFilter (optional) 
     * @param maxDateReviewedFilter (optional) 
     * @param minDateReviewedFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, assumptionTypeFilter: number | null | undefined, oldValueFilter: string | null | undefined, newValueFilter: string | null | undefined, maxDateReviewedFilter: moment.Moment | null | undefined, minDateReviewedFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptionApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (assumptionTypeFilter !== undefined)
            url_ += "AssumptionTypeFilter=" + encodeURIComponent("" + assumptionTypeFilter) + "&"; 
        if (oldValueFilter !== undefined)
            url_ += "OldValueFilter=" + encodeURIComponent("" + oldValueFilter) + "&"; 
        if (newValueFilter !== undefined)
            url_ += "NewValueFilter=" + encodeURIComponent("" + newValueFilter) + "&"; 
        if (maxDateReviewedFilter !== undefined)
            url_ += "MaxDateReviewedFilter=" + encodeURIComponent(maxDateReviewedFilter ? "" + maxDateReviewedFilter.toJSON() : "") + "&"; 
        if (minDateReviewedFilter !== undefined)
            url_ += "MinDateReviewedFilter=" + encodeURIComponent(minDateReviewedFilter ? "" + minDateReviewedFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclAssumptionApprovalForEdit(id: string | null | undefined): Observable<GetObeEclAssumptionApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptionApprovals/GetObeEclAssumptionApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclAssumptionApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclAssumptionApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclAssumptionApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclAssumptionApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclAssumptionApprovalForEdit(response: HttpResponseBase): Observable<GetObeEclAssumptionApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclAssumptionApprovalForEditOutput.fromJS(resultData200) : new GetObeEclAssumptionApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclAssumptionApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclAssumptionApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptionApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptionApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptionApprovals/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptionApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param inputNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param datatypeFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param assumptionGroupFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, inputNameFilter: string | null | undefined, valueFilter: string | null | undefined, datatypeFilter: number | null | undefined, isComputedFilter: number | null | undefined, assumptionGroupFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (datatypeFilter !== undefined)
            url_ += "DatatypeFilter=" + encodeURIComponent("" + datatypeFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (assumptionGroupFilter !== undefined)
            url_ += "AssumptionGroupFilter=" + encodeURIComponent("" + assumptionGroupFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclAssumptionForEdit(id: string | null | undefined): Observable<GetObeEclAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptions/GetObeEclAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclAssumptionForEdit(response: HttpResponseBase): Observable<GetObeEclAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclAssumptionForEditOutput.fromJS(resultData200) : new GetObeEclAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclAssumptions/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclDataLoanBooksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customerNoFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param contractNoFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param maxSnapshotDateFilter (optional) 
     * @param minSnapshotDateFilter (optional) 
     * @param segmentFilter (optional) 
     * @param sectorFilter (optional) 
     * @param currencyFilter (optional) 
     * @param productTypeFilter (optional) 
     * @param productMappingFilter (optional) 
     * @param specialisedLendingFilter (optional) 
     * @param ratingModelFilter (optional) 
     * @param maxOriginalRatingFilter (optional) 
     * @param minOriginalRatingFilter (optional) 
     * @param maxCurrentRatingFilter (optional) 
     * @param minCurrentRatingFilter (optional) 
     * @param maxLifetimePDFilter (optional) 
     * @param minLifetimePDFilter (optional) 
     * @param maxMonth12PDFilter (optional) 
     * @param minMonth12PDFilter (optional) 
     * @param maxDaysPastDueFilter (optional) 
     * @param minDaysPastDueFilter (optional) 
     * @param watchlistIndicatorFilter (optional) 
     * @param classificationFilter (optional) 
     * @param maxImpairedDateFilter (optional) 
     * @param minImpairedDateFilter (optional) 
     * @param maxDefaultDateFilter (optional) 
     * @param minDefaultDateFilter (optional) 
     * @param maxCreditLimitFilter (optional) 
     * @param minCreditLimitFilter (optional) 
     * @param maxOriginalBalanceLCYFilter (optional) 
     * @param minOriginalBalanceLCYFilter (optional) 
     * @param maxOutstandingBalanceLCYFilter (optional) 
     * @param minOutstandingBalanceLCYFilter (optional) 
     * @param maxOutstandingBalanceACYFilter (optional) 
     * @param minOutstandingBalanceACYFilter (optional) 
     * @param maxContractStartDateFilter (optional) 
     * @param minContractStartDateFilter (optional) 
     * @param maxContractEndDateFilter (optional) 
     * @param minContractEndDateFilter (optional) 
     * @param restructureIndicatorFilter (optional) 
     * @param restructureRiskFilter (optional) 
     * @param restructureTypeFilter (optional) 
     * @param maxRestructureStartDateFilter (optional) 
     * @param minRestructureStartDateFilter (optional) 
     * @param maxRestructureEndDateFilter (optional) 
     * @param minRestructureEndDateFilter (optional) 
     * @param principalPaymentTermsOriginationFilter (optional) 
     * @param maxPPTOPeriodFilter (optional) 
     * @param minPPTOPeriodFilter (optional) 
     * @param interestPaymentTermsOriginationFilter (optional) 
     * @param maxIPTOPeriodFilter (optional) 
     * @param minIPTOPeriodFilter (optional) 
     * @param principalPaymentStructureFilter (optional) 
     * @param interestPaymentStructureFilter (optional) 
     * @param interestRateTypeFilter (optional) 
     * @param baseRateFilter (optional) 
     * @param originationContractualInterestRateFilter (optional) 
     * @param maxIntroductoryPeriodFilter (optional) 
     * @param minIntroductoryPeriodFilter (optional) 
     * @param maxPostIPContractualInterestRateFilter (optional) 
     * @param minPostIPContractualInterestRateFilter (optional) 
     * @param maxCurrentContractualInterestRateFilter (optional) 
     * @param minCurrentContractualInterestRateFilter (optional) 
     * @param maxEIRFilter (optional) 
     * @param minEIRFilter (optional) 
     * @param maxDebentureOMVFilter (optional) 
     * @param minDebentureOMVFilter (optional) 
     * @param maxDebentureFSVFilter (optional) 
     * @param minDebentureFSVFilter (optional) 
     * @param maxCashOMVFilter (optional) 
     * @param minCashOMVFilter (optional) 
     * @param maxCashFSVFilter (optional) 
     * @param minCashFSVFilter (optional) 
     * @param maxInventoryOMVFilter (optional) 
     * @param minInventoryOMVFilter (optional) 
     * @param maxInventoryFSVFilter (optional) 
     * @param minInventoryFSVFilter (optional) 
     * @param maxPlantEquipmentOMVFilter (optional) 
     * @param minPlantEquipmentOMVFilter (optional) 
     * @param maxPlantEquipmentFSVFilter (optional) 
     * @param minPlantEquipmentFSVFilter (optional) 
     * @param maxResidentialPropertyOMVFilter (optional) 
     * @param minResidentialPropertyOMVFilter (optional) 
     * @param maxResidentialPropertyFSVFilter (optional) 
     * @param minResidentialPropertyFSVFilter (optional) 
     * @param maxCommercialPropertyOMVFilter (optional) 
     * @param minCommercialPropertyOMVFilter (optional) 
     * @param maxCommercialPropertyFilter (optional) 
     * @param minCommercialPropertyFilter (optional) 
     * @param maxReceivablesOMVFilter (optional) 
     * @param minReceivablesOMVFilter (optional) 
     * @param maxReceivablesFSVFilter (optional) 
     * @param minReceivablesFSVFilter (optional) 
     * @param maxSharesOMVFilter (optional) 
     * @param minSharesOMVFilter (optional) 
     * @param maxSharesFSVFilter (optional) 
     * @param minSharesFSVFilter (optional) 
     * @param maxVehicleOMVFilter (optional) 
     * @param minVehicleOMVFilter (optional) 
     * @param maxVehicleFSVFilter (optional) 
     * @param minVehicleFSVFilter (optional) 
     * @param maxCureRateFilter (optional) 
     * @param minCureRateFilter (optional) 
     * @param guaranteeIndicatorFilter (optional) 
     * @param guarantorPDFilter (optional) 
     * @param guarantorLGDFilter (optional) 
     * @param maxGuaranteeValueFilter (optional) 
     * @param minGuaranteeValueFilter (optional) 
     * @param maxGuaranteeLevelFilter (optional) 
     * @param minGuaranteeLevelFilter (optional) 
     * @param contractIdFilter (optional) 
     * @param obeEclUploadTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, customerNoFilter: string | null | undefined, accountNoFilter: string | null | undefined, contractNoFilter: string | null | undefined, customerNameFilter: string | null | undefined, maxSnapshotDateFilter: moment.Moment | null | undefined, minSnapshotDateFilter: moment.Moment | null | undefined, segmentFilter: string | null | undefined, sectorFilter: string | null | undefined, currencyFilter: string | null | undefined, productTypeFilter: string | null | undefined, productMappingFilter: string | null | undefined, specialisedLendingFilter: string | null | undefined, ratingModelFilter: string | null | undefined, maxOriginalRatingFilter: number | null | undefined, minOriginalRatingFilter: number | null | undefined, maxCurrentRatingFilter: number | null | undefined, minCurrentRatingFilter: number | null | undefined, maxLifetimePDFilter: number | null | undefined, minLifetimePDFilter: number | null | undefined, maxMonth12PDFilter: number | null | undefined, minMonth12PDFilter: number | null | undefined, maxDaysPastDueFilter: number | null | undefined, minDaysPastDueFilter: number | null | undefined, watchlistIndicatorFilter: number | null | undefined, classificationFilter: string | null | undefined, maxImpairedDateFilter: moment.Moment | null | undefined, minImpairedDateFilter: moment.Moment | null | undefined, maxDefaultDateFilter: moment.Moment | null | undefined, minDefaultDateFilter: moment.Moment | null | undefined, maxCreditLimitFilter: number | null | undefined, minCreditLimitFilter: number | null | undefined, maxOriginalBalanceLCYFilter: number | null | undefined, minOriginalBalanceLCYFilter: number | null | undefined, maxOutstandingBalanceLCYFilter: number | null | undefined, minOutstandingBalanceLCYFilter: number | null | undefined, maxOutstandingBalanceACYFilter: number | null | undefined, minOutstandingBalanceACYFilter: number | null | undefined, maxContractStartDateFilter: moment.Moment | null | undefined, minContractStartDateFilter: moment.Moment | null | undefined, maxContractEndDateFilter: moment.Moment | null | undefined, minContractEndDateFilter: moment.Moment | null | undefined, restructureIndicatorFilter: number | null | undefined, restructureRiskFilter: string | null | undefined, restructureTypeFilter: string | null | undefined, maxRestructureStartDateFilter: moment.Moment | null | undefined, minRestructureStartDateFilter: moment.Moment | null | undefined, maxRestructureEndDateFilter: moment.Moment | null | undefined, minRestructureEndDateFilter: moment.Moment | null | undefined, principalPaymentTermsOriginationFilter: string | null | undefined, maxPPTOPeriodFilter: number | null | undefined, minPPTOPeriodFilter: number | null | undefined, interestPaymentTermsOriginationFilter: string | null | undefined, maxIPTOPeriodFilter: number | null | undefined, minIPTOPeriodFilter: number | null | undefined, principalPaymentStructureFilter: string | null | undefined, interestPaymentStructureFilter: string | null | undefined, interestRateTypeFilter: string | null | undefined, baseRateFilter: string | null | undefined, originationContractualInterestRateFilter: string | null | undefined, maxIntroductoryPeriodFilter: number | null | undefined, minIntroductoryPeriodFilter: number | null | undefined, maxPostIPContractualInterestRateFilter: number | null | undefined, minPostIPContractualInterestRateFilter: number | null | undefined, maxCurrentContractualInterestRateFilter: number | null | undefined, minCurrentContractualInterestRateFilter: number | null | undefined, maxEIRFilter: number | null | undefined, minEIRFilter: number | null | undefined, maxDebentureOMVFilter: number | null | undefined, minDebentureOMVFilter: number | null | undefined, maxDebentureFSVFilter: number | null | undefined, minDebentureFSVFilter: number | null | undefined, maxCashOMVFilter: number | null | undefined, minCashOMVFilter: number | null | undefined, maxCashFSVFilter: number | null | undefined, minCashFSVFilter: number | null | undefined, maxInventoryOMVFilter: number | null | undefined, minInventoryOMVFilter: number | null | undefined, maxInventoryFSVFilter: number | null | undefined, minInventoryFSVFilter: number | null | undefined, maxPlantEquipmentOMVFilter: number | null | undefined, minPlantEquipmentOMVFilter: number | null | undefined, maxPlantEquipmentFSVFilter: number | null | undefined, minPlantEquipmentFSVFilter: number | null | undefined, maxResidentialPropertyOMVFilter: number | null | undefined, minResidentialPropertyOMVFilter: number | null | undefined, maxResidentialPropertyFSVFilter: number | null | undefined, minResidentialPropertyFSVFilter: number | null | undefined, maxCommercialPropertyOMVFilter: number | null | undefined, minCommercialPropertyOMVFilter: number | null | undefined, maxCommercialPropertyFilter: number | null | undefined, minCommercialPropertyFilter: number | null | undefined, maxReceivablesOMVFilter: number | null | undefined, minReceivablesOMVFilter: number | null | undefined, maxReceivablesFSVFilter: number | null | undefined, minReceivablesFSVFilter: number | null | undefined, maxSharesOMVFilter: number | null | undefined, minSharesOMVFilter: number | null | undefined, maxSharesFSVFilter: number | null | undefined, minSharesFSVFilter: number | null | undefined, maxVehicleOMVFilter: number | null | undefined, minVehicleOMVFilter: number | null | undefined, maxVehicleFSVFilter: number | null | undefined, minVehicleFSVFilter: number | null | undefined, maxCureRateFilter: number | null | undefined, minCureRateFilter: number | null | undefined, guaranteeIndicatorFilter: number | null | undefined, guarantorPDFilter: string | null | undefined, guarantorLGDFilter: string | null | undefined, maxGuaranteeValueFilter: number | null | undefined, minGuaranteeValueFilter: number | null | undefined, maxGuaranteeLevelFilter: number | null | undefined, minGuaranteeLevelFilter: number | null | undefined, contractIdFilter: string | null | undefined, obeEclUploadTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclDataLoanBookForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataLoanBooks/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (customerNoFilter !== undefined)
            url_ += "CustomerNoFilter=" + encodeURIComponent("" + customerNoFilter) + "&"; 
        if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&"; 
        if (contractNoFilter !== undefined)
            url_ += "ContractNoFilter=" + encodeURIComponent("" + contractNoFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (maxSnapshotDateFilter !== undefined)
            url_ += "MaxSnapshotDateFilter=" + encodeURIComponent(maxSnapshotDateFilter ? "" + maxSnapshotDateFilter.toJSON() : "") + "&"; 
        if (minSnapshotDateFilter !== undefined)
            url_ += "MinSnapshotDateFilter=" + encodeURIComponent(minSnapshotDateFilter ? "" + minSnapshotDateFilter.toJSON() : "") + "&"; 
        if (segmentFilter !== undefined)
            url_ += "SegmentFilter=" + encodeURIComponent("" + segmentFilter) + "&"; 
        if (sectorFilter !== undefined)
            url_ += "SectorFilter=" + encodeURIComponent("" + sectorFilter) + "&"; 
        if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&"; 
        if (productTypeFilter !== undefined)
            url_ += "ProductTypeFilter=" + encodeURIComponent("" + productTypeFilter) + "&"; 
        if (productMappingFilter !== undefined)
            url_ += "ProductMappingFilter=" + encodeURIComponent("" + productMappingFilter) + "&"; 
        if (specialisedLendingFilter !== undefined)
            url_ += "SpecialisedLendingFilter=" + encodeURIComponent("" + specialisedLendingFilter) + "&"; 
        if (ratingModelFilter !== undefined)
            url_ += "RatingModelFilter=" + encodeURIComponent("" + ratingModelFilter) + "&"; 
        if (maxOriginalRatingFilter !== undefined)
            url_ += "MaxOriginalRatingFilter=" + encodeURIComponent("" + maxOriginalRatingFilter) + "&"; 
        if (minOriginalRatingFilter !== undefined)
            url_ += "MinOriginalRatingFilter=" + encodeURIComponent("" + minOriginalRatingFilter) + "&"; 
        if (maxCurrentRatingFilter !== undefined)
            url_ += "MaxCurrentRatingFilter=" + encodeURIComponent("" + maxCurrentRatingFilter) + "&"; 
        if (minCurrentRatingFilter !== undefined)
            url_ += "MinCurrentRatingFilter=" + encodeURIComponent("" + minCurrentRatingFilter) + "&"; 
        if (maxLifetimePDFilter !== undefined)
            url_ += "MaxLifetimePDFilter=" + encodeURIComponent("" + maxLifetimePDFilter) + "&"; 
        if (minLifetimePDFilter !== undefined)
            url_ += "MinLifetimePDFilter=" + encodeURIComponent("" + minLifetimePDFilter) + "&"; 
        if (maxMonth12PDFilter !== undefined)
            url_ += "MaxMonth12PDFilter=" + encodeURIComponent("" + maxMonth12PDFilter) + "&"; 
        if (minMonth12PDFilter !== undefined)
            url_ += "MinMonth12PDFilter=" + encodeURIComponent("" + minMonth12PDFilter) + "&"; 
        if (maxDaysPastDueFilter !== undefined)
            url_ += "MaxDaysPastDueFilter=" + encodeURIComponent("" + maxDaysPastDueFilter) + "&"; 
        if (minDaysPastDueFilter !== undefined)
            url_ += "MinDaysPastDueFilter=" + encodeURIComponent("" + minDaysPastDueFilter) + "&"; 
        if (watchlistIndicatorFilter !== undefined)
            url_ += "WatchlistIndicatorFilter=" + encodeURIComponent("" + watchlistIndicatorFilter) + "&"; 
        if (classificationFilter !== undefined)
            url_ += "ClassificationFilter=" + encodeURIComponent("" + classificationFilter) + "&"; 
        if (maxImpairedDateFilter !== undefined)
            url_ += "MaxImpairedDateFilter=" + encodeURIComponent(maxImpairedDateFilter ? "" + maxImpairedDateFilter.toJSON() : "") + "&"; 
        if (minImpairedDateFilter !== undefined)
            url_ += "MinImpairedDateFilter=" + encodeURIComponent(minImpairedDateFilter ? "" + minImpairedDateFilter.toJSON() : "") + "&"; 
        if (maxDefaultDateFilter !== undefined)
            url_ += "MaxDefaultDateFilter=" + encodeURIComponent(maxDefaultDateFilter ? "" + maxDefaultDateFilter.toJSON() : "") + "&"; 
        if (minDefaultDateFilter !== undefined)
            url_ += "MinDefaultDateFilter=" + encodeURIComponent(minDefaultDateFilter ? "" + minDefaultDateFilter.toJSON() : "") + "&"; 
        if (maxCreditLimitFilter !== undefined)
            url_ += "MaxCreditLimitFilter=" + encodeURIComponent("" + maxCreditLimitFilter) + "&"; 
        if (minCreditLimitFilter !== undefined)
            url_ += "MinCreditLimitFilter=" + encodeURIComponent("" + minCreditLimitFilter) + "&"; 
        if (maxOriginalBalanceLCYFilter !== undefined)
            url_ += "MaxOriginalBalanceLCYFilter=" + encodeURIComponent("" + maxOriginalBalanceLCYFilter) + "&"; 
        if (minOriginalBalanceLCYFilter !== undefined)
            url_ += "MinOriginalBalanceLCYFilter=" + encodeURIComponent("" + minOriginalBalanceLCYFilter) + "&"; 
        if (maxOutstandingBalanceLCYFilter !== undefined)
            url_ += "MaxOutstandingBalanceLCYFilter=" + encodeURIComponent("" + maxOutstandingBalanceLCYFilter) + "&"; 
        if (minOutstandingBalanceLCYFilter !== undefined)
            url_ += "MinOutstandingBalanceLCYFilter=" + encodeURIComponent("" + minOutstandingBalanceLCYFilter) + "&"; 
        if (maxOutstandingBalanceACYFilter !== undefined)
            url_ += "MaxOutstandingBalanceACYFilter=" + encodeURIComponent("" + maxOutstandingBalanceACYFilter) + "&"; 
        if (minOutstandingBalanceACYFilter !== undefined)
            url_ += "MinOutstandingBalanceACYFilter=" + encodeURIComponent("" + minOutstandingBalanceACYFilter) + "&"; 
        if (maxContractStartDateFilter !== undefined)
            url_ += "MaxContractStartDateFilter=" + encodeURIComponent(maxContractStartDateFilter ? "" + maxContractStartDateFilter.toJSON() : "") + "&"; 
        if (minContractStartDateFilter !== undefined)
            url_ += "MinContractStartDateFilter=" + encodeURIComponent(minContractStartDateFilter ? "" + minContractStartDateFilter.toJSON() : "") + "&"; 
        if (maxContractEndDateFilter !== undefined)
            url_ += "MaxContractEndDateFilter=" + encodeURIComponent(maxContractEndDateFilter ? "" + maxContractEndDateFilter.toJSON() : "") + "&"; 
        if (minContractEndDateFilter !== undefined)
            url_ += "MinContractEndDateFilter=" + encodeURIComponent(minContractEndDateFilter ? "" + minContractEndDateFilter.toJSON() : "") + "&"; 
        if (restructureIndicatorFilter !== undefined)
            url_ += "RestructureIndicatorFilter=" + encodeURIComponent("" + restructureIndicatorFilter) + "&"; 
        if (restructureRiskFilter !== undefined)
            url_ += "RestructureRiskFilter=" + encodeURIComponent("" + restructureRiskFilter) + "&"; 
        if (restructureTypeFilter !== undefined)
            url_ += "RestructureTypeFilter=" + encodeURIComponent("" + restructureTypeFilter) + "&"; 
        if (maxRestructureStartDateFilter !== undefined)
            url_ += "MaxRestructureStartDateFilter=" + encodeURIComponent(maxRestructureStartDateFilter ? "" + maxRestructureStartDateFilter.toJSON() : "") + "&"; 
        if (minRestructureStartDateFilter !== undefined)
            url_ += "MinRestructureStartDateFilter=" + encodeURIComponent(minRestructureStartDateFilter ? "" + minRestructureStartDateFilter.toJSON() : "") + "&"; 
        if (maxRestructureEndDateFilter !== undefined)
            url_ += "MaxRestructureEndDateFilter=" + encodeURIComponent(maxRestructureEndDateFilter ? "" + maxRestructureEndDateFilter.toJSON() : "") + "&"; 
        if (minRestructureEndDateFilter !== undefined)
            url_ += "MinRestructureEndDateFilter=" + encodeURIComponent(minRestructureEndDateFilter ? "" + minRestructureEndDateFilter.toJSON() : "") + "&"; 
        if (principalPaymentTermsOriginationFilter !== undefined)
            url_ += "PrincipalPaymentTermsOriginationFilter=" + encodeURIComponent("" + principalPaymentTermsOriginationFilter) + "&"; 
        if (maxPPTOPeriodFilter !== undefined)
            url_ += "MaxPPTOPeriodFilter=" + encodeURIComponent("" + maxPPTOPeriodFilter) + "&"; 
        if (minPPTOPeriodFilter !== undefined)
            url_ += "MinPPTOPeriodFilter=" + encodeURIComponent("" + minPPTOPeriodFilter) + "&"; 
        if (interestPaymentTermsOriginationFilter !== undefined)
            url_ += "InterestPaymentTermsOriginationFilter=" + encodeURIComponent("" + interestPaymentTermsOriginationFilter) + "&"; 
        if (maxIPTOPeriodFilter !== undefined)
            url_ += "MaxIPTOPeriodFilter=" + encodeURIComponent("" + maxIPTOPeriodFilter) + "&"; 
        if (minIPTOPeriodFilter !== undefined)
            url_ += "MinIPTOPeriodFilter=" + encodeURIComponent("" + minIPTOPeriodFilter) + "&"; 
        if (principalPaymentStructureFilter !== undefined)
            url_ += "PrincipalPaymentStructureFilter=" + encodeURIComponent("" + principalPaymentStructureFilter) + "&"; 
        if (interestPaymentStructureFilter !== undefined)
            url_ += "InterestPaymentStructureFilter=" + encodeURIComponent("" + interestPaymentStructureFilter) + "&"; 
        if (interestRateTypeFilter !== undefined)
            url_ += "InterestRateTypeFilter=" + encodeURIComponent("" + interestRateTypeFilter) + "&"; 
        if (baseRateFilter !== undefined)
            url_ += "BaseRateFilter=" + encodeURIComponent("" + baseRateFilter) + "&"; 
        if (originationContractualInterestRateFilter !== undefined)
            url_ += "OriginationContractualInterestRateFilter=" + encodeURIComponent("" + originationContractualInterestRateFilter) + "&"; 
        if (maxIntroductoryPeriodFilter !== undefined)
            url_ += "MaxIntroductoryPeriodFilter=" + encodeURIComponent("" + maxIntroductoryPeriodFilter) + "&"; 
        if (minIntroductoryPeriodFilter !== undefined)
            url_ += "MinIntroductoryPeriodFilter=" + encodeURIComponent("" + minIntroductoryPeriodFilter) + "&"; 
        if (maxPostIPContractualInterestRateFilter !== undefined)
            url_ += "MaxPostIPContractualInterestRateFilter=" + encodeURIComponent("" + maxPostIPContractualInterestRateFilter) + "&"; 
        if (minPostIPContractualInterestRateFilter !== undefined)
            url_ += "MinPostIPContractualInterestRateFilter=" + encodeURIComponent("" + minPostIPContractualInterestRateFilter) + "&"; 
        if (maxCurrentContractualInterestRateFilter !== undefined)
            url_ += "MaxCurrentContractualInterestRateFilter=" + encodeURIComponent("" + maxCurrentContractualInterestRateFilter) + "&"; 
        if (minCurrentContractualInterestRateFilter !== undefined)
            url_ += "MinCurrentContractualInterestRateFilter=" + encodeURIComponent("" + minCurrentContractualInterestRateFilter) + "&"; 
        if (maxEIRFilter !== undefined)
            url_ += "MaxEIRFilter=" + encodeURIComponent("" + maxEIRFilter) + "&"; 
        if (minEIRFilter !== undefined)
            url_ += "MinEIRFilter=" + encodeURIComponent("" + minEIRFilter) + "&"; 
        if (maxDebentureOMVFilter !== undefined)
            url_ += "MaxDebentureOMVFilter=" + encodeURIComponent("" + maxDebentureOMVFilter) + "&"; 
        if (minDebentureOMVFilter !== undefined)
            url_ += "MinDebentureOMVFilter=" + encodeURIComponent("" + minDebentureOMVFilter) + "&"; 
        if (maxDebentureFSVFilter !== undefined)
            url_ += "MaxDebentureFSVFilter=" + encodeURIComponent("" + maxDebentureFSVFilter) + "&"; 
        if (minDebentureFSVFilter !== undefined)
            url_ += "MinDebentureFSVFilter=" + encodeURIComponent("" + minDebentureFSVFilter) + "&"; 
        if (maxCashOMVFilter !== undefined)
            url_ += "MaxCashOMVFilter=" + encodeURIComponent("" + maxCashOMVFilter) + "&"; 
        if (minCashOMVFilter !== undefined)
            url_ += "MinCashOMVFilter=" + encodeURIComponent("" + minCashOMVFilter) + "&"; 
        if (maxCashFSVFilter !== undefined)
            url_ += "MaxCashFSVFilter=" + encodeURIComponent("" + maxCashFSVFilter) + "&"; 
        if (minCashFSVFilter !== undefined)
            url_ += "MinCashFSVFilter=" + encodeURIComponent("" + minCashFSVFilter) + "&"; 
        if (maxInventoryOMVFilter !== undefined)
            url_ += "MaxInventoryOMVFilter=" + encodeURIComponent("" + maxInventoryOMVFilter) + "&"; 
        if (minInventoryOMVFilter !== undefined)
            url_ += "MinInventoryOMVFilter=" + encodeURIComponent("" + minInventoryOMVFilter) + "&"; 
        if (maxInventoryFSVFilter !== undefined)
            url_ += "MaxInventoryFSVFilter=" + encodeURIComponent("" + maxInventoryFSVFilter) + "&"; 
        if (minInventoryFSVFilter !== undefined)
            url_ += "MinInventoryFSVFilter=" + encodeURIComponent("" + minInventoryFSVFilter) + "&"; 
        if (maxPlantEquipmentOMVFilter !== undefined)
            url_ += "MaxPlantEquipmentOMVFilter=" + encodeURIComponent("" + maxPlantEquipmentOMVFilter) + "&"; 
        if (minPlantEquipmentOMVFilter !== undefined)
            url_ += "MinPlantEquipmentOMVFilter=" + encodeURIComponent("" + minPlantEquipmentOMVFilter) + "&"; 
        if (maxPlantEquipmentFSVFilter !== undefined)
            url_ += "MaxPlantEquipmentFSVFilter=" + encodeURIComponent("" + maxPlantEquipmentFSVFilter) + "&"; 
        if (minPlantEquipmentFSVFilter !== undefined)
            url_ += "MinPlantEquipmentFSVFilter=" + encodeURIComponent("" + minPlantEquipmentFSVFilter) + "&"; 
        if (maxResidentialPropertyOMVFilter !== undefined)
            url_ += "MaxResidentialPropertyOMVFilter=" + encodeURIComponent("" + maxResidentialPropertyOMVFilter) + "&"; 
        if (minResidentialPropertyOMVFilter !== undefined)
            url_ += "MinResidentialPropertyOMVFilter=" + encodeURIComponent("" + minResidentialPropertyOMVFilter) + "&"; 
        if (maxResidentialPropertyFSVFilter !== undefined)
            url_ += "MaxResidentialPropertyFSVFilter=" + encodeURIComponent("" + maxResidentialPropertyFSVFilter) + "&"; 
        if (minResidentialPropertyFSVFilter !== undefined)
            url_ += "MinResidentialPropertyFSVFilter=" + encodeURIComponent("" + minResidentialPropertyFSVFilter) + "&"; 
        if (maxCommercialPropertyOMVFilter !== undefined)
            url_ += "MaxCommercialPropertyOMVFilter=" + encodeURIComponent("" + maxCommercialPropertyOMVFilter) + "&"; 
        if (minCommercialPropertyOMVFilter !== undefined)
            url_ += "MinCommercialPropertyOMVFilter=" + encodeURIComponent("" + minCommercialPropertyOMVFilter) + "&"; 
        if (maxCommercialPropertyFilter !== undefined)
            url_ += "MaxCommercialPropertyFilter=" + encodeURIComponent("" + maxCommercialPropertyFilter) + "&"; 
        if (minCommercialPropertyFilter !== undefined)
            url_ += "MinCommercialPropertyFilter=" + encodeURIComponent("" + minCommercialPropertyFilter) + "&"; 
        if (maxReceivablesOMVFilter !== undefined)
            url_ += "MaxReceivablesOMVFilter=" + encodeURIComponent("" + maxReceivablesOMVFilter) + "&"; 
        if (minReceivablesOMVFilter !== undefined)
            url_ += "MinReceivablesOMVFilter=" + encodeURIComponent("" + minReceivablesOMVFilter) + "&"; 
        if (maxReceivablesFSVFilter !== undefined)
            url_ += "MaxReceivablesFSVFilter=" + encodeURIComponent("" + maxReceivablesFSVFilter) + "&"; 
        if (minReceivablesFSVFilter !== undefined)
            url_ += "MinReceivablesFSVFilter=" + encodeURIComponent("" + minReceivablesFSVFilter) + "&"; 
        if (maxSharesOMVFilter !== undefined)
            url_ += "MaxSharesOMVFilter=" + encodeURIComponent("" + maxSharesOMVFilter) + "&"; 
        if (minSharesOMVFilter !== undefined)
            url_ += "MinSharesOMVFilter=" + encodeURIComponent("" + minSharesOMVFilter) + "&"; 
        if (maxSharesFSVFilter !== undefined)
            url_ += "MaxSharesFSVFilter=" + encodeURIComponent("" + maxSharesFSVFilter) + "&"; 
        if (minSharesFSVFilter !== undefined)
            url_ += "MinSharesFSVFilter=" + encodeURIComponent("" + minSharesFSVFilter) + "&"; 
        if (maxVehicleOMVFilter !== undefined)
            url_ += "MaxVehicleOMVFilter=" + encodeURIComponent("" + maxVehicleOMVFilter) + "&"; 
        if (minVehicleOMVFilter !== undefined)
            url_ += "MinVehicleOMVFilter=" + encodeURIComponent("" + minVehicleOMVFilter) + "&"; 
        if (maxVehicleFSVFilter !== undefined)
            url_ += "MaxVehicleFSVFilter=" + encodeURIComponent("" + maxVehicleFSVFilter) + "&"; 
        if (minVehicleFSVFilter !== undefined)
            url_ += "MinVehicleFSVFilter=" + encodeURIComponent("" + minVehicleFSVFilter) + "&"; 
        if (maxCureRateFilter !== undefined)
            url_ += "MaxCureRateFilter=" + encodeURIComponent("" + maxCureRateFilter) + "&"; 
        if (minCureRateFilter !== undefined)
            url_ += "MinCureRateFilter=" + encodeURIComponent("" + minCureRateFilter) + "&"; 
        if (guaranteeIndicatorFilter !== undefined)
            url_ += "GuaranteeIndicatorFilter=" + encodeURIComponent("" + guaranteeIndicatorFilter) + "&"; 
        if (guarantorPDFilter !== undefined)
            url_ += "GuarantorPDFilter=" + encodeURIComponent("" + guarantorPDFilter) + "&"; 
        if (guarantorLGDFilter !== undefined)
            url_ += "GuarantorLGDFilter=" + encodeURIComponent("" + guarantorLGDFilter) + "&"; 
        if (maxGuaranteeValueFilter !== undefined)
            url_ += "MaxGuaranteeValueFilter=" + encodeURIComponent("" + maxGuaranteeValueFilter) + "&"; 
        if (minGuaranteeValueFilter !== undefined)
            url_ += "MinGuaranteeValueFilter=" + encodeURIComponent("" + minGuaranteeValueFilter) + "&"; 
        if (maxGuaranteeLevelFilter !== undefined)
            url_ += "MaxGuaranteeLevelFilter=" + encodeURIComponent("" + maxGuaranteeLevelFilter) + "&"; 
        if (minGuaranteeLevelFilter !== undefined)
            url_ += "MinGuaranteeLevelFilter=" + encodeURIComponent("" + minGuaranteeLevelFilter) + "&"; 
        if (contractIdFilter !== undefined)
            url_ += "ContractIdFilter=" + encodeURIComponent("" + contractIdFilter) + "&"; 
        if (obeEclUploadTenantIdFilter !== undefined)
            url_ += "ObeEclUploadTenantIdFilter=" + encodeURIComponent("" + obeEclUploadTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclDataLoanBookForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclDataLoanBookForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclDataLoanBookForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclDataLoanBookForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclDataLoanBookForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclDataLoanBookForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclDataLoanBookForEdit(id: string | null | undefined): Observable<GetObeEclDataLoanBookForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataLoanBooks/GetObeEclDataLoanBookForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclDataLoanBookForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclDataLoanBookForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclDataLoanBookForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclDataLoanBookForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclDataLoanBookForEdit(response: HttpResponseBase): Observable<GetObeEclDataLoanBookForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclDataLoanBookForEditOutput.fromJS(resultData200) : new GetObeEclDataLoanBookForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclDataLoanBookForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclDataLoanBookDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataLoanBooks/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataLoanBooks/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataLoanBooks/GetAllObeEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclDataPaymentSchedulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param contractRefNoFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param componentFilter (optional) 
     * @param maxNoOfSchedulesFilter (optional) 
     * @param minNoOfSchedulesFilter (optional) 
     * @param frequencyFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param obeEclUploadTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, contractRefNoFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, componentFilter: string | null | undefined, maxNoOfSchedulesFilter: number | null | undefined, minNoOfSchedulesFilter: number | null | undefined, frequencyFilter: string | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, obeEclUploadTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataPaymentSchedules/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (contractRefNoFilter !== undefined)
            url_ += "ContractRefNoFilter=" + encodeURIComponent("" + contractRefNoFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (componentFilter !== undefined)
            url_ += "ComponentFilter=" + encodeURIComponent("" + componentFilter) + "&"; 
        if (maxNoOfSchedulesFilter !== undefined)
            url_ += "MaxNoOfSchedulesFilter=" + encodeURIComponent("" + maxNoOfSchedulesFilter) + "&"; 
        if (minNoOfSchedulesFilter !== undefined)
            url_ += "MinNoOfSchedulesFilter=" + encodeURIComponent("" + minNoOfSchedulesFilter) + "&"; 
        if (frequencyFilter !== undefined)
            url_ += "FrequencyFilter=" + encodeURIComponent("" + frequencyFilter) + "&"; 
        if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&"; 
        if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&"; 
        if (obeEclUploadTenantIdFilter !== undefined)
            url_ += "ObeEclUploadTenantIdFilter=" + encodeURIComponent("" + obeEclUploadTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclDataPaymentScheduleForEdit(id: string | null | undefined): Observable<GetObeEclDataPaymentScheduleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataPaymentSchedules/GetObeEclDataPaymentScheduleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclDataPaymentScheduleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclDataPaymentScheduleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclDataPaymentScheduleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclDataPaymentScheduleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclDataPaymentScheduleForEdit(response: HttpResponseBase): Observable<GetObeEclDataPaymentScheduleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclDataPaymentScheduleForEditOutput.fromJS(resultData200) : new GetObeEclDataPaymentScheduleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclDataPaymentScheduleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclDataPaymentScheduleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataPaymentSchedules/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataPaymentSchedules/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclDataPaymentSchedules/GetAllObeEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclEadInputAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param inputNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param datatypeFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param eadGroupFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, inputNameFilter: string | null | undefined, valueFilter: string | null | undefined, datatypeFilter: number | null | undefined, isComputedFilter: number | null | undefined, eadGroupFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclEadInputAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (datatypeFilter !== undefined)
            url_ += "DatatypeFilter=" + encodeURIComponent("" + datatypeFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (eadGroupFilter !== undefined)
            url_ += "EadGroupFilter=" + encodeURIComponent("" + eadGroupFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclEadInputAssumptionForEdit(id: string | null | undefined): Observable<GetObeEclEadInputAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclEadInputAssumptions/GetObeEclEadInputAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclEadInputAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclEadInputAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclEadInputAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclEadInputAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclEadInputAssumptionForEdit(response: HttpResponseBase): Observable<GetObeEclEadInputAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclEadInputAssumptionForEditOutput.fromJS(resultData200) : new GetObeEclEadInputAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclEadInputAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclEadInputAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclEadInputAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclEadInputAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclEadInputAssumptions/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclLgdAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param inputNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param dataTypeFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param lgdGroupFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, inputNameFilter: string | null | undefined, valueFilter: string | null | undefined, dataTypeFilter: number | null | undefined, isComputedFilter: number | null | undefined, lgdGroupFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclLgdAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclLgdAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (dataTypeFilter !== undefined)
            url_ += "DataTypeFilter=" + encodeURIComponent("" + dataTypeFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (lgdGroupFilter !== undefined)
            url_ += "LgdGroupFilter=" + encodeURIComponent("" + lgdGroupFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclLgdAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclLgdAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclLgdAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclLgdAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclLgdAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclLgdAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclLgdAssumptionForEdit(id: string | null | undefined): Observable<GetObeEclLgdAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclLgdAssumptions/GetObeEclLgdAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclLgdAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclLgdAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclLgdAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclLgdAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclLgdAssumptionForEdit(response: HttpResponseBase): Observable<GetObeEclLgdAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclLgdAssumptionForEditOutput.fromJS(resultData200) : new GetObeEclLgdAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclLgdAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclLgdAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclLgdAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclLgdAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclLgdAssumptions/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdAssumption12MonthsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxCreditFilter (optional) 
     * @param minCreditFilter (optional) 
     * @param maxPDFilter (optional) 
     * @param minPDFilter (optional) 
     * @param snPMappingEtiCreditPolicyFilter (optional) 
     * @param snPMappingBestFitFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxCreditFilter: number | null | undefined, minCreditFilter: number | null | undefined, maxPDFilter: number | null | undefined, minPDFilter: number | null | undefined, snPMappingEtiCreditPolicyFilter: string | null | undefined, snPMappingBestFitFilter: string | null | undefined, requiresGroupApprovalFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumption12Months/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxCreditFilter !== undefined)
            url_ += "MaxCreditFilter=" + encodeURIComponent("" + maxCreditFilter) + "&"; 
        if (minCreditFilter !== undefined)
            url_ += "MinCreditFilter=" + encodeURIComponent("" + minCreditFilter) + "&"; 
        if (maxPDFilter !== undefined)
            url_ += "MaxPDFilter=" + encodeURIComponent("" + maxPDFilter) + "&"; 
        if (minPDFilter !== undefined)
            url_ += "MinPDFilter=" + encodeURIComponent("" + minPDFilter) + "&"; 
        if (snPMappingEtiCreditPolicyFilter !== undefined)
            url_ += "SnPMappingEtiCreditPolicyFilter=" + encodeURIComponent("" + snPMappingEtiCreditPolicyFilter) + "&"; 
        if (snPMappingBestFitFilter !== undefined)
            url_ += "SnPMappingBestFitFilter=" + encodeURIComponent("" + snPMappingBestFitFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdAssumption12MonthForEdit(id: string | null | undefined): Observable<GetObeEclPdAssumption12MonthForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumption12Months/GetObeEclPdAssumption12MonthForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdAssumption12MonthForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdAssumption12MonthForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdAssumption12MonthForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdAssumption12MonthForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdAssumption12MonthForEdit(response: HttpResponseBase): Observable<GetObeEclPdAssumption12MonthForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdAssumption12MonthForEditOutput.fromJS(resultData200) : new GetObeEclPdAssumption12MonthForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdAssumption12MonthForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdAssumption12MonthDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumption12Months/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumption12Months/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumption12Months/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdAssumptionMacroeconomicInputsesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicInputses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdAssumptionMacroeconomicInputsForEdit(id: string | null | undefined): Observable<GetObeEclPdAssumptionMacroeconomicInputsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicInputses/GetObeEclPdAssumptionMacroeconomicInputsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdAssumptionMacroeconomicInputsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdAssumptionMacroeconomicInputsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdAssumptionMacroeconomicInputsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdAssumptionMacroeconomicInputsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdAssumptionMacroeconomicInputsForEdit(response: HttpResponseBase): Observable<GetObeEclPdAssumptionMacroeconomicInputsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdAssumptionMacroeconomicInputsForEditOutput.fromJS(resultData200) : new GetObeEclPdAssumptionMacroeconomicInputsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdAssumptionMacroeconomicInputsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicInputses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicInputses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicInputses/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdAssumptionMacroeconomicProjectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicProjections/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdAssumptionMacroeconomicProjectionForEdit(id: string | null | undefined): Observable<GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicProjections/GetObeEclPdAssumptionMacroeconomicProjectionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdAssumptionMacroeconomicProjectionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdAssumptionMacroeconomicProjectionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdAssumptionMacroeconomicProjectionForEdit(response: HttpResponseBase): Observable<GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput.fromJS(resultData200) : new GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicProjections/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicProjections/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionMacroeconomicProjections/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdAssumptionNonInternalModelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNonInternalModels/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdAssumptionNonInternalModelForEdit(id: string | null | undefined): Observable<GetObeEclPdAssumptionNonInternalModelForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNonInternalModels/GetObeEclPdAssumptionNonInternalModelForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdAssumptionNonInternalModelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdAssumptionNonInternalModelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdAssumptionNonInternalModelForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdAssumptionNonInternalModelForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdAssumptionNonInternalModelForEdit(response: HttpResponseBase): Observable<GetObeEclPdAssumptionNonInternalModelForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdAssumptionNonInternalModelForEditOutput.fromJS(resultData200) : new GetObeEclPdAssumptionNonInternalModelForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdAssumptionNonInternalModelForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdAssumptionNonInternalModelDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNonInternalModels/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNonInternalModels/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNonInternalModels/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdAssumptionNplIndexesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNplIndexes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdAssumptionNplIndexForEdit(id: string | null | undefined): Observable<GetObeEclPdAssumptionNplIndexForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNplIndexes/GetObeEclPdAssumptionNplIndexForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdAssumptionNplIndexForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdAssumptionNplIndexForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdAssumptionNplIndexForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdAssumptionNplIndexForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdAssumptionNplIndexForEdit(response: HttpResponseBase): Observable<GetObeEclPdAssumptionNplIndexForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdAssumptionNplIndexForEditOutput.fromJS(resultData200) : new GetObeEclPdAssumptionNplIndexForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdAssumptionNplIndexForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdAssumptionNplIndexDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNplIndexes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNplIndexes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptionNplIndexes/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdAssumptionForEdit(id: string | null | undefined): Observable<GetObeEclPdAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptions/GetObeEclPdAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdAssumptionForEdit(response: HttpResponseBase): Observable<GetObeEclPdAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdAssumptionForEditOutput.fromJS(resultData200) : new GetObeEclPdAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdAssumptions/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclPdSnPCummulativeDefaultRatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param ratingFilter (optional) 
     * @param maxYearsFilter (optional) 
     * @param minYearsFilter (optional) 
     * @param maxValueFilter (optional) 
     * @param minValueFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, ratingFilter: string | null | undefined, maxYearsFilter: number | null | undefined, minYearsFilter: number | null | undefined, maxValueFilter: number | null | undefined, minValueFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdSnPCummulativeDefaultRates/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (ratingFilter !== undefined)
            url_ += "RatingFilter=" + encodeURIComponent("" + ratingFilter) + "&"; 
        if (maxYearsFilter !== undefined)
            url_ += "MaxYearsFilter=" + encodeURIComponent("" + maxYearsFilter) + "&"; 
        if (minYearsFilter !== undefined)
            url_ += "MinYearsFilter=" + encodeURIComponent("" + minYearsFilter) + "&"; 
        if (maxValueFilter !== undefined)
            url_ += "MaxValueFilter=" + encodeURIComponent("" + maxValueFilter) + "&"; 
        if (minValueFilter !== undefined)
            url_ += "MinValueFilter=" + encodeURIComponent("" + minValueFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclPdSnPCummulativeDefaultRateForEdit(id: string | null | undefined): Observable<GetObeEclPdSnPCummulativeDefaultRateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdSnPCummulativeDefaultRates/GetObeEclPdSnPCummulativeDefaultRateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclPdSnPCummulativeDefaultRateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclPdSnPCummulativeDefaultRateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclPdSnPCummulativeDefaultRateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclPdSnPCummulativeDefaultRateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclPdSnPCummulativeDefaultRateForEdit(response: HttpResponseBase): Observable<GetObeEclPdSnPCummulativeDefaultRateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclPdSnPCummulativeDefaultRateForEditOutput.fromJS(resultData200) : new GetObeEclPdSnPCummulativeDefaultRateForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclPdSnPCummulativeDefaultRateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclPdSnPCummulativeDefaultRateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdSnPCummulativeDefaultRates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdSnPCummulativeDefaultRates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclPdSnPCummulativeDefaultRates/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclResultDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param contractIDFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param customerNoFilter (optional) 
     * @param segmentFilter (optional) 
     * @param productTypeFilter (optional) 
     * @param sectorFilter (optional) 
     * @param maxStageFilter (optional) 
     * @param minStageFilter (optional) 
     * @param maxOutstandingBalanceFilter (optional) 
     * @param minOutstandingBalanceFilter (optional) 
     * @param maxPreOverrideEclBestFilter (optional) 
     * @param minPreOverrideEclBestFilter (optional) 
     * @param maxPreOverrideEclOptimisticFilter (optional) 
     * @param minPreOverrideEclOptimisticFilter (optional) 
     * @param maxPreOverrideEclDownturnFilter (optional) 
     * @param minPreOverrideEclDownturnFilter (optional) 
     * @param maxOverrideStageFilter (optional) 
     * @param minOverrideStageFilter (optional) 
     * @param maxOverrideTTRYearsFilter (optional) 
     * @param minOverrideTTRYearsFilter (optional) 
     * @param maxOverrideFSVFilter (optional) 
     * @param minOverrideFSVFilter (optional) 
     * @param maxOverrideOverlayFilter (optional) 
     * @param minOverrideOverlayFilter (optional) 
     * @param maxPostOverrideEclBestFilter (optional) 
     * @param minPostOverrideEclBestFilter (optional) 
     * @param maxPostOverrideEclOptimisticFilter (optional) 
     * @param minPostOverrideEclOptimisticFilter (optional) 
     * @param maxPostOverrideEclDownturnFilter (optional) 
     * @param minPostOverrideEclDownturnFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param obeEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, contractIDFilter: string | null | undefined, accountNoFilter: string | null | undefined, customerNoFilter: string | null | undefined, segmentFilter: string | null | undefined, productTypeFilter: string | null | undefined, sectorFilter: string | null | undefined, maxStageFilter: number | null | undefined, minStageFilter: number | null | undefined, maxOutstandingBalanceFilter: number | null | undefined, minOutstandingBalanceFilter: number | null | undefined, maxPreOverrideEclBestFilter: number | null | undefined, minPreOverrideEclBestFilter: number | null | undefined, maxPreOverrideEclOptimisticFilter: number | null | undefined, minPreOverrideEclOptimisticFilter: number | null | undefined, maxPreOverrideEclDownturnFilter: number | null | undefined, minPreOverrideEclDownturnFilter: number | null | undefined, maxOverrideStageFilter: number | null | undefined, minOverrideStageFilter: number | null | undefined, maxOverrideTTRYearsFilter: number | null | undefined, minOverrideTTRYearsFilter: number | null | undefined, maxOverrideFSVFilter: number | null | undefined, minOverrideFSVFilter: number | null | undefined, maxOverrideOverlayFilter: number | null | undefined, minOverrideOverlayFilter: number | null | undefined, maxPostOverrideEclBestFilter: number | null | undefined, minPostOverrideEclBestFilter: number | null | undefined, maxPostOverrideEclOptimisticFilter: number | null | undefined, minPostOverrideEclOptimisticFilter: number | null | undefined, maxPostOverrideEclDownturnFilter: number | null | undefined, minPostOverrideEclDownturnFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, obeEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclResultDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (contractIDFilter !== undefined)
            url_ += "ContractIDFilter=" + encodeURIComponent("" + contractIDFilter) + "&"; 
        if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&"; 
        if (customerNoFilter !== undefined)
            url_ += "CustomerNoFilter=" + encodeURIComponent("" + customerNoFilter) + "&"; 
        if (segmentFilter !== undefined)
            url_ += "SegmentFilter=" + encodeURIComponent("" + segmentFilter) + "&"; 
        if (productTypeFilter !== undefined)
            url_ += "ProductTypeFilter=" + encodeURIComponent("" + productTypeFilter) + "&"; 
        if (sectorFilter !== undefined)
            url_ += "SectorFilter=" + encodeURIComponent("" + sectorFilter) + "&"; 
        if (maxStageFilter !== undefined)
            url_ += "MaxStageFilter=" + encodeURIComponent("" + maxStageFilter) + "&"; 
        if (minStageFilter !== undefined)
            url_ += "MinStageFilter=" + encodeURIComponent("" + minStageFilter) + "&"; 
        if (maxOutstandingBalanceFilter !== undefined)
            url_ += "MaxOutstandingBalanceFilter=" + encodeURIComponent("" + maxOutstandingBalanceFilter) + "&"; 
        if (minOutstandingBalanceFilter !== undefined)
            url_ += "MinOutstandingBalanceFilter=" + encodeURIComponent("" + minOutstandingBalanceFilter) + "&"; 
        if (maxPreOverrideEclBestFilter !== undefined)
            url_ += "MaxPreOverrideEclBestFilter=" + encodeURIComponent("" + maxPreOverrideEclBestFilter) + "&"; 
        if (minPreOverrideEclBestFilter !== undefined)
            url_ += "MinPreOverrideEclBestFilter=" + encodeURIComponent("" + minPreOverrideEclBestFilter) + "&"; 
        if (maxPreOverrideEclOptimisticFilter !== undefined)
            url_ += "MaxPreOverrideEclOptimisticFilter=" + encodeURIComponent("" + maxPreOverrideEclOptimisticFilter) + "&"; 
        if (minPreOverrideEclOptimisticFilter !== undefined)
            url_ += "MinPreOverrideEclOptimisticFilter=" + encodeURIComponent("" + minPreOverrideEclOptimisticFilter) + "&"; 
        if (maxPreOverrideEclDownturnFilter !== undefined)
            url_ += "MaxPreOverrideEclDownturnFilter=" + encodeURIComponent("" + maxPreOverrideEclDownturnFilter) + "&"; 
        if (minPreOverrideEclDownturnFilter !== undefined)
            url_ += "MinPreOverrideEclDownturnFilter=" + encodeURIComponent("" + minPreOverrideEclDownturnFilter) + "&"; 
        if (maxOverrideStageFilter !== undefined)
            url_ += "MaxOverrideStageFilter=" + encodeURIComponent("" + maxOverrideStageFilter) + "&"; 
        if (minOverrideStageFilter !== undefined)
            url_ += "MinOverrideStageFilter=" + encodeURIComponent("" + minOverrideStageFilter) + "&"; 
        if (maxOverrideTTRYearsFilter !== undefined)
            url_ += "MaxOverrideTTRYearsFilter=" + encodeURIComponent("" + maxOverrideTTRYearsFilter) + "&"; 
        if (minOverrideTTRYearsFilter !== undefined)
            url_ += "MinOverrideTTRYearsFilter=" + encodeURIComponent("" + minOverrideTTRYearsFilter) + "&"; 
        if (maxOverrideFSVFilter !== undefined)
            url_ += "MaxOverrideFSVFilter=" + encodeURIComponent("" + maxOverrideFSVFilter) + "&"; 
        if (minOverrideFSVFilter !== undefined)
            url_ += "MinOverrideFSVFilter=" + encodeURIComponent("" + minOverrideFSVFilter) + "&"; 
        if (maxOverrideOverlayFilter !== undefined)
            url_ += "MaxOverrideOverlayFilter=" + encodeURIComponent("" + maxOverrideOverlayFilter) + "&"; 
        if (minOverrideOverlayFilter !== undefined)
            url_ += "MinOverrideOverlayFilter=" + encodeURIComponent("" + minOverrideOverlayFilter) + "&"; 
        if (maxPostOverrideEclBestFilter !== undefined)
            url_ += "MaxPostOverrideEclBestFilter=" + encodeURIComponent("" + maxPostOverrideEclBestFilter) + "&"; 
        if (minPostOverrideEclBestFilter !== undefined)
            url_ += "MinPostOverrideEclBestFilter=" + encodeURIComponent("" + minPostOverrideEclBestFilter) + "&"; 
        if (maxPostOverrideEclOptimisticFilter !== undefined)
            url_ += "MaxPostOverrideEclOptimisticFilter=" + encodeURIComponent("" + maxPostOverrideEclOptimisticFilter) + "&"; 
        if (minPostOverrideEclOptimisticFilter !== undefined)
            url_ += "MinPostOverrideEclOptimisticFilter=" + encodeURIComponent("" + minPostOverrideEclOptimisticFilter) + "&"; 
        if (maxPostOverrideEclDownturnFilter !== undefined)
            url_ += "MaxPostOverrideEclDownturnFilter=" + encodeURIComponent("" + maxPostOverrideEclDownturnFilter) + "&"; 
        if (minPostOverrideEclDownturnFilter !== undefined)
            url_ += "MinPostOverrideEclDownturnFilter=" + encodeURIComponent("" + minPostOverrideEclDownturnFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (obeEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "ObeEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + obeEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclResultDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclResultDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclResultDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclResultDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclResultDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclResultDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclResultDetailForEdit(id: string | null | undefined): Observable<GetObeEclResultDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultDetails/GetObeEclResultDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclResultDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclResultDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclResultDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclResultDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclResultDetailForEdit(response: HttpResponseBase): Observable<GetObeEclResultDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclResultDetailForEditOutput.fromJS(resultData200) : new GetObeEclResultDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclResultDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclResultDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultDetails/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultDetails/GetAllObeEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclResultSummaryKeyInputsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pDGroupingFilter (optional) 
     * @param maxExposureFilter (optional) 
     * @param minExposureFilter (optional) 
     * @param maxCollateralFilter (optional) 
     * @param minCollateralFilter (optional) 
     * @param maxUnsecuredPercentageFilter (optional) 
     * @param minUnsecuredPercentageFilter (optional) 
     * @param maxPercentageOfBookFilter (optional) 
     * @param minPercentageOfBookFilter (optional) 
     * @param maxMonths6CummulativeBestPDsFilter (optional) 
     * @param minMonths6CummulativeBestPDsFilter (optional) 
     * @param maxMonths12CummulativeBestPDsFilter (optional) 
     * @param minMonths12CummulativeBestPDsFilter (optional) 
     * @param maxMonths24CummulativeBestPDsFilter (optional) 
     * @param minMonths24CummulativeBestPDsFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, pDGroupingFilter: string | null | undefined, maxExposureFilter: number | null | undefined, minExposureFilter: number | null | undefined, maxCollateralFilter: number | null | undefined, minCollateralFilter: number | null | undefined, maxUnsecuredPercentageFilter: number | null | undefined, minUnsecuredPercentageFilter: number | null | undefined, maxPercentageOfBookFilter: number | null | undefined, minPercentageOfBookFilter: number | null | undefined, maxMonths6CummulativeBestPDsFilter: number | null | undefined, minMonths6CummulativeBestPDsFilter: number | null | undefined, maxMonths12CummulativeBestPDsFilter: number | null | undefined, minMonths12CummulativeBestPDsFilter: number | null | undefined, maxMonths24CummulativeBestPDsFilter: number | null | undefined, minMonths24CummulativeBestPDsFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryKeyInputs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (pDGroupingFilter !== undefined)
            url_ += "PDGroupingFilter=" + encodeURIComponent("" + pDGroupingFilter) + "&"; 
        if (maxExposureFilter !== undefined)
            url_ += "MaxExposureFilter=" + encodeURIComponent("" + maxExposureFilter) + "&"; 
        if (minExposureFilter !== undefined)
            url_ += "MinExposureFilter=" + encodeURIComponent("" + minExposureFilter) + "&"; 
        if (maxCollateralFilter !== undefined)
            url_ += "MaxCollateralFilter=" + encodeURIComponent("" + maxCollateralFilter) + "&"; 
        if (minCollateralFilter !== undefined)
            url_ += "MinCollateralFilter=" + encodeURIComponent("" + minCollateralFilter) + "&"; 
        if (maxUnsecuredPercentageFilter !== undefined)
            url_ += "MaxUnsecuredPercentageFilter=" + encodeURIComponent("" + maxUnsecuredPercentageFilter) + "&"; 
        if (minUnsecuredPercentageFilter !== undefined)
            url_ += "MinUnsecuredPercentageFilter=" + encodeURIComponent("" + minUnsecuredPercentageFilter) + "&"; 
        if (maxPercentageOfBookFilter !== undefined)
            url_ += "MaxPercentageOfBookFilter=" + encodeURIComponent("" + maxPercentageOfBookFilter) + "&"; 
        if (minPercentageOfBookFilter !== undefined)
            url_ += "MinPercentageOfBookFilter=" + encodeURIComponent("" + minPercentageOfBookFilter) + "&"; 
        if (maxMonths6CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths6CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths6CummulativeBestPDsFilter) + "&"; 
        if (minMonths6CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths6CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths6CummulativeBestPDsFilter) + "&"; 
        if (maxMonths12CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths12CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths12CummulativeBestPDsFilter) + "&"; 
        if (minMonths12CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths12CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths12CummulativeBestPDsFilter) + "&"; 
        if (maxMonths24CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths24CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths24CummulativeBestPDsFilter) + "&"; 
        if (minMonths24CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths24CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths24CummulativeBestPDsFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclResultSummaryKeyInputForEdit(id: string | null | undefined): Observable<GetObeEclResultSummaryKeyInputForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryKeyInputs/GetObeEclResultSummaryKeyInputForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclResultSummaryKeyInputForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclResultSummaryKeyInputForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclResultSummaryKeyInputForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclResultSummaryKeyInputForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclResultSummaryKeyInputForEdit(response: HttpResponseBase): Observable<GetObeEclResultSummaryKeyInputForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclResultSummaryKeyInputForEditOutput.fromJS(resultData200) : new GetObeEclResultSummaryKeyInputForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclResultSummaryKeyInputForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclResultSummaryKeyInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryKeyInputs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryKeyInputs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryKeyInputs/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclResultSummaryTopExposuresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPreOverrideExposureFilter (optional) 
     * @param minPreOverrideExposureFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPreOverrideCoverageRatioFilter (optional) 
     * @param minPreOverrideCoverageRatioFilter (optional) 
     * @param maxPostOverrideExposureFilter (optional) 
     * @param minPostOverrideExposureFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideCoverageRatioFilter (optional) 
     * @param minPostOverrideCoverageRatioFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param obeEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxPreOverrideExposureFilter: number | null | undefined, minPreOverrideExposureFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPreOverrideCoverageRatioFilter: number | null | undefined, minPreOverrideCoverageRatioFilter: number | null | undefined, maxPostOverrideExposureFilter: number | null | undefined, minPostOverrideExposureFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, maxPostOverrideCoverageRatioFilter: number | null | undefined, minPostOverrideCoverageRatioFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, obeEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryTopExposures/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPreOverrideExposureFilter !== undefined)
            url_ += "MaxPreOverrideExposureFilter=" + encodeURIComponent("" + maxPreOverrideExposureFilter) + "&"; 
        if (minPreOverrideExposureFilter !== undefined)
            url_ += "MinPreOverrideExposureFilter=" + encodeURIComponent("" + minPreOverrideExposureFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPreOverrideCoverageRatioFilter) + "&"; 
        if (minPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPreOverrideCoverageRatioFilter) + "&"; 
        if (maxPostOverrideExposureFilter !== undefined)
            url_ += "MaxPostOverrideExposureFilter=" + encodeURIComponent("" + maxPostOverrideExposureFilter) + "&"; 
        if (minPostOverrideExposureFilter !== undefined)
            url_ += "MinPostOverrideExposureFilter=" + encodeURIComponent("" + minPostOverrideExposureFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPostOverrideCoverageRatioFilter) + "&"; 
        if (minPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPostOverrideCoverageRatioFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (obeEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "ObeEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + obeEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclResultSummaryTopExposureForEdit(id: string | null | undefined): Observable<GetObeEclResultSummaryTopExposureForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryTopExposures/GetObeEclResultSummaryTopExposureForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclResultSummaryTopExposureForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclResultSummaryTopExposureForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclResultSummaryTopExposureForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclResultSummaryTopExposureForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclResultSummaryTopExposureForEdit(response: HttpResponseBase): Observable<GetObeEclResultSummaryTopExposureForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclResultSummaryTopExposureForEditOutput.fromJS(resultData200) : new GetObeEclResultSummaryTopExposureForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclResultSummaryTopExposureForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclResultSummaryTopExposureDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryTopExposures/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryTopExposures/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryTopExposures/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclResultSummaryTopExposures/GetAllObeEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReportingDateFilter (optional) 
     * @param minReportingDateFilter (optional) 
     * @param maxClosedDateFilter (optional) 
     * @param minClosedDateFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReportingDateFilter: moment.Moment | null | undefined, minReportingDateFilter: moment.Moment | null | undefined, maxClosedDateFilter: moment.Moment | null | undefined, minClosedDateFilter: moment.Moment | null | undefined, isApprovedFilter: number | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEcls/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReportingDateFilter !== undefined)
            url_ += "MaxReportingDateFilter=" + encodeURIComponent(maxReportingDateFilter ? "" + maxReportingDateFilter.toJSON() : "") + "&"; 
        if (minReportingDateFilter !== undefined)
            url_ += "MinReportingDateFilter=" + encodeURIComponent(minReportingDateFilter ? "" + minReportingDateFilter.toJSON() : "") + "&"; 
        if (maxClosedDateFilter !== undefined)
            url_ += "MaxClosedDateFilter=" + encodeURIComponent(maxClosedDateFilter ? "" + maxClosedDateFilter.toJSON() : "") + "&"; 
        if (minClosedDateFilter !== undefined)
            url_ += "MinClosedDateFilter=" + encodeURIComponent(minClosedDateFilter ? "" + minClosedDateFilter.toJSON() : "") + "&"; 
        if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclForEdit(id: string | null | undefined): Observable<GetObeEclForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEcls/GetObeEclForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclForEdit(response: HttpResponseBase): Observable<GetObeEclForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclForEditOutput.fromJS(resultData200) : new GetObeEclForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEcls/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEcls/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEcls/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclSicrApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param obeEclSicrTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, obeEclSicrTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclSicrApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (obeEclSicrTenantIdFilter !== undefined)
            url_ += "ObeEclSicrTenantIdFilter=" + encodeURIComponent("" + obeEclSicrTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclSicrApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclSicrApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclSicrApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclSicrApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclSicrApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclSicrApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclSicrApprovalForEdit(id: string | null | undefined): Observable<GetObeEclSicrApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrApprovals/GetObeEclSicrApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclSicrApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclSicrApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclSicrApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclSicrApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclSicrApprovalForEdit(response: HttpResponseBase): Observable<GetObeEclSicrApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclSicrApprovalForEditOutput.fromJS(resultData200) : new GetObeEclSicrApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclSicrApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclSicrApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclSicrForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrApprovals/GetAllObeEclSicrForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclSicrForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclSicrForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclSicrForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclSicrsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxComputedSICRFilter (optional) 
     * @param minComputedSICRFilter (optional) 
     * @param overrideSICRFilter (optional) 
     * @param overrideCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param obeEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxComputedSICRFilter: number | null | undefined, minComputedSICRFilter: number | null | undefined, overrideSICRFilter: string | null | undefined, overrideCommentFilter: string | null | undefined, statusFilter: number | null | undefined, obeEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclSicrForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxComputedSICRFilter !== undefined)
            url_ += "MaxComputedSICRFilter=" + encodeURIComponent("" + maxComputedSICRFilter) + "&"; 
        if (minComputedSICRFilter !== undefined)
            url_ += "MinComputedSICRFilter=" + encodeURIComponent("" + minComputedSICRFilter) + "&"; 
        if (overrideSICRFilter !== undefined)
            url_ += "OverrideSICRFilter=" + encodeURIComponent("" + overrideSICRFilter) + "&"; 
        if (overrideCommentFilter !== undefined)
            url_ += "OverrideCommentFilter=" + encodeURIComponent("" + overrideCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (obeEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "ObeEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + obeEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclSicrForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclSicrForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclSicrForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclSicrForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclSicrForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclSicrForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclSicrForEdit(id: string | null | undefined): Observable<GetObeEclSicrForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrs/GetObeEclSicrForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclSicrForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclSicrForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclSicrForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclSicrForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclSicrForEdit(response: HttpResponseBase): Observable<GetObeEclSicrForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclSicrForEditOutput.fromJS(resultData200) : new GetObeEclSicrForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclSicrForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclSicrDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclSicrs/GetAllObeEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclUploadApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param obeEclUploadTenantIdFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, obeEclUploadTenantIdFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclUploadApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploadApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (obeEclUploadTenantIdFilter !== undefined)
            url_ += "ObeEclUploadTenantIdFilter=" + encodeURIComponent("" + obeEclUploadTenantIdFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclUploadApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclUploadApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclUploadApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclUploadApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclUploadApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclUploadApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclUploadApprovalForEdit(id: string | null | undefined): Observable<GetObeEclUploadApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploadApprovals/GetObeEclUploadApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclUploadApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclUploadApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclUploadApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclUploadApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclUploadApprovalForEdit(response: HttpResponseBase): Observable<GetObeEclUploadApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclUploadApprovalForEditOutput.fromJS(resultData200) : new GetObeEclUploadApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclUploadApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclUploadApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploadApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploadApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploadApprovals/GetAllObeEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploadApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObeEclUploadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param docTypeFilter (optional) 
     * @param uploadCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, docTypeFilter: number | null | undefined, uploadCommentFilter: string | null | undefined, statusFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObeEclUploadForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploads/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (docTypeFilter !== undefined)
            url_ += "DocTypeFilter=" + encodeURIComponent("" + docTypeFilter) + "&"; 
        if (uploadCommentFilter !== undefined)
            url_ += "UploadCommentFilter=" + encodeURIComponent("" + uploadCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObeEclUploadForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObeEclUploadForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObeEclUploadForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObeEclUploadForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObeEclUploadForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObeEclUploadForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObeEclUploadForEdit(id: string | null | undefined): Observable<GetObeEclUploadForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploads/GetObeEclUploadForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObeEclUploadForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObeEclUploadForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObeEclUploadForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObeEclUploadForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObeEclUploadForEdit(response: HttpResponseBase): Observable<GetObeEclUploadForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObeEclUploadForEditOutput.fromJS(resultData200) : new GetObeEclUploadForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObeEclUploadForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObeEclUploadDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploads/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploads/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObeEclUploadObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObeEclUploads/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObeEclUploadObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObeEclUploadObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObeEclUploadObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObeEclUploadObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObeEclUploadObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObeEclUploadObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ObesaleEclResultSummariesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param summaryTypeFilter (optional) 
     * @param titleFilter (optional) 
     * @param maxPreOverrideExposureFilter (optional) 
     * @param minPreOverrideExposureFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPreOverrideCoverageRatioFilter (optional) 
     * @param minPreOverrideCoverageRatioFilter (optional) 
     * @param maxPostOverrideExposureFilter (optional) 
     * @param minPostOverrideExposureFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideCoverageRatioFilter (optional) 
     * @param minPostOverrideCoverageRatioFilter (optional) 
     * @param obeEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, summaryTypeFilter: number | null | undefined, titleFilter: string | null | undefined, maxPreOverrideExposureFilter: number | null | undefined, minPreOverrideExposureFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPreOverrideCoverageRatioFilter: number | null | undefined, minPreOverrideCoverageRatioFilter: number | null | undefined, maxPostOverrideExposureFilter: number | null | undefined, minPostOverrideExposureFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, maxPostOverrideCoverageRatioFilter: number | null | undefined, minPostOverrideCoverageRatioFilter: number | null | undefined, obeEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetObesaleEclResultSummaryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ObesaleEclResultSummaries/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (summaryTypeFilter !== undefined)
            url_ += "SummaryTypeFilter=" + encodeURIComponent("" + summaryTypeFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (maxPreOverrideExposureFilter !== undefined)
            url_ += "MaxPreOverrideExposureFilter=" + encodeURIComponent("" + maxPreOverrideExposureFilter) + "&"; 
        if (minPreOverrideExposureFilter !== undefined)
            url_ += "MinPreOverrideExposureFilter=" + encodeURIComponent("" + minPreOverrideExposureFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPreOverrideCoverageRatioFilter) + "&"; 
        if (minPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPreOverrideCoverageRatioFilter) + "&"; 
        if (maxPostOverrideExposureFilter !== undefined)
            url_ += "MaxPostOverrideExposureFilter=" + encodeURIComponent("" + maxPostOverrideExposureFilter) + "&"; 
        if (minPostOverrideExposureFilter !== undefined)
            url_ += "MinPostOverrideExposureFilter=" + encodeURIComponent("" + minPostOverrideExposureFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPostOverrideCoverageRatioFilter) + "&"; 
        if (minPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPostOverrideCoverageRatioFilter) + "&"; 
        if (obeEclTenantIdFilter !== undefined)
            url_ += "ObeEclTenantIdFilter=" + encodeURIComponent("" + obeEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetObesaleEclResultSummaryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetObesaleEclResultSummaryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetObesaleEclResultSummaryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetObesaleEclResultSummaryForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetObesaleEclResultSummaryForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetObesaleEclResultSummaryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getObesaleEclResultSummaryForEdit(id: string | null | undefined): Observable<GetObesaleEclResultSummaryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ObesaleEclResultSummaries/GetObesaleEclResultSummaryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetObesaleEclResultSummaryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetObesaleEclResultSummaryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetObesaleEclResultSummaryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetObesaleEclResultSummaryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetObesaleEclResultSummaryForEdit(response: HttpResponseBase): Observable<GetObesaleEclResultSummaryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetObesaleEclResultSummaryForEditOutput.fromJS(resultData200) : new GetObesaleEclResultSummaryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetObesaleEclResultSummaryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditObesaleEclResultSummaryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObesaleEclResultSummaries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ObesaleEclResultSummaries/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllObeEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ObesaleEclResultSummaries/GetAllObeEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllObeEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllObeEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllObeEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findRoles(input: FindOrganizationUnitRolesInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentAsync?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalPaymentId (optional) 
     * @param paypalPayerId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | null | undefined, paypalPaymentId: string | null | undefined, paypalPayerId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalPaymentId !== undefined)
            url_ += "paypalPaymentId=" + encodeURIComponent("" + paypalPaymentId) + "&"; 
        if (paypalPayerId !== undefined)
            url_ += "paypalPayerId=" + encodeURIComponent("" + paypalPayerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalConfigurationDto.fromJS(resultData200) : new PayPalConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PdInputAssumptionMacroeconomicProjectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionMacroeconomicProjections/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPdInputAssumptionMacroeconomicProjectionForEdit(id: string | null | undefined): Observable<GetPdInputAssumptionMacroeconomicProjectionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionMacroeconomicProjections/GetPdInputAssumptionMacroeconomicProjectionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPdInputAssumptionMacroeconomicProjectionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdInputAssumptionMacroeconomicProjectionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPdInputAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPdInputAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdInputAssumptionMacroeconomicProjectionForEdit(response: HttpResponseBase): Observable<GetPdInputAssumptionMacroeconomicProjectionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPdInputAssumptionMacroeconomicProjectionForEditOutput.fromJS(resultData200) : new GetPdInputAssumptionMacroeconomicProjectionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPdInputAssumptionMacroeconomicProjectionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditPdInputAssumptionMacroeconomicProjectionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionMacroeconomicProjections/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionMacroeconomicProjections/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PdInputAssumptionNonInternalModelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNonInternalModels/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPdInputAssumptionNonInternalModelForEdit(id: string | null | undefined): Observable<GetPdInputAssumptionNonInternalModelForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNonInternalModels/GetPdInputAssumptionNonInternalModelForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPdInputAssumptionNonInternalModelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdInputAssumptionNonInternalModelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPdInputAssumptionNonInternalModelForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPdInputAssumptionNonInternalModelForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdInputAssumptionNonInternalModelForEdit(response: HttpResponseBase): Observable<GetPdInputAssumptionNonInternalModelForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPdInputAssumptionNonInternalModelForEditOutput.fromJS(resultData200) : new GetPdInputAssumptionNonInternalModelForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPdInputAssumptionNonInternalModelForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditPdInputAssumptionNonInternalModelDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNonInternalModels/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNonInternalModels/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PdInputAssumptionNplIndexesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNplIndexes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPdInputAssumptionNplIndexForEdit(id: string | null | undefined): Observable<GetPdInputAssumptionNplIndexForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNplIndexes/GetPdInputAssumptionNplIndexForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPdInputAssumptionNplIndexForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdInputAssumptionNplIndexForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPdInputAssumptionNplIndexForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPdInputAssumptionNplIndexForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdInputAssumptionNplIndexForEdit(response: HttpResponseBase): Observable<GetPdInputAssumptionNplIndexForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPdInputAssumptionNplIndexForEditOutput.fromJS(resultData200) : new GetPdInputAssumptionNplIndexForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPdInputAssumptionNplIndexForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditPdInputAssumptionNplIndexDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNplIndexes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionNplIndexes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PdInputAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetPdInputAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPdInputAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPdInputAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPdInputAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPdInputAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPdInputAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPdInputAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPdInputAssumptionForEdit(id: string | null | undefined): Observable<GetPdInputAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptions/GetPdInputAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPdInputAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdInputAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPdInputAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPdInputAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdInputAssumptionForEdit(response: HttpResponseBase): Observable<GetPdInputAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPdInputAssumptionForEditOutput.fromJS(resultData200) : new GetPdInputAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPdInputAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditPdInputAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PdInputAssumptionStatisticalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param canAffiliateEditFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, canAffiliateEditFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionStatisticals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (canAffiliateEditFilter !== undefined)
            url_ += "CanAffiliateEditFilter=" + encodeURIComponent("" + canAffiliateEditFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPdInputAssumptionStatisticalForEdit(id: string | null | undefined): Observable<GetPdInputAssumptionStatisticalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionStatisticals/GetPdInputAssumptionStatisticalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPdInputAssumptionStatisticalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdInputAssumptionStatisticalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPdInputAssumptionStatisticalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPdInputAssumptionStatisticalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdInputAssumptionStatisticalForEdit(response: HttpResponseBase): Observable<GetPdInputAssumptionStatisticalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPdInputAssumptionStatisticalForEditOutput.fromJS(resultData200) : new GetPdInputAssumptionStatisticalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPdInputAssumptionStatisticalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditPdInputAssumptionStatisticalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionStatisticals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputAssumptionStatisticals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PdInputSnPCummulativeDefaultRatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param ratingFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, ratingFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/PdInputSnPCummulativeDefaultRates/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (ratingFilter !== undefined)
            url_ += "RatingFilter=" + encodeURIComponent("" + ratingFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPdInputSnPCummulativeDefaultRateForEdit(id: string | null | undefined): Observable<GetPdInputSnPCummulativeDefaultRateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PdInputSnPCummulativeDefaultRates/GetPdInputSnPCummulativeDefaultRateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPdInputSnPCummulativeDefaultRateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdInputSnPCummulativeDefaultRateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPdInputSnPCummulativeDefaultRateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPdInputSnPCummulativeDefaultRateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdInputSnPCummulativeDefaultRateForEdit(response: HttpResponseBase): Observable<GetPdInputSnPCummulativeDefaultRateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPdInputSnPCummulativeDefaultRateForEditOutput.fromJS(resultData200) : new GetPdInputSnPCummulativeDefaultRateForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPdInputSnPCummulativeDefaultRateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditPdInputSnPCummulativeDefaultRateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputSnPCummulativeDefaultRates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PdInputSnPCummulativeDefaultRates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendVerificationSms(input: SendVerificationSmsInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RetailEclApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclApprovalForEdit(id: string | null | undefined): Observable<GetRetailEclApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclApprovals/GetRetailEclApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclApprovalForEdit(response: HttpResponseBase): Observable<GetRetailEclApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclApprovalForEditOutput.fromJS(resultData200) : new GetRetailEclApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclApprovalUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclApprovals/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclAssumptionApprovalsesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param assumptionTypeFilter (optional) 
     * @param oldValueFilter (optional) 
     * @param newValueFilter (optional) 
     * @param maxDateReviewedFilter (optional) 
     * @param minDateReviewedFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param userNameFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, assumptionTypeFilter: number | null | undefined, oldValueFilter: string | null | undefined, newValueFilter: string | null | undefined, maxDateReviewedFilter: moment.Moment | null | undefined, minDateReviewedFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, userNameFilter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptionApprovalses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (assumptionTypeFilter !== undefined)
            url_ += "AssumptionTypeFilter=" + encodeURIComponent("" + assumptionTypeFilter) + "&"; 
        if (oldValueFilter !== undefined)
            url_ += "OldValueFilter=" + encodeURIComponent("" + oldValueFilter) + "&"; 
        if (newValueFilter !== undefined)
            url_ += "NewValueFilter=" + encodeURIComponent("" + newValueFilter) + "&"; 
        if (maxDateReviewedFilter !== undefined)
            url_ += "MaxDateReviewedFilter=" + encodeURIComponent(maxDateReviewedFilter ? "" + maxDateReviewedFilter.toJSON() : "") + "&"; 
        if (minDateReviewedFilter !== undefined)
            url_ += "MinDateReviewedFilter=" + encodeURIComponent(minDateReviewedFilter ? "" + minDateReviewedFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclAssumptionApprovalsForEdit(id: string | null | undefined): Observable<GetRetailEclAssumptionApprovalsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptionApprovalses/GetRetailEclAssumptionApprovalsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclAssumptionApprovalsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclAssumptionApprovalsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclAssumptionApprovalsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclAssumptionApprovalsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclAssumptionApprovalsForEdit(response: HttpResponseBase): Observable<GetRetailEclAssumptionApprovalsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclAssumptionApprovalsForEditOutput.fromJS(resultData200) : new GetRetailEclAssumptionApprovalsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclAssumptionApprovalsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclAssumptionApprovalsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptionApprovalses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptionApprovalses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptionApprovalses/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptionApprovalses/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param inputNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param datatypeFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param assumptionGroupFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, inputNameFilter: string | null | undefined, valueFilter: string | null | undefined, datatypeFilter: number | null | undefined, isComputedFilter: number | null | undefined, assumptionGroupFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (datatypeFilter !== undefined)
            url_ += "DatatypeFilter=" + encodeURIComponent("" + datatypeFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (assumptionGroupFilter !== undefined)
            url_ += "AssumptionGroupFilter=" + encodeURIComponent("" + assumptionGroupFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclAssumptionForEdit(id: string | null | undefined): Observable<GetRetailEclAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptions/GetRetailEclAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclAssumptionForEdit(response: HttpResponseBase): Observable<GetRetailEclAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclAssumptionForEditOutput.fromJS(resultData200) : new GetRetailEclAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclAssumptionsList(id: string | null | undefined): Observable<CreateOrEditRetailEclAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptions/GetRetailEclAssumptionsList?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclAssumptionsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclAssumptionsList(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditRetailEclAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditRetailEclAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclAssumptionsList(response: HttpResponseBase): Observable<CreateOrEditRetailEclAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateOrEditRetailEclAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditRetailEclAssumptionDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclAssumptions/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclDataLoanBooksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customerNoFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param contractNoFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param maxSnapshotDateFilter (optional) 
     * @param minSnapshotDateFilter (optional) 
     * @param segmentFilter (optional) 
     * @param sectorFilter (optional) 
     * @param currencyFilter (optional) 
     * @param productTypeFilter (optional) 
     * @param productMappingFilter (optional) 
     * @param specialisedLendingFilter (optional) 
     * @param ratingModelFilter (optional) 
     * @param maxOriginalRatingFilter (optional) 
     * @param minOriginalRatingFilter (optional) 
     * @param maxCurrentRatingFilter (optional) 
     * @param minCurrentRatingFilter (optional) 
     * @param maxLifetimePDFilter (optional) 
     * @param minLifetimePDFilter (optional) 
     * @param maxMonth12PDFilter (optional) 
     * @param minMonth12PDFilter (optional) 
     * @param maxDaysPastDueFilter (optional) 
     * @param minDaysPastDueFilter (optional) 
     * @param watchlistIndicatorFilter (optional) 
     * @param classificationFilter (optional) 
     * @param maxImpairedDateFilter (optional) 
     * @param minImpairedDateFilter (optional) 
     * @param maxDefaultDateFilter (optional) 
     * @param minDefaultDateFilter (optional) 
     * @param maxCreditLimitFilter (optional) 
     * @param minCreditLimitFilter (optional) 
     * @param maxOriginalBalanceLCYFilter (optional) 
     * @param minOriginalBalanceLCYFilter (optional) 
     * @param maxOutstandingBalanceLCYFilter (optional) 
     * @param minOutstandingBalanceLCYFilter (optional) 
     * @param maxOutstandingBalanceACYFilter (optional) 
     * @param minOutstandingBalanceACYFilter (optional) 
     * @param maxContractStartDateFilter (optional) 
     * @param minContractStartDateFilter (optional) 
     * @param maxContractEndDateFilter (optional) 
     * @param minContractEndDateFilter (optional) 
     * @param restructureIndicatorFilter (optional) 
     * @param restructureRiskFilter (optional) 
     * @param restructureTypeFilter (optional) 
     * @param maxRestructureStartDateFilter (optional) 
     * @param minRestructureStartDateFilter (optional) 
     * @param maxRestructureEndDateFilter (optional) 
     * @param minRestructureEndDateFilter (optional) 
     * @param principalPaymentTermsOriginationFilter (optional) 
     * @param maxPPTOPeriodFilter (optional) 
     * @param minPPTOPeriodFilter (optional) 
     * @param interestPaymentTermsOriginationFilter (optional) 
     * @param maxIPTOPeriodFilter (optional) 
     * @param minIPTOPeriodFilter (optional) 
     * @param principalPaymentStructureFilter (optional) 
     * @param interestPaymentStructureFilter (optional) 
     * @param interestRateTypeFilter (optional) 
     * @param baseRateFilter (optional) 
     * @param originationContractualInterestRateFilter (optional) 
     * @param maxIntroductoryPeriodFilter (optional) 
     * @param minIntroductoryPeriodFilter (optional) 
     * @param maxPostIPContractualInterestRateFilter (optional) 
     * @param minPostIPContractualInterestRateFilter (optional) 
     * @param maxCurrentContractualInterestRateFilter (optional) 
     * @param minCurrentContractualInterestRateFilter (optional) 
     * @param maxEIRFilter (optional) 
     * @param minEIRFilter (optional) 
     * @param maxDebentureOMVFilter (optional) 
     * @param minDebentureOMVFilter (optional) 
     * @param maxDebentureFSVFilter (optional) 
     * @param minDebentureFSVFilter (optional) 
     * @param maxCashOMVFilter (optional) 
     * @param minCashOMVFilter (optional) 
     * @param maxCashFSVFilter (optional) 
     * @param minCashFSVFilter (optional) 
     * @param maxInventoryOMVFilter (optional) 
     * @param minInventoryOMVFilter (optional) 
     * @param maxInventoryFSVFilter (optional) 
     * @param minInventoryFSVFilter (optional) 
     * @param maxPlantEquipmentOMVFilter (optional) 
     * @param minPlantEquipmentOMVFilter (optional) 
     * @param maxPlantEquipmentFSVFilter (optional) 
     * @param minPlantEquipmentFSVFilter (optional) 
     * @param maxResidentialPropertyOMVFilter (optional) 
     * @param minResidentialPropertyOMVFilter (optional) 
     * @param maxResidentialPropertyFSVFilter (optional) 
     * @param minResidentialPropertyFSVFilter (optional) 
     * @param maxCommercialPropertyOMVFilter (optional) 
     * @param minCommercialPropertyOMVFilter (optional) 
     * @param maxCommercialPropertyFilter (optional) 
     * @param minCommercialPropertyFilter (optional) 
     * @param maxReceivablesOMVFilter (optional) 
     * @param minReceivablesOMVFilter (optional) 
     * @param maxReceivablesFSVFilter (optional) 
     * @param minReceivablesFSVFilter (optional) 
     * @param maxSharesOMVFilter (optional) 
     * @param minSharesOMVFilter (optional) 
     * @param maxSharesFSVFilter (optional) 
     * @param minSharesFSVFilter (optional) 
     * @param maxVehicleOMVFilter (optional) 
     * @param minVehicleOMVFilter (optional) 
     * @param maxVehicleFSVFilter (optional) 
     * @param minVehicleFSVFilter (optional) 
     * @param maxCureRateFilter (optional) 
     * @param minCureRateFilter (optional) 
     * @param guaranteeIndicatorFilter (optional) 
     * @param guarantorPDFilter (optional) 
     * @param guarantorLGDFilter (optional) 
     * @param maxGuaranteeValueFilter (optional) 
     * @param minGuaranteeValueFilter (optional) 
     * @param maxGuaranteeLevelFilter (optional) 
     * @param minGuaranteeLevelFilter (optional) 
     * @param contractIdFilter (optional) 
     * @param retailEclUploadTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, customerNoFilter: string | null | undefined, accountNoFilter: string | null | undefined, contractNoFilter: string | null | undefined, customerNameFilter: string | null | undefined, maxSnapshotDateFilter: moment.Moment | null | undefined, minSnapshotDateFilter: moment.Moment | null | undefined, segmentFilter: string | null | undefined, sectorFilter: string | null | undefined, currencyFilter: string | null | undefined, productTypeFilter: string | null | undefined, productMappingFilter: string | null | undefined, specialisedLendingFilter: string | null | undefined, ratingModelFilter: string | null | undefined, maxOriginalRatingFilter: number | null | undefined, minOriginalRatingFilter: number | null | undefined, maxCurrentRatingFilter: number | null | undefined, minCurrentRatingFilter: number | null | undefined, maxLifetimePDFilter: number | null | undefined, minLifetimePDFilter: number | null | undefined, maxMonth12PDFilter: number | null | undefined, minMonth12PDFilter: number | null | undefined, maxDaysPastDueFilter: number | null | undefined, minDaysPastDueFilter: number | null | undefined, watchlistIndicatorFilter: number | null | undefined, classificationFilter: string | null | undefined, maxImpairedDateFilter: moment.Moment | null | undefined, minImpairedDateFilter: moment.Moment | null | undefined, maxDefaultDateFilter: moment.Moment | null | undefined, minDefaultDateFilter: moment.Moment | null | undefined, maxCreditLimitFilter: number | null | undefined, minCreditLimitFilter: number | null | undefined, maxOriginalBalanceLCYFilter: number | null | undefined, minOriginalBalanceLCYFilter: number | null | undefined, maxOutstandingBalanceLCYFilter: number | null | undefined, minOutstandingBalanceLCYFilter: number | null | undefined, maxOutstandingBalanceACYFilter: number | null | undefined, minOutstandingBalanceACYFilter: number | null | undefined, maxContractStartDateFilter: moment.Moment | null | undefined, minContractStartDateFilter: moment.Moment | null | undefined, maxContractEndDateFilter: moment.Moment | null | undefined, minContractEndDateFilter: moment.Moment | null | undefined, restructureIndicatorFilter: number | null | undefined, restructureRiskFilter: string | null | undefined, restructureTypeFilter: string | null | undefined, maxRestructureStartDateFilter: moment.Moment | null | undefined, minRestructureStartDateFilter: moment.Moment | null | undefined, maxRestructureEndDateFilter: moment.Moment | null | undefined, minRestructureEndDateFilter: moment.Moment | null | undefined, principalPaymentTermsOriginationFilter: string | null | undefined, maxPPTOPeriodFilter: number | null | undefined, minPPTOPeriodFilter: number | null | undefined, interestPaymentTermsOriginationFilter: string | null | undefined, maxIPTOPeriodFilter: number | null | undefined, minIPTOPeriodFilter: number | null | undefined, principalPaymentStructureFilter: string | null | undefined, interestPaymentStructureFilter: string | null | undefined, interestRateTypeFilter: string | null | undefined, baseRateFilter: string | null | undefined, originationContractualInterestRateFilter: string | null | undefined, maxIntroductoryPeriodFilter: number | null | undefined, minIntroductoryPeriodFilter: number | null | undefined, maxPostIPContractualInterestRateFilter: number | null | undefined, minPostIPContractualInterestRateFilter: number | null | undefined, maxCurrentContractualInterestRateFilter: number | null | undefined, minCurrentContractualInterestRateFilter: number | null | undefined, maxEIRFilter: number | null | undefined, minEIRFilter: number | null | undefined, maxDebentureOMVFilter: number | null | undefined, minDebentureOMVFilter: number | null | undefined, maxDebentureFSVFilter: number | null | undefined, minDebentureFSVFilter: number | null | undefined, maxCashOMVFilter: number | null | undefined, minCashOMVFilter: number | null | undefined, maxCashFSVFilter: number | null | undefined, minCashFSVFilter: number | null | undefined, maxInventoryOMVFilter: number | null | undefined, minInventoryOMVFilter: number | null | undefined, maxInventoryFSVFilter: number | null | undefined, minInventoryFSVFilter: number | null | undefined, maxPlantEquipmentOMVFilter: number | null | undefined, minPlantEquipmentOMVFilter: number | null | undefined, maxPlantEquipmentFSVFilter: number | null | undefined, minPlantEquipmentFSVFilter: number | null | undefined, maxResidentialPropertyOMVFilter: number | null | undefined, minResidentialPropertyOMVFilter: number | null | undefined, maxResidentialPropertyFSVFilter: number | null | undefined, minResidentialPropertyFSVFilter: number | null | undefined, maxCommercialPropertyOMVFilter: number | null | undefined, minCommercialPropertyOMVFilter: number | null | undefined, maxCommercialPropertyFilter: number | null | undefined, minCommercialPropertyFilter: number | null | undefined, maxReceivablesOMVFilter: number | null | undefined, minReceivablesOMVFilter: number | null | undefined, maxReceivablesFSVFilter: number | null | undefined, minReceivablesFSVFilter: number | null | undefined, maxSharesOMVFilter: number | null | undefined, minSharesOMVFilter: number | null | undefined, maxSharesFSVFilter: number | null | undefined, minSharesFSVFilter: number | null | undefined, maxVehicleOMVFilter: number | null | undefined, minVehicleOMVFilter: number | null | undefined, maxVehicleFSVFilter: number | null | undefined, minVehicleFSVFilter: number | null | undefined, maxCureRateFilter: number | null | undefined, minCureRateFilter: number | null | undefined, guaranteeIndicatorFilter: number | null | undefined, guarantorPDFilter: string | null | undefined, guarantorLGDFilter: string | null | undefined, maxGuaranteeValueFilter: number | null | undefined, minGuaranteeValueFilter: number | null | undefined, maxGuaranteeLevelFilter: number | null | undefined, minGuaranteeLevelFilter: number | null | undefined, contractIdFilter: string | null | undefined, retailEclUploadTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclDataLoanBookForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataLoanBooks/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (customerNoFilter !== undefined)
            url_ += "CustomerNoFilter=" + encodeURIComponent("" + customerNoFilter) + "&"; 
        if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&"; 
        if (contractNoFilter !== undefined)
            url_ += "ContractNoFilter=" + encodeURIComponent("" + contractNoFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (maxSnapshotDateFilter !== undefined)
            url_ += "MaxSnapshotDateFilter=" + encodeURIComponent(maxSnapshotDateFilter ? "" + maxSnapshotDateFilter.toJSON() : "") + "&"; 
        if (minSnapshotDateFilter !== undefined)
            url_ += "MinSnapshotDateFilter=" + encodeURIComponent(minSnapshotDateFilter ? "" + minSnapshotDateFilter.toJSON() : "") + "&"; 
        if (segmentFilter !== undefined)
            url_ += "SegmentFilter=" + encodeURIComponent("" + segmentFilter) + "&"; 
        if (sectorFilter !== undefined)
            url_ += "SectorFilter=" + encodeURIComponent("" + sectorFilter) + "&"; 
        if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&"; 
        if (productTypeFilter !== undefined)
            url_ += "ProductTypeFilter=" + encodeURIComponent("" + productTypeFilter) + "&"; 
        if (productMappingFilter !== undefined)
            url_ += "ProductMappingFilter=" + encodeURIComponent("" + productMappingFilter) + "&"; 
        if (specialisedLendingFilter !== undefined)
            url_ += "SpecialisedLendingFilter=" + encodeURIComponent("" + specialisedLendingFilter) + "&"; 
        if (ratingModelFilter !== undefined)
            url_ += "RatingModelFilter=" + encodeURIComponent("" + ratingModelFilter) + "&"; 
        if (maxOriginalRatingFilter !== undefined)
            url_ += "MaxOriginalRatingFilter=" + encodeURIComponent("" + maxOriginalRatingFilter) + "&"; 
        if (minOriginalRatingFilter !== undefined)
            url_ += "MinOriginalRatingFilter=" + encodeURIComponent("" + minOriginalRatingFilter) + "&"; 
        if (maxCurrentRatingFilter !== undefined)
            url_ += "MaxCurrentRatingFilter=" + encodeURIComponent("" + maxCurrentRatingFilter) + "&"; 
        if (minCurrentRatingFilter !== undefined)
            url_ += "MinCurrentRatingFilter=" + encodeURIComponent("" + minCurrentRatingFilter) + "&"; 
        if (maxLifetimePDFilter !== undefined)
            url_ += "MaxLifetimePDFilter=" + encodeURIComponent("" + maxLifetimePDFilter) + "&"; 
        if (minLifetimePDFilter !== undefined)
            url_ += "MinLifetimePDFilter=" + encodeURIComponent("" + minLifetimePDFilter) + "&"; 
        if (maxMonth12PDFilter !== undefined)
            url_ += "MaxMonth12PDFilter=" + encodeURIComponent("" + maxMonth12PDFilter) + "&"; 
        if (minMonth12PDFilter !== undefined)
            url_ += "MinMonth12PDFilter=" + encodeURIComponent("" + minMonth12PDFilter) + "&"; 
        if (maxDaysPastDueFilter !== undefined)
            url_ += "MaxDaysPastDueFilter=" + encodeURIComponent("" + maxDaysPastDueFilter) + "&"; 
        if (minDaysPastDueFilter !== undefined)
            url_ += "MinDaysPastDueFilter=" + encodeURIComponent("" + minDaysPastDueFilter) + "&"; 
        if (watchlistIndicatorFilter !== undefined)
            url_ += "WatchlistIndicatorFilter=" + encodeURIComponent("" + watchlistIndicatorFilter) + "&"; 
        if (classificationFilter !== undefined)
            url_ += "ClassificationFilter=" + encodeURIComponent("" + classificationFilter) + "&"; 
        if (maxImpairedDateFilter !== undefined)
            url_ += "MaxImpairedDateFilter=" + encodeURIComponent(maxImpairedDateFilter ? "" + maxImpairedDateFilter.toJSON() : "") + "&"; 
        if (minImpairedDateFilter !== undefined)
            url_ += "MinImpairedDateFilter=" + encodeURIComponent(minImpairedDateFilter ? "" + minImpairedDateFilter.toJSON() : "") + "&"; 
        if (maxDefaultDateFilter !== undefined)
            url_ += "MaxDefaultDateFilter=" + encodeURIComponent(maxDefaultDateFilter ? "" + maxDefaultDateFilter.toJSON() : "") + "&"; 
        if (minDefaultDateFilter !== undefined)
            url_ += "MinDefaultDateFilter=" + encodeURIComponent(minDefaultDateFilter ? "" + minDefaultDateFilter.toJSON() : "") + "&"; 
        if (maxCreditLimitFilter !== undefined)
            url_ += "MaxCreditLimitFilter=" + encodeURIComponent("" + maxCreditLimitFilter) + "&"; 
        if (minCreditLimitFilter !== undefined)
            url_ += "MinCreditLimitFilter=" + encodeURIComponent("" + minCreditLimitFilter) + "&"; 
        if (maxOriginalBalanceLCYFilter !== undefined)
            url_ += "MaxOriginalBalanceLCYFilter=" + encodeURIComponent("" + maxOriginalBalanceLCYFilter) + "&"; 
        if (minOriginalBalanceLCYFilter !== undefined)
            url_ += "MinOriginalBalanceLCYFilter=" + encodeURIComponent("" + minOriginalBalanceLCYFilter) + "&"; 
        if (maxOutstandingBalanceLCYFilter !== undefined)
            url_ += "MaxOutstandingBalanceLCYFilter=" + encodeURIComponent("" + maxOutstandingBalanceLCYFilter) + "&"; 
        if (minOutstandingBalanceLCYFilter !== undefined)
            url_ += "MinOutstandingBalanceLCYFilter=" + encodeURIComponent("" + minOutstandingBalanceLCYFilter) + "&"; 
        if (maxOutstandingBalanceACYFilter !== undefined)
            url_ += "MaxOutstandingBalanceACYFilter=" + encodeURIComponent("" + maxOutstandingBalanceACYFilter) + "&"; 
        if (minOutstandingBalanceACYFilter !== undefined)
            url_ += "MinOutstandingBalanceACYFilter=" + encodeURIComponent("" + minOutstandingBalanceACYFilter) + "&"; 
        if (maxContractStartDateFilter !== undefined)
            url_ += "MaxContractStartDateFilter=" + encodeURIComponent(maxContractStartDateFilter ? "" + maxContractStartDateFilter.toJSON() : "") + "&"; 
        if (minContractStartDateFilter !== undefined)
            url_ += "MinContractStartDateFilter=" + encodeURIComponent(minContractStartDateFilter ? "" + minContractStartDateFilter.toJSON() : "") + "&"; 
        if (maxContractEndDateFilter !== undefined)
            url_ += "MaxContractEndDateFilter=" + encodeURIComponent(maxContractEndDateFilter ? "" + maxContractEndDateFilter.toJSON() : "") + "&"; 
        if (minContractEndDateFilter !== undefined)
            url_ += "MinContractEndDateFilter=" + encodeURIComponent(minContractEndDateFilter ? "" + minContractEndDateFilter.toJSON() : "") + "&"; 
        if (restructureIndicatorFilter !== undefined)
            url_ += "RestructureIndicatorFilter=" + encodeURIComponent("" + restructureIndicatorFilter) + "&"; 
        if (restructureRiskFilter !== undefined)
            url_ += "RestructureRiskFilter=" + encodeURIComponent("" + restructureRiskFilter) + "&"; 
        if (restructureTypeFilter !== undefined)
            url_ += "RestructureTypeFilter=" + encodeURIComponent("" + restructureTypeFilter) + "&"; 
        if (maxRestructureStartDateFilter !== undefined)
            url_ += "MaxRestructureStartDateFilter=" + encodeURIComponent(maxRestructureStartDateFilter ? "" + maxRestructureStartDateFilter.toJSON() : "") + "&"; 
        if (minRestructureStartDateFilter !== undefined)
            url_ += "MinRestructureStartDateFilter=" + encodeURIComponent(minRestructureStartDateFilter ? "" + minRestructureStartDateFilter.toJSON() : "") + "&"; 
        if (maxRestructureEndDateFilter !== undefined)
            url_ += "MaxRestructureEndDateFilter=" + encodeURIComponent(maxRestructureEndDateFilter ? "" + maxRestructureEndDateFilter.toJSON() : "") + "&"; 
        if (minRestructureEndDateFilter !== undefined)
            url_ += "MinRestructureEndDateFilter=" + encodeURIComponent(minRestructureEndDateFilter ? "" + minRestructureEndDateFilter.toJSON() : "") + "&"; 
        if (principalPaymentTermsOriginationFilter !== undefined)
            url_ += "PrincipalPaymentTermsOriginationFilter=" + encodeURIComponent("" + principalPaymentTermsOriginationFilter) + "&"; 
        if (maxPPTOPeriodFilter !== undefined)
            url_ += "MaxPPTOPeriodFilter=" + encodeURIComponent("" + maxPPTOPeriodFilter) + "&"; 
        if (minPPTOPeriodFilter !== undefined)
            url_ += "MinPPTOPeriodFilter=" + encodeURIComponent("" + minPPTOPeriodFilter) + "&"; 
        if (interestPaymentTermsOriginationFilter !== undefined)
            url_ += "InterestPaymentTermsOriginationFilter=" + encodeURIComponent("" + interestPaymentTermsOriginationFilter) + "&"; 
        if (maxIPTOPeriodFilter !== undefined)
            url_ += "MaxIPTOPeriodFilter=" + encodeURIComponent("" + maxIPTOPeriodFilter) + "&"; 
        if (minIPTOPeriodFilter !== undefined)
            url_ += "MinIPTOPeriodFilter=" + encodeURIComponent("" + minIPTOPeriodFilter) + "&"; 
        if (principalPaymentStructureFilter !== undefined)
            url_ += "PrincipalPaymentStructureFilter=" + encodeURIComponent("" + principalPaymentStructureFilter) + "&"; 
        if (interestPaymentStructureFilter !== undefined)
            url_ += "InterestPaymentStructureFilter=" + encodeURIComponent("" + interestPaymentStructureFilter) + "&"; 
        if (interestRateTypeFilter !== undefined)
            url_ += "InterestRateTypeFilter=" + encodeURIComponent("" + interestRateTypeFilter) + "&"; 
        if (baseRateFilter !== undefined)
            url_ += "BaseRateFilter=" + encodeURIComponent("" + baseRateFilter) + "&"; 
        if (originationContractualInterestRateFilter !== undefined)
            url_ += "OriginationContractualInterestRateFilter=" + encodeURIComponent("" + originationContractualInterestRateFilter) + "&"; 
        if (maxIntroductoryPeriodFilter !== undefined)
            url_ += "MaxIntroductoryPeriodFilter=" + encodeURIComponent("" + maxIntroductoryPeriodFilter) + "&"; 
        if (minIntroductoryPeriodFilter !== undefined)
            url_ += "MinIntroductoryPeriodFilter=" + encodeURIComponent("" + minIntroductoryPeriodFilter) + "&"; 
        if (maxPostIPContractualInterestRateFilter !== undefined)
            url_ += "MaxPostIPContractualInterestRateFilter=" + encodeURIComponent("" + maxPostIPContractualInterestRateFilter) + "&"; 
        if (minPostIPContractualInterestRateFilter !== undefined)
            url_ += "MinPostIPContractualInterestRateFilter=" + encodeURIComponent("" + minPostIPContractualInterestRateFilter) + "&"; 
        if (maxCurrentContractualInterestRateFilter !== undefined)
            url_ += "MaxCurrentContractualInterestRateFilter=" + encodeURIComponent("" + maxCurrentContractualInterestRateFilter) + "&"; 
        if (minCurrentContractualInterestRateFilter !== undefined)
            url_ += "MinCurrentContractualInterestRateFilter=" + encodeURIComponent("" + minCurrentContractualInterestRateFilter) + "&"; 
        if (maxEIRFilter !== undefined)
            url_ += "MaxEIRFilter=" + encodeURIComponent("" + maxEIRFilter) + "&"; 
        if (minEIRFilter !== undefined)
            url_ += "MinEIRFilter=" + encodeURIComponent("" + minEIRFilter) + "&"; 
        if (maxDebentureOMVFilter !== undefined)
            url_ += "MaxDebentureOMVFilter=" + encodeURIComponent("" + maxDebentureOMVFilter) + "&"; 
        if (minDebentureOMVFilter !== undefined)
            url_ += "MinDebentureOMVFilter=" + encodeURIComponent("" + minDebentureOMVFilter) + "&"; 
        if (maxDebentureFSVFilter !== undefined)
            url_ += "MaxDebentureFSVFilter=" + encodeURIComponent("" + maxDebentureFSVFilter) + "&"; 
        if (minDebentureFSVFilter !== undefined)
            url_ += "MinDebentureFSVFilter=" + encodeURIComponent("" + minDebentureFSVFilter) + "&"; 
        if (maxCashOMVFilter !== undefined)
            url_ += "MaxCashOMVFilter=" + encodeURIComponent("" + maxCashOMVFilter) + "&"; 
        if (minCashOMVFilter !== undefined)
            url_ += "MinCashOMVFilter=" + encodeURIComponent("" + minCashOMVFilter) + "&"; 
        if (maxCashFSVFilter !== undefined)
            url_ += "MaxCashFSVFilter=" + encodeURIComponent("" + maxCashFSVFilter) + "&"; 
        if (minCashFSVFilter !== undefined)
            url_ += "MinCashFSVFilter=" + encodeURIComponent("" + minCashFSVFilter) + "&"; 
        if (maxInventoryOMVFilter !== undefined)
            url_ += "MaxInventoryOMVFilter=" + encodeURIComponent("" + maxInventoryOMVFilter) + "&"; 
        if (minInventoryOMVFilter !== undefined)
            url_ += "MinInventoryOMVFilter=" + encodeURIComponent("" + minInventoryOMVFilter) + "&"; 
        if (maxInventoryFSVFilter !== undefined)
            url_ += "MaxInventoryFSVFilter=" + encodeURIComponent("" + maxInventoryFSVFilter) + "&"; 
        if (minInventoryFSVFilter !== undefined)
            url_ += "MinInventoryFSVFilter=" + encodeURIComponent("" + minInventoryFSVFilter) + "&"; 
        if (maxPlantEquipmentOMVFilter !== undefined)
            url_ += "MaxPlantEquipmentOMVFilter=" + encodeURIComponent("" + maxPlantEquipmentOMVFilter) + "&"; 
        if (minPlantEquipmentOMVFilter !== undefined)
            url_ += "MinPlantEquipmentOMVFilter=" + encodeURIComponent("" + minPlantEquipmentOMVFilter) + "&"; 
        if (maxPlantEquipmentFSVFilter !== undefined)
            url_ += "MaxPlantEquipmentFSVFilter=" + encodeURIComponent("" + maxPlantEquipmentFSVFilter) + "&"; 
        if (minPlantEquipmentFSVFilter !== undefined)
            url_ += "MinPlantEquipmentFSVFilter=" + encodeURIComponent("" + minPlantEquipmentFSVFilter) + "&"; 
        if (maxResidentialPropertyOMVFilter !== undefined)
            url_ += "MaxResidentialPropertyOMVFilter=" + encodeURIComponent("" + maxResidentialPropertyOMVFilter) + "&"; 
        if (minResidentialPropertyOMVFilter !== undefined)
            url_ += "MinResidentialPropertyOMVFilter=" + encodeURIComponent("" + minResidentialPropertyOMVFilter) + "&"; 
        if (maxResidentialPropertyFSVFilter !== undefined)
            url_ += "MaxResidentialPropertyFSVFilter=" + encodeURIComponent("" + maxResidentialPropertyFSVFilter) + "&"; 
        if (minResidentialPropertyFSVFilter !== undefined)
            url_ += "MinResidentialPropertyFSVFilter=" + encodeURIComponent("" + minResidentialPropertyFSVFilter) + "&"; 
        if (maxCommercialPropertyOMVFilter !== undefined)
            url_ += "MaxCommercialPropertyOMVFilter=" + encodeURIComponent("" + maxCommercialPropertyOMVFilter) + "&"; 
        if (minCommercialPropertyOMVFilter !== undefined)
            url_ += "MinCommercialPropertyOMVFilter=" + encodeURIComponent("" + minCommercialPropertyOMVFilter) + "&"; 
        if (maxCommercialPropertyFilter !== undefined)
            url_ += "MaxCommercialPropertyFilter=" + encodeURIComponent("" + maxCommercialPropertyFilter) + "&"; 
        if (minCommercialPropertyFilter !== undefined)
            url_ += "MinCommercialPropertyFilter=" + encodeURIComponent("" + minCommercialPropertyFilter) + "&"; 
        if (maxReceivablesOMVFilter !== undefined)
            url_ += "MaxReceivablesOMVFilter=" + encodeURIComponent("" + maxReceivablesOMVFilter) + "&"; 
        if (minReceivablesOMVFilter !== undefined)
            url_ += "MinReceivablesOMVFilter=" + encodeURIComponent("" + minReceivablesOMVFilter) + "&"; 
        if (maxReceivablesFSVFilter !== undefined)
            url_ += "MaxReceivablesFSVFilter=" + encodeURIComponent("" + maxReceivablesFSVFilter) + "&"; 
        if (minReceivablesFSVFilter !== undefined)
            url_ += "MinReceivablesFSVFilter=" + encodeURIComponent("" + minReceivablesFSVFilter) + "&"; 
        if (maxSharesOMVFilter !== undefined)
            url_ += "MaxSharesOMVFilter=" + encodeURIComponent("" + maxSharesOMVFilter) + "&"; 
        if (minSharesOMVFilter !== undefined)
            url_ += "MinSharesOMVFilter=" + encodeURIComponent("" + minSharesOMVFilter) + "&"; 
        if (maxSharesFSVFilter !== undefined)
            url_ += "MaxSharesFSVFilter=" + encodeURIComponent("" + maxSharesFSVFilter) + "&"; 
        if (minSharesFSVFilter !== undefined)
            url_ += "MinSharesFSVFilter=" + encodeURIComponent("" + minSharesFSVFilter) + "&"; 
        if (maxVehicleOMVFilter !== undefined)
            url_ += "MaxVehicleOMVFilter=" + encodeURIComponent("" + maxVehicleOMVFilter) + "&"; 
        if (minVehicleOMVFilter !== undefined)
            url_ += "MinVehicleOMVFilter=" + encodeURIComponent("" + minVehicleOMVFilter) + "&"; 
        if (maxVehicleFSVFilter !== undefined)
            url_ += "MaxVehicleFSVFilter=" + encodeURIComponent("" + maxVehicleFSVFilter) + "&"; 
        if (minVehicleFSVFilter !== undefined)
            url_ += "MinVehicleFSVFilter=" + encodeURIComponent("" + minVehicleFSVFilter) + "&"; 
        if (maxCureRateFilter !== undefined)
            url_ += "MaxCureRateFilter=" + encodeURIComponent("" + maxCureRateFilter) + "&"; 
        if (minCureRateFilter !== undefined)
            url_ += "MinCureRateFilter=" + encodeURIComponent("" + minCureRateFilter) + "&"; 
        if (guaranteeIndicatorFilter !== undefined)
            url_ += "GuaranteeIndicatorFilter=" + encodeURIComponent("" + guaranteeIndicatorFilter) + "&"; 
        if (guarantorPDFilter !== undefined)
            url_ += "GuarantorPDFilter=" + encodeURIComponent("" + guarantorPDFilter) + "&"; 
        if (guarantorLGDFilter !== undefined)
            url_ += "GuarantorLGDFilter=" + encodeURIComponent("" + guarantorLGDFilter) + "&"; 
        if (maxGuaranteeValueFilter !== undefined)
            url_ += "MaxGuaranteeValueFilter=" + encodeURIComponent("" + maxGuaranteeValueFilter) + "&"; 
        if (minGuaranteeValueFilter !== undefined)
            url_ += "MinGuaranteeValueFilter=" + encodeURIComponent("" + minGuaranteeValueFilter) + "&"; 
        if (maxGuaranteeLevelFilter !== undefined)
            url_ += "MaxGuaranteeLevelFilter=" + encodeURIComponent("" + maxGuaranteeLevelFilter) + "&"; 
        if (minGuaranteeLevelFilter !== undefined)
            url_ += "MinGuaranteeLevelFilter=" + encodeURIComponent("" + minGuaranteeLevelFilter) + "&"; 
        if (contractIdFilter !== undefined)
            url_ += "ContractIdFilter=" + encodeURIComponent("" + contractIdFilter) + "&"; 
        if (retailEclUploadTenantIdFilter !== undefined)
            url_ += "RetailEclUploadTenantIdFilter=" + encodeURIComponent("" + retailEclUploadTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclDataLoanBookForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclDataLoanBookForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclDataLoanBookForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclDataLoanBookForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclDataLoanBookForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclDataLoanBookForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclDataLoanBookForEdit(id: string | null | undefined): Observable<GetRetailEclDataLoanBookForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataLoanBooks/GetRetailEclDataLoanBookForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclDataLoanBookForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclDataLoanBookForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclDataLoanBookForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclDataLoanBookForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclDataLoanBookForEdit(response: HttpResponseBase): Observable<GetRetailEclDataLoanBookForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclDataLoanBookForEditOutput.fromJS(resultData200) : new GetRetailEclDataLoanBookForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclDataLoanBookForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclDataLoanBookDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataLoanBooks/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataLoanBooks/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataLoanBooks/GetAllRetailEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclDataPaymentSchedulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param contractRefNoFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param componentFilter (optional) 
     * @param maxNoOfSchedulesFilter (optional) 
     * @param minNoOfSchedulesFilter (optional) 
     * @param frequencyFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param retailEclUploadTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, contractRefNoFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, componentFilter: string | null | undefined, maxNoOfSchedulesFilter: number | null | undefined, minNoOfSchedulesFilter: number | null | undefined, frequencyFilter: string | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, retailEclUploadTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataPaymentSchedules/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (contractRefNoFilter !== undefined)
            url_ += "ContractRefNoFilter=" + encodeURIComponent("" + contractRefNoFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (componentFilter !== undefined)
            url_ += "ComponentFilter=" + encodeURIComponent("" + componentFilter) + "&"; 
        if (maxNoOfSchedulesFilter !== undefined)
            url_ += "MaxNoOfSchedulesFilter=" + encodeURIComponent("" + maxNoOfSchedulesFilter) + "&"; 
        if (minNoOfSchedulesFilter !== undefined)
            url_ += "MinNoOfSchedulesFilter=" + encodeURIComponent("" + minNoOfSchedulesFilter) + "&"; 
        if (frequencyFilter !== undefined)
            url_ += "FrequencyFilter=" + encodeURIComponent("" + frequencyFilter) + "&"; 
        if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&"; 
        if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&"; 
        if (retailEclUploadTenantIdFilter !== undefined)
            url_ += "RetailEclUploadTenantIdFilter=" + encodeURIComponent("" + retailEclUploadTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclDataPaymentScheduleForEdit(id: string | null | undefined): Observable<GetRetailEclDataPaymentScheduleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataPaymentSchedules/GetRetailEclDataPaymentScheduleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclDataPaymentScheduleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclDataPaymentScheduleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclDataPaymentScheduleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclDataPaymentScheduleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclDataPaymentScheduleForEdit(response: HttpResponseBase): Observable<GetRetailEclDataPaymentScheduleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclDataPaymentScheduleForEditOutput.fromJS(resultData200) : new GetRetailEclDataPaymentScheduleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclDataPaymentScheduleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclDataPaymentScheduleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataPaymentSchedules/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataPaymentSchedules/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclDataPaymentSchedules/GetAllRetailEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclEadInputAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param inputNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param datatypeFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param eadGroupFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, inputNameFilter: string | null | undefined, valueFilter: string | null | undefined, datatypeFilter: number | null | undefined, isComputedFilter: number | null | undefined, eadGroupFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclEadInputAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (datatypeFilter !== undefined)
            url_ += "DatatypeFilter=" + encodeURIComponent("" + datatypeFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (eadGroupFilter !== undefined)
            url_ += "EadGroupFilter=" + encodeURIComponent("" + eadGroupFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclEadInputAssumptionForEdit(id: string | null | undefined): Observable<GetRetailEclEadInputAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclEadInputAssumptions/GetRetailEclEadInputAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclEadInputAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclEadInputAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclEadInputAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclEadInputAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclEadInputAssumptionForEdit(response: HttpResponseBase): Observable<GetRetailEclEadInputAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclEadInputAssumptionForEditOutput.fromJS(resultData200) : new GetRetailEclEadInputAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclEadInputAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclEadInputAssumptionsList(id: string | null | undefined): Observable<CreateOrEditRetailEclEadInputAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclEadInputAssumptions/GetRetailEclEadInputAssumptionsList?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclEadInputAssumptionsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclEadInputAssumptionsList(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditRetailEclEadInputAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditRetailEclEadInputAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclEadInputAssumptionsList(response: HttpResponseBase): Observable<CreateOrEditRetailEclEadInputAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateOrEditRetailEclEadInputAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditRetailEclEadInputAssumptionDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclEadInputAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclEadInputAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclEadInputAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclEadInputAssumptions/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclLgdAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param inputNameFilter (optional) 
     * @param valueFilter (optional) 
     * @param dataTypeFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param lgdGroupFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, inputNameFilter: string | null | undefined, valueFilter: string | null | undefined, dataTypeFilter: number | null | undefined, isComputedFilter: number | null | undefined, lgdGroupFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclLgdAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (valueFilter !== undefined)
            url_ += "ValueFilter=" + encodeURIComponent("" + valueFilter) + "&"; 
        if (dataTypeFilter !== undefined)
            url_ += "DataTypeFilter=" + encodeURIComponent("" + dataTypeFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (lgdGroupFilter !== undefined)
            url_ += "LgdGroupFilter=" + encodeURIComponent("" + lgdGroupFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclLgdAssumptionForEdit(id: string | null | undefined): Observable<GetRetailEclLgdAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclLgdAssumptions/GetRetailEclLgdAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclLgdAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclLgdAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclLgdAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclLgdAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclLgdAssumptionForEdit(response: HttpResponseBase): Observable<GetRetailEclLgdAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclLgdAssumptionForEditOutput.fromJS(resultData200) : new GetRetailEclLgdAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclLgdAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclLgdAssumptionsList(id: string | null | undefined): Observable<CreateOrEditRetailEclLgdAssumptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclLgdAssumptions/GetRetailEclLgdAssumptionsList?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclLgdAssumptionsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclLgdAssumptionsList(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditRetailEclLgdAssumptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditRetailEclLgdAssumptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclLgdAssumptionsList(response: HttpResponseBase): Observable<CreateOrEditRetailEclLgdAssumptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateOrEditRetailEclLgdAssumptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditRetailEclLgdAssumptionDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclLgdAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclLgdAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclLgdAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclLgdAssumptions/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdAssumption12MonthsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxCreditFilter (optional) 
     * @param minCreditFilter (optional) 
     * @param maxPDFilter (optional) 
     * @param minPDFilter (optional) 
     * @param snPMappingEtiCreditPolicyFilter (optional) 
     * @param snPMappingBestFitFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxCreditFilter: number | null | undefined, minCreditFilter: number | null | undefined, maxPDFilter: number | null | undefined, minPDFilter: number | null | undefined, snPMappingEtiCreditPolicyFilter: string | null | undefined, snPMappingBestFitFilter: string | null | undefined, requiresGroupApprovalFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumption12Months/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxCreditFilter !== undefined)
            url_ += "MaxCreditFilter=" + encodeURIComponent("" + maxCreditFilter) + "&"; 
        if (minCreditFilter !== undefined)
            url_ += "MinCreditFilter=" + encodeURIComponent("" + minCreditFilter) + "&"; 
        if (maxPDFilter !== undefined)
            url_ += "MaxPDFilter=" + encodeURIComponent("" + maxPDFilter) + "&"; 
        if (minPDFilter !== undefined)
            url_ += "MinPDFilter=" + encodeURIComponent("" + minPDFilter) + "&"; 
        if (snPMappingEtiCreditPolicyFilter !== undefined)
            url_ += "SnPMappingEtiCreditPolicyFilter=" + encodeURIComponent("" + snPMappingEtiCreditPolicyFilter) + "&"; 
        if (snPMappingBestFitFilter !== undefined)
            url_ += "SnPMappingBestFitFilter=" + encodeURIComponent("" + snPMappingBestFitFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdAssumption12MonthForEdit(id: string | null | undefined): Observable<GetRetailEclPdAssumption12MonthForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumption12Months/GetRetailEclPdAssumption12MonthForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdAssumption12MonthForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdAssumption12MonthForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdAssumption12MonthForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdAssumption12MonthForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdAssumption12MonthForEdit(response: HttpResponseBase): Observable<GetRetailEclPdAssumption12MonthForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdAssumption12MonthForEditOutput.fromJS(resultData200) : new GetRetailEclPdAssumption12MonthForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdAssumption12MonthForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdAssumption12MonthDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumption12Months/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumption12Months/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumption12Months/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdAssumptionMacroeconomicInputsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicInputs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdAssumptionMacroeconomicInputForEdit(id: string | null | undefined): Observable<GetRetailEclPdAssumptionMacroeconomicInputForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicInputs/GetRetailEclPdAssumptionMacroeconomicInputForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdAssumptionMacroeconomicInputForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdAssumptionMacroeconomicInputForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdAssumptionMacroeconomicInputForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdAssumptionMacroeconomicInputForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdAssumptionMacroeconomicInputForEdit(response: HttpResponseBase): Observable<GetRetailEclPdAssumptionMacroeconomicInputForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdAssumptionMacroeconomicInputForEditOutput.fromJS(resultData200) : new GetRetailEclPdAssumptionMacroeconomicInputForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdAssumptionMacroeconomicInputForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicInputs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicInputs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicInputs/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdAssumptionMacroeconomicProjectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicProjections/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdAssumptionMacroeconomicProjectionForEdit(id: string | null | undefined): Observable<GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicProjections/GetRetailEclPdAssumptionMacroeconomicProjectionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdAssumptionMacroeconomicProjectionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdAssumptionMacroeconomicProjectionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdAssumptionMacroeconomicProjectionForEdit(response: HttpResponseBase): Observable<GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput.fromJS(resultData200) : new GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicProjections/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicProjections/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionMacroeconomicProjections/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdAssumptionNonInteralModelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNonInteralModels/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdAssumptionNonInteralModelForEdit(id: string | null | undefined): Observable<GetRetailEclPdAssumptionNonInteralModelForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNonInteralModels/GetRetailEclPdAssumptionNonInteralModelForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdAssumptionNonInteralModelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdAssumptionNonInteralModelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdAssumptionNonInteralModelForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdAssumptionNonInteralModelForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdAssumptionNonInteralModelForEdit(response: HttpResponseBase): Observable<GetRetailEclPdAssumptionNonInteralModelForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdAssumptionNonInteralModelForEditOutput.fromJS(resultData200) : new GetRetailEclPdAssumptionNonInteralModelForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdAssumptionNonInteralModelForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdAssumptionNonInteralModelDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNonInteralModels/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNonInteralModels/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNonInteralModels/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdAssumptionNplIndexesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNplIndexes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdAssumptionNplIndexForEdit(id: string | null | undefined): Observable<GetRetailEclPdAssumptionNplIndexForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNplIndexes/GetRetailEclPdAssumptionNplIndexForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdAssumptionNplIndexForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdAssumptionNplIndexForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdAssumptionNplIndexForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdAssumptionNplIndexForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdAssumptionNplIndexForEdit(response: HttpResponseBase): Observable<GetRetailEclPdAssumptionNplIndexForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdAssumptionNplIndexForEditOutput.fromJS(resultData200) : new GetRetailEclPdAssumptionNplIndexForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdAssumptionNplIndexForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdAssumptionNplIndexDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNplIndexes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNplIndexes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptionNplIndexes/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdAssumptionForEdit(id: string | null | undefined): Observable<GetRetailEclPdAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptions/GetRetailEclPdAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdAssumptionForEdit(response: HttpResponseBase): Observable<GetRetailEclPdAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdAssumptionForEditOutput.fromJS(resultData200) : new GetRetailEclPdAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdAssumptions/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclPdSnPCummulativeDefaultRatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param ratingFilter (optional) 
     * @param maxYearsFilter (optional) 
     * @param minYearsFilter (optional) 
     * @param maxValueFilter (optional) 
     * @param minValueFilter (optional) 
     * @param requiresGroupApprovalFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, ratingFilter: string | null | undefined, maxYearsFilter: number | null | undefined, minYearsFilter: number | null | undefined, maxValueFilter: number | null | undefined, minValueFilter: number | null | undefined, requiresGroupApprovalFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdSnPCummulativeDefaultRates/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (ratingFilter !== undefined)
            url_ += "RatingFilter=" + encodeURIComponent("" + ratingFilter) + "&"; 
        if (maxYearsFilter !== undefined)
            url_ += "MaxYearsFilter=" + encodeURIComponent("" + maxYearsFilter) + "&"; 
        if (minYearsFilter !== undefined)
            url_ += "MinYearsFilter=" + encodeURIComponent("" + minYearsFilter) + "&"; 
        if (maxValueFilter !== undefined)
            url_ += "MaxValueFilter=" + encodeURIComponent("" + maxValueFilter) + "&"; 
        if (minValueFilter !== undefined)
            url_ += "MinValueFilter=" + encodeURIComponent("" + minValueFilter) + "&"; 
        if (requiresGroupApprovalFilter !== undefined)
            url_ += "RequiresGroupApprovalFilter=" + encodeURIComponent("" + requiresGroupApprovalFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclPdSnPCummulativeDefaultRateForEdit(id: string | null | undefined): Observable<GetRetailEclPdSnPCummulativeDefaultRateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdSnPCummulativeDefaultRates/GetRetailEclPdSnPCummulativeDefaultRateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclPdSnPCummulativeDefaultRateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclPdSnPCummulativeDefaultRateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclPdSnPCummulativeDefaultRateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclPdSnPCummulativeDefaultRateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclPdSnPCummulativeDefaultRateForEdit(response: HttpResponseBase): Observable<GetRetailEclPdSnPCummulativeDefaultRateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclPdSnPCummulativeDefaultRateForEditOutput.fromJS(resultData200) : new GetRetailEclPdSnPCummulativeDefaultRateForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclPdSnPCummulativeDefaultRateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdSnPCummulativeDefaultRates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdSnPCummulativeDefaultRates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclPdSnPCummulativeDefaultRates/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclResultDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param contractIDFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param customerNoFilter (optional) 
     * @param segmentFilter (optional) 
     * @param productTypeFilter (optional) 
     * @param sectorFilter (optional) 
     * @param maxStageFilter (optional) 
     * @param minStageFilter (optional) 
     * @param maxOutstandingBalanceFilter (optional) 
     * @param minOutstandingBalanceFilter (optional) 
     * @param maxPreOverrideEclBestFilter (optional) 
     * @param minPreOverrideEclBestFilter (optional) 
     * @param maxPreOverrideEclOptimisticFilter (optional) 
     * @param minPreOverrideEclOptimisticFilter (optional) 
     * @param maxPreOverrideEclDownturnFilter (optional) 
     * @param minPreOverrideEclDownturnFilter (optional) 
     * @param maxOverrideStageFilter (optional) 
     * @param minOverrideStageFilter (optional) 
     * @param maxOverrideTTRYearsFilter (optional) 
     * @param minOverrideTTRYearsFilter (optional) 
     * @param maxOverrideFSVFilter (optional) 
     * @param minOverrideFSVFilter (optional) 
     * @param maxOverrideOverlayFilter (optional) 
     * @param minOverrideOverlayFilter (optional) 
     * @param maxPostOverrideEclBestFilter (optional) 
     * @param minPostOverrideEclBestFilter (optional) 
     * @param maxPostOverrideEclOptimisticFilter (optional) 
     * @param minPostOverrideEclOptimisticFilter (optional) 
     * @param maxPostOverrideEclDownturnFilter (optional) 
     * @param minPostOverrideEclDownturnFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param retailEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, contractIDFilter: string | null | undefined, accountNoFilter: string | null | undefined, customerNoFilter: string | null | undefined, segmentFilter: string | null | undefined, productTypeFilter: string | null | undefined, sectorFilter: string | null | undefined, maxStageFilter: number | null | undefined, minStageFilter: number | null | undefined, maxOutstandingBalanceFilter: number | null | undefined, minOutstandingBalanceFilter: number | null | undefined, maxPreOverrideEclBestFilter: number | null | undefined, minPreOverrideEclBestFilter: number | null | undefined, maxPreOverrideEclOptimisticFilter: number | null | undefined, minPreOverrideEclOptimisticFilter: number | null | undefined, maxPreOverrideEclDownturnFilter: number | null | undefined, minPreOverrideEclDownturnFilter: number | null | undefined, maxOverrideStageFilter: number | null | undefined, minOverrideStageFilter: number | null | undefined, maxOverrideTTRYearsFilter: number | null | undefined, minOverrideTTRYearsFilter: number | null | undefined, maxOverrideFSVFilter: number | null | undefined, minOverrideFSVFilter: number | null | undefined, maxOverrideOverlayFilter: number | null | undefined, minOverrideOverlayFilter: number | null | undefined, maxPostOverrideEclBestFilter: number | null | undefined, minPostOverrideEclBestFilter: number | null | undefined, maxPostOverrideEclOptimisticFilter: number | null | undefined, minPostOverrideEclOptimisticFilter: number | null | undefined, maxPostOverrideEclDownturnFilter: number | null | undefined, minPostOverrideEclDownturnFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, retailEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclResultDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (contractIDFilter !== undefined)
            url_ += "ContractIDFilter=" + encodeURIComponent("" + contractIDFilter) + "&"; 
        if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&"; 
        if (customerNoFilter !== undefined)
            url_ += "CustomerNoFilter=" + encodeURIComponent("" + customerNoFilter) + "&"; 
        if (segmentFilter !== undefined)
            url_ += "SegmentFilter=" + encodeURIComponent("" + segmentFilter) + "&"; 
        if (productTypeFilter !== undefined)
            url_ += "ProductTypeFilter=" + encodeURIComponent("" + productTypeFilter) + "&"; 
        if (sectorFilter !== undefined)
            url_ += "SectorFilter=" + encodeURIComponent("" + sectorFilter) + "&"; 
        if (maxStageFilter !== undefined)
            url_ += "MaxStageFilter=" + encodeURIComponent("" + maxStageFilter) + "&"; 
        if (minStageFilter !== undefined)
            url_ += "MinStageFilter=" + encodeURIComponent("" + minStageFilter) + "&"; 
        if (maxOutstandingBalanceFilter !== undefined)
            url_ += "MaxOutstandingBalanceFilter=" + encodeURIComponent("" + maxOutstandingBalanceFilter) + "&"; 
        if (minOutstandingBalanceFilter !== undefined)
            url_ += "MinOutstandingBalanceFilter=" + encodeURIComponent("" + minOutstandingBalanceFilter) + "&"; 
        if (maxPreOverrideEclBestFilter !== undefined)
            url_ += "MaxPreOverrideEclBestFilter=" + encodeURIComponent("" + maxPreOverrideEclBestFilter) + "&"; 
        if (minPreOverrideEclBestFilter !== undefined)
            url_ += "MinPreOverrideEclBestFilter=" + encodeURIComponent("" + minPreOverrideEclBestFilter) + "&"; 
        if (maxPreOverrideEclOptimisticFilter !== undefined)
            url_ += "MaxPreOverrideEclOptimisticFilter=" + encodeURIComponent("" + maxPreOverrideEclOptimisticFilter) + "&"; 
        if (minPreOverrideEclOptimisticFilter !== undefined)
            url_ += "MinPreOverrideEclOptimisticFilter=" + encodeURIComponent("" + minPreOverrideEclOptimisticFilter) + "&"; 
        if (maxPreOverrideEclDownturnFilter !== undefined)
            url_ += "MaxPreOverrideEclDownturnFilter=" + encodeURIComponent("" + maxPreOverrideEclDownturnFilter) + "&"; 
        if (minPreOverrideEclDownturnFilter !== undefined)
            url_ += "MinPreOverrideEclDownturnFilter=" + encodeURIComponent("" + minPreOverrideEclDownturnFilter) + "&"; 
        if (maxOverrideStageFilter !== undefined)
            url_ += "MaxOverrideStageFilter=" + encodeURIComponent("" + maxOverrideStageFilter) + "&"; 
        if (minOverrideStageFilter !== undefined)
            url_ += "MinOverrideStageFilter=" + encodeURIComponent("" + minOverrideStageFilter) + "&"; 
        if (maxOverrideTTRYearsFilter !== undefined)
            url_ += "MaxOverrideTTRYearsFilter=" + encodeURIComponent("" + maxOverrideTTRYearsFilter) + "&"; 
        if (minOverrideTTRYearsFilter !== undefined)
            url_ += "MinOverrideTTRYearsFilter=" + encodeURIComponent("" + minOverrideTTRYearsFilter) + "&"; 
        if (maxOverrideFSVFilter !== undefined)
            url_ += "MaxOverrideFSVFilter=" + encodeURIComponent("" + maxOverrideFSVFilter) + "&"; 
        if (minOverrideFSVFilter !== undefined)
            url_ += "MinOverrideFSVFilter=" + encodeURIComponent("" + minOverrideFSVFilter) + "&"; 
        if (maxOverrideOverlayFilter !== undefined)
            url_ += "MaxOverrideOverlayFilter=" + encodeURIComponent("" + maxOverrideOverlayFilter) + "&"; 
        if (minOverrideOverlayFilter !== undefined)
            url_ += "MinOverrideOverlayFilter=" + encodeURIComponent("" + minOverrideOverlayFilter) + "&"; 
        if (maxPostOverrideEclBestFilter !== undefined)
            url_ += "MaxPostOverrideEclBestFilter=" + encodeURIComponent("" + maxPostOverrideEclBestFilter) + "&"; 
        if (minPostOverrideEclBestFilter !== undefined)
            url_ += "MinPostOverrideEclBestFilter=" + encodeURIComponent("" + minPostOverrideEclBestFilter) + "&"; 
        if (maxPostOverrideEclOptimisticFilter !== undefined)
            url_ += "MaxPostOverrideEclOptimisticFilter=" + encodeURIComponent("" + maxPostOverrideEclOptimisticFilter) + "&"; 
        if (minPostOverrideEclOptimisticFilter !== undefined)
            url_ += "MinPostOverrideEclOptimisticFilter=" + encodeURIComponent("" + minPostOverrideEclOptimisticFilter) + "&"; 
        if (maxPostOverrideEclDownturnFilter !== undefined)
            url_ += "MaxPostOverrideEclDownturnFilter=" + encodeURIComponent("" + maxPostOverrideEclDownturnFilter) + "&"; 
        if (minPostOverrideEclDownturnFilter !== undefined)
            url_ += "MinPostOverrideEclDownturnFilter=" + encodeURIComponent("" + minPostOverrideEclDownturnFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (retailEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "RetailEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + retailEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclResultDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclResultDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclResultDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclResultDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclResultDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclResultDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclResultDetailForEdit(id: string | null | undefined): Observable<GetRetailEclResultDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultDetails/GetRetailEclResultDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclResultDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclResultDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclResultDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclResultDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclResultDetailForEdit(response: HttpResponseBase): Observable<GetRetailEclResultDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclResultDetailForEditOutput.fromJS(resultData200) : new GetRetailEclResultDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclResultDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclResultDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultDetails/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultDetails/GetAllRetailEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclResultSummariesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param summaryTypeFilter (optional) 
     * @param titleFilter (optional) 
     * @param maxPreOverrideExposureFilter (optional) 
     * @param minPreOverrideExposureFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPreOverrideCoverageRatioFilter (optional) 
     * @param minPreOverrideCoverageRatioFilter (optional) 
     * @param maxPostOverrideExposureFilter (optional) 
     * @param minPostOverrideExposureFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideCoverageRatioFilter (optional) 
     * @param minPostOverrideCoverageRatioFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, summaryTypeFilter: number | null | undefined, titleFilter: string | null | undefined, maxPreOverrideExposureFilter: number | null | undefined, minPreOverrideExposureFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPreOverrideCoverageRatioFilter: number | null | undefined, minPreOverrideCoverageRatioFilter: number | null | undefined, maxPostOverrideExposureFilter: number | null | undefined, minPostOverrideExposureFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, maxPostOverrideCoverageRatioFilter: number | null | undefined, minPostOverrideCoverageRatioFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclResultSummaryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaries/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (summaryTypeFilter !== undefined)
            url_ += "SummaryTypeFilter=" + encodeURIComponent("" + summaryTypeFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (maxPreOverrideExposureFilter !== undefined)
            url_ += "MaxPreOverrideExposureFilter=" + encodeURIComponent("" + maxPreOverrideExposureFilter) + "&"; 
        if (minPreOverrideExposureFilter !== undefined)
            url_ += "MinPreOverrideExposureFilter=" + encodeURIComponent("" + minPreOverrideExposureFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPreOverrideCoverageRatioFilter) + "&"; 
        if (minPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPreOverrideCoverageRatioFilter) + "&"; 
        if (maxPostOverrideExposureFilter !== undefined)
            url_ += "MaxPostOverrideExposureFilter=" + encodeURIComponent("" + maxPostOverrideExposureFilter) + "&"; 
        if (minPostOverrideExposureFilter !== undefined)
            url_ += "MinPostOverrideExposureFilter=" + encodeURIComponent("" + minPostOverrideExposureFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPostOverrideCoverageRatioFilter) + "&"; 
        if (minPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPostOverrideCoverageRatioFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclResultSummaryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclResultSummaryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclResultSummaryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclResultSummaryForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclResultSummaryForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclResultSummaryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclResultSummaryForEdit(id: string | null | undefined): Observable<GetRetailEclResultSummaryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaries/GetRetailEclResultSummaryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclResultSummaryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclResultSummaryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclResultSummaryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclResultSummaryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclResultSummaryForEdit(response: HttpResponseBase): Observable<GetRetailEclResultSummaryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclResultSummaryForEditOutput.fromJS(resultData200) : new GetRetailEclResultSummaryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclResultSummaryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclResultSummaryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaries/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaries/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclResultSummaryKeyInputsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pDGroupingFilter (optional) 
     * @param maxExposureFilter (optional) 
     * @param minExposureFilter (optional) 
     * @param maxCollateralFilter (optional) 
     * @param minCollateralFilter (optional) 
     * @param maxUnsecuredPercentageFilter (optional) 
     * @param minUnsecuredPercentageFilter (optional) 
     * @param maxPercentageOfBookFilter (optional) 
     * @param minPercentageOfBookFilter (optional) 
     * @param maxMonths6CummulativeBestPDsFilter (optional) 
     * @param minMonths6CummulativeBestPDsFilter (optional) 
     * @param maxMonths12CummulativeBestPDsFilter (optional) 
     * @param minMonths12CummulativeBestPDsFilter (optional) 
     * @param maxMonths24CummulativeBestPDsFilter (optional) 
     * @param minMonths24CummulativeBestPDsFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, pDGroupingFilter: string | null | undefined, maxExposureFilter: number | null | undefined, minExposureFilter: number | null | undefined, maxCollateralFilter: number | null | undefined, minCollateralFilter: number | null | undefined, maxUnsecuredPercentageFilter: number | null | undefined, minUnsecuredPercentageFilter: number | null | undefined, maxPercentageOfBookFilter: number | null | undefined, minPercentageOfBookFilter: number | null | undefined, maxMonths6CummulativeBestPDsFilter: number | null | undefined, minMonths6CummulativeBestPDsFilter: number | null | undefined, maxMonths12CummulativeBestPDsFilter: number | null | undefined, minMonths12CummulativeBestPDsFilter: number | null | undefined, maxMonths24CummulativeBestPDsFilter: number | null | undefined, minMonths24CummulativeBestPDsFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryKeyInputs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (pDGroupingFilter !== undefined)
            url_ += "PDGroupingFilter=" + encodeURIComponent("" + pDGroupingFilter) + "&"; 
        if (maxExposureFilter !== undefined)
            url_ += "MaxExposureFilter=" + encodeURIComponent("" + maxExposureFilter) + "&"; 
        if (minExposureFilter !== undefined)
            url_ += "MinExposureFilter=" + encodeURIComponent("" + minExposureFilter) + "&"; 
        if (maxCollateralFilter !== undefined)
            url_ += "MaxCollateralFilter=" + encodeURIComponent("" + maxCollateralFilter) + "&"; 
        if (minCollateralFilter !== undefined)
            url_ += "MinCollateralFilter=" + encodeURIComponent("" + minCollateralFilter) + "&"; 
        if (maxUnsecuredPercentageFilter !== undefined)
            url_ += "MaxUnsecuredPercentageFilter=" + encodeURIComponent("" + maxUnsecuredPercentageFilter) + "&"; 
        if (minUnsecuredPercentageFilter !== undefined)
            url_ += "MinUnsecuredPercentageFilter=" + encodeURIComponent("" + minUnsecuredPercentageFilter) + "&"; 
        if (maxPercentageOfBookFilter !== undefined)
            url_ += "MaxPercentageOfBookFilter=" + encodeURIComponent("" + maxPercentageOfBookFilter) + "&"; 
        if (minPercentageOfBookFilter !== undefined)
            url_ += "MinPercentageOfBookFilter=" + encodeURIComponent("" + minPercentageOfBookFilter) + "&"; 
        if (maxMonths6CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths6CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths6CummulativeBestPDsFilter) + "&"; 
        if (minMonths6CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths6CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths6CummulativeBestPDsFilter) + "&"; 
        if (maxMonths12CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths12CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths12CummulativeBestPDsFilter) + "&"; 
        if (minMonths12CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths12CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths12CummulativeBestPDsFilter) + "&"; 
        if (maxMonths24CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths24CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths24CummulativeBestPDsFilter) + "&"; 
        if (minMonths24CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths24CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths24CummulativeBestPDsFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclResultSummaryKeyInputForEdit(id: string | null | undefined): Observable<GetRetailEclResultSummaryKeyInputForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryKeyInputs/GetRetailEclResultSummaryKeyInputForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclResultSummaryKeyInputForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclResultSummaryKeyInputForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclResultSummaryKeyInputForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclResultSummaryKeyInputForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclResultSummaryKeyInputForEdit(response: HttpResponseBase): Observable<GetRetailEclResultSummaryKeyInputForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclResultSummaryKeyInputForEditOutput.fromJS(resultData200) : new GetRetailEclResultSummaryKeyInputForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclResultSummaryKeyInputForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclResultSummaryKeyInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryKeyInputs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryKeyInputs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryKeyInputs/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclResultSummaryTopExposuresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPreOverrideExposureFilter (optional) 
     * @param minPreOverrideExposureFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPreOverrideCoverageRatioFilter (optional) 
     * @param minPreOverrideCoverageRatioFilter (optional) 
     * @param maxPostOverrideExposureFilter (optional) 
     * @param minPostOverrideExposureFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideCoverageRatioFilter (optional) 
     * @param minPostOverrideCoverageRatioFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param retailEclDataLoanBookContractNoFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxPreOverrideExposureFilter: number | null | undefined, minPreOverrideExposureFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPreOverrideCoverageRatioFilter: number | null | undefined, minPreOverrideCoverageRatioFilter: number | null | undefined, maxPostOverrideExposureFilter: number | null | undefined, minPostOverrideExposureFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, maxPostOverrideCoverageRatioFilter: number | null | undefined, minPostOverrideCoverageRatioFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, retailEclDataLoanBookContractNoFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryTopExposures/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPreOverrideExposureFilter !== undefined)
            url_ += "MaxPreOverrideExposureFilter=" + encodeURIComponent("" + maxPreOverrideExposureFilter) + "&"; 
        if (minPreOverrideExposureFilter !== undefined)
            url_ += "MinPreOverrideExposureFilter=" + encodeURIComponent("" + minPreOverrideExposureFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPreOverrideCoverageRatioFilter) + "&"; 
        if (minPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPreOverrideCoverageRatioFilter) + "&"; 
        if (maxPostOverrideExposureFilter !== undefined)
            url_ += "MaxPostOverrideExposureFilter=" + encodeURIComponent("" + maxPostOverrideExposureFilter) + "&"; 
        if (minPostOverrideExposureFilter !== undefined)
            url_ += "MinPostOverrideExposureFilter=" + encodeURIComponent("" + minPostOverrideExposureFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPostOverrideCoverageRatioFilter) + "&"; 
        if (minPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPostOverrideCoverageRatioFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (retailEclDataLoanBookContractNoFilter !== undefined)
            url_ += "RetailEclDataLoanBookContractNoFilter=" + encodeURIComponent("" + retailEclDataLoanBookContractNoFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclResultSummaryTopExposureForEdit(id: string | null | undefined): Observable<GetRetailEclResultSummaryTopExposureForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryTopExposures/GetRetailEclResultSummaryTopExposureForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclResultSummaryTopExposureForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclResultSummaryTopExposureForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclResultSummaryTopExposureForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclResultSummaryTopExposureForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclResultSummaryTopExposureForEdit(response: HttpResponseBase): Observable<GetRetailEclResultSummaryTopExposureForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclResultSummaryTopExposureForEditOutput.fromJS(resultData200) : new GetRetailEclResultSummaryTopExposureForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclResultSummaryTopExposureForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclResultSummaryTopExposureDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryTopExposures/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryTopExposures/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryTopExposures/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclResultSummaryTopExposures/GetAllRetailEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReportingDateFilter (optional) 
     * @param minReportingDateFilter (optional) 
     * @param maxClosedDateFilter (optional) 
     * @param minClosedDateFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReportingDateFilter: moment.Moment | null | undefined, minReportingDateFilter: moment.Moment | null | undefined, maxClosedDateFilter: moment.Moment | null | undefined, minClosedDateFilter: moment.Moment | null | undefined, isApprovedFilter: number | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReportingDateFilter !== undefined)
            url_ += "MaxReportingDateFilter=" + encodeURIComponent(maxReportingDateFilter ? "" + maxReportingDateFilter.toJSON() : "") + "&"; 
        if (minReportingDateFilter !== undefined)
            url_ += "MinReportingDateFilter=" + encodeURIComponent(minReportingDateFilter ? "" + minReportingDateFilter.toJSON() : "") + "&"; 
        if (maxClosedDateFilter !== undefined)
            url_ += "MaxClosedDateFilter=" + encodeURIComponent(maxClosedDateFilter ? "" + maxClosedDateFilter.toJSON() : "") + "&"; 
        if (minClosedDateFilter !== undefined)
            url_ += "MinClosedDateFilter=" + encodeURIComponent(minClosedDateFilter ? "" + minClosedDateFilter.toJSON() : "") + "&"; 
        if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclForEdit(id: string | null | undefined): Observable<GetRetailEclForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/GetRetailEclForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclForEdit(response: HttpResponseBase): Observable<GetRetailEclForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclForEditOutput.fromJS(resultData200) : new GetRetailEclForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclDetailsForEdit(id: string | null | undefined): Observable<GetRetailEclForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/GetRetailEclDetailsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclDetailsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclDetailsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclDetailsForEdit(response: HttpResponseBase): Observable<GetRetailEclForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclForEditOutput.fromJS(resultData200) : new GetRetailEclForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEclAndAssumption(input: CreateRetailEclAndAssumptions | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/CreateEclAndAssumption";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEclAndAssumption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEclAndAssumption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEclAndAssumption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    approveRejectEcl(input: CreateOrEditRetailEclApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/ApproveRejectEcl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveRejectEcl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveRejectEcl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveRejectEcl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    runEcl(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEcls/RunEcl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunEcl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunEcl(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRunEcl(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RetailEclSicrApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param retailEclSicrTenantIdFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, retailEclSicrTenantIdFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclSicrApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (retailEclSicrTenantIdFilter !== undefined)
            url_ += "RetailEclSicrTenantIdFilter=" + encodeURIComponent("" + retailEclSicrTenantIdFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclSicrApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclSicrApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclSicrApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclSicrApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclSicrApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclSicrApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclSicrApprovalForEdit(id: string | null | undefined): Observable<GetRetailEclSicrApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrApprovals/GetRetailEclSicrApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclSicrApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclSicrApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclSicrApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclSicrApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclSicrApprovalForEdit(response: HttpResponseBase): Observable<GetRetailEclSicrApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclSicrApprovalForEditOutput.fromJS(resultData200) : new GetRetailEclSicrApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclSicrApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclSicrApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclSicrForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrApprovals/GetAllRetailEclSicrForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclSicrForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclSicrForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclSicrForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclSicrsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxComputedSICRFilter (optional) 
     * @param minComputedSICRFilter (optional) 
     * @param overrideSICRFilter (optional) 
     * @param overrideCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param retailEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxComputedSICRFilter: number | null | undefined, minComputedSICRFilter: number | null | undefined, overrideSICRFilter: string | null | undefined, overrideCommentFilter: string | null | undefined, statusFilter: number | null | undefined, retailEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclSicrForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxComputedSICRFilter !== undefined)
            url_ += "MaxComputedSICRFilter=" + encodeURIComponent("" + maxComputedSICRFilter) + "&"; 
        if (minComputedSICRFilter !== undefined)
            url_ += "MinComputedSICRFilter=" + encodeURIComponent("" + minComputedSICRFilter) + "&"; 
        if (overrideSICRFilter !== undefined)
            url_ += "OverrideSICRFilter=" + encodeURIComponent("" + overrideSICRFilter) + "&"; 
        if (overrideCommentFilter !== undefined)
            url_ += "OverrideCommentFilter=" + encodeURIComponent("" + overrideCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (retailEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "RetailEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + retailEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclSicrForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclSicrForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclSicrForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclSicrForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclSicrForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclSicrForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclSicrForEdit(id: string | null | undefined): Observable<GetRetailEclSicrForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrs/GetRetailEclSicrForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclSicrForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclSicrForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclSicrForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclSicrForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclSicrForEdit(response: HttpResponseBase): Observable<GetRetailEclSicrForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclSicrForEditOutput.fromJS(resultData200) : new GetRetailEclSicrForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclSicrForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclSicrDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclSicrs/GetAllRetailEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclUploadApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param retailEclUploadTenantIdFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, retailEclUploadTenantIdFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclUploadApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploadApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (retailEclUploadTenantIdFilter !== undefined)
            url_ += "RetailEclUploadTenantIdFilter=" + encodeURIComponent("" + retailEclUploadTenantIdFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclUploadApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclUploadApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclUploadApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclUploadApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclUploadApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclUploadApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclUploadApprovalForEdit(id: string | null | undefined): Observable<GetRetailEclUploadApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploadApprovals/GetRetailEclUploadApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclUploadApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclUploadApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclUploadApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclUploadApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclUploadApprovalForEdit(response: HttpResponseBase): Observable<GetRetailEclUploadApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclUploadApprovalForEditOutput.fromJS(resultData200) : new GetRetailEclUploadApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclUploadApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclUploadApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploadApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploadApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploadApprovals/GetAllRetailEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploadApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RetailEclUploadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param docTypeFilter (optional) 
     * @param uploadCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param retailEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, docTypeFilter: number | null | undefined, uploadCommentFilter: string | null | undefined, statusFilter: number | null | undefined, retailEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRetailEclUploadForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploads/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (docTypeFilter !== undefined)
            url_ += "DocTypeFilter=" + encodeURIComponent("" + docTypeFilter) + "&"; 
        if (uploadCommentFilter !== undefined)
            url_ += "UploadCommentFilter=" + encodeURIComponent("" + uploadCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (retailEclTenantIdFilter !== undefined)
            url_ += "RetailEclTenantIdFilter=" + encodeURIComponent("" + retailEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRetailEclUploadForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRetailEclUploadForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRetailEclUploadForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRetailEclUploadForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetRetailEclUploadForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRetailEclUploadForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRetailEclUploadForEdit(id: string | null | undefined): Observable<GetRetailEclUploadForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploads/GetRetailEclUploadForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailEclUploadForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailEclUploadForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRetailEclUploadForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRetailEclUploadForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetailEclUploadForEdit(response: HttpResponseBase): Observable<GetRetailEclUploadForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRetailEclUploadForEditOutput.fromJS(resultData200) : new GetRetailEclUploadForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRetailEclUploadForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRetailEclUploadDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploads/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploads/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRetailEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/RetailEclUploads/GetAllRetailEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRetailEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRetailEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRetailEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    confirmPayment(input: StripeConfirmPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createSubscription(input: StripeCreateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSubscription(input: StripeUpdateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StripeConfigurationDto.fromJS(resultData200) : new StripeConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RefreshTokenResult.fromJS(resultData200) : new RefreshTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permission (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permission (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEadInputAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param inputNameFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, inputNameFilter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEadInputAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEadInputAssumptionForEdit(id: string | null | undefined): Observable<GetWholesaleEadInputAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEadInputAssumptions/GetWholesaleEadInputAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEadInputAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEadInputAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEadInputAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEadInputAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEadInputAssumptionForEdit(response: HttpResponseBase): Observable<GetWholesaleEadInputAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEadInputAssumptionForEditOutput.fromJS(resultData200) : new GetWholesaleEadInputAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEadInputAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEadInputAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEadInputAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEadInputAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEadInputAssumptions/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclApprovalForEdit(id: string | null | undefined): Observable<GetWholesaleEclApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclApprovals/GetWholesaleEclApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclApprovalForEdit(response: HttpResponseBase): Observable<GetWholesaleEclApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclApprovalForEditOutput.fromJS(resultData200) : new GetWholesaleEclApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclApprovals/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclAssumptionApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptionApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclAssumptionApprovalForEdit(id: string | null | undefined): Observable<GetWholesaleEclAssumptionApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptionApprovals/GetWholesaleEclAssumptionApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclAssumptionApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclAssumptionApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclAssumptionApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclAssumptionApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclAssumptionApprovalForEdit(response: HttpResponseBase): Observable<GetWholesaleEclAssumptionApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclAssumptionApprovalForEditOutput.fromJS(resultData200) : new GetWholesaleEclAssumptionApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclAssumptionApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclAssumptionApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptionApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptionApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptionApprovals/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptionApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param inputNameFilter (optional) 
     * @param isComputedFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, inputNameFilter: string | null | undefined, isComputedFilter: number | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (isComputedFilter !== undefined)
            url_ += "IsComputedFilter=" + encodeURIComponent("" + isComputedFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclAssumptionForEdit(id: string | null | undefined): Observable<GetWholesaleEclAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptions/GetWholesaleEclAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclAssumptionForEdit(response: HttpResponseBase): Observable<GetWholesaleEclAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclAssumptionForEditOutput.fromJS(resultData200) : new GetWholesaleEclAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclAssumptions/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclDataLoanBooksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customerNoFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param contractNoFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param currencyFilter (optional) 
     * @param productTypeFilter (optional) 
     * @param productMappingFilter (optional) 
     * @param specialisedLendingFilter (optional) 
     * @param ratingModelFilter (optional) 
     * @param maxOriginalRatingFilter (optional) 
     * @param minOriginalRatingFilter (optional) 
     * @param maxCurrentRatingFilter (optional) 
     * @param minCurrentRatingFilter (optional) 
     * @param maxLifetimePDFilter (optional) 
     * @param minLifetimePDFilter (optional) 
     * @param maxMonth12PDFilter (optional) 
     * @param minMonth12PDFilter (optional) 
     * @param maxDaysPastDueFilter (optional) 
     * @param minDaysPastDueFilter (optional) 
     * @param watchlistIndicatorFilter (optional) 
     * @param classificationFilter (optional) 
     * @param maxImpairedDateFilter (optional) 
     * @param minImpairedDateFilter (optional) 
     * @param maxDefaultDateFilter (optional) 
     * @param minDefaultDateFilter (optional) 
     * @param maxCreditLimitFilter (optional) 
     * @param minCreditLimitFilter (optional) 
     * @param maxOriginalBalanceLCYFilter (optional) 
     * @param minOriginalBalanceLCYFilter (optional) 
     * @param maxOutstandingBalanceLCYFilter (optional) 
     * @param minOutstandingBalanceLCYFilter (optional) 
     * @param maxOutstandingBalanceACYFilter (optional) 
     * @param minOutstandingBalanceACYFilter (optional) 
     * @param maxContractStartDateFilter (optional) 
     * @param minContractStartDateFilter (optional) 
     * @param maxContractEndDateFilter (optional) 
     * @param minContractEndDateFilter (optional) 
     * @param restructureIndicatorFilter (optional) 
     * @param restructureRiskFilter (optional) 
     * @param restructureTypeFilter (optional) 
     * @param maxRestructureStartDateFilter (optional) 
     * @param minRestructureStartDateFilter (optional) 
     * @param maxRestructureEndDateFilter (optional) 
     * @param minRestructureEndDateFilter (optional) 
     * @param principalPaymentTermsOriginationFilter (optional) 
     * @param maxPPTOPeriodFilter (optional) 
     * @param minPPTOPeriodFilter (optional) 
     * @param interestPaymentTermsOriginationFilter (optional) 
     * @param maxIPTOPeriodFilter (optional) 
     * @param minIPTOPeriodFilter (optional) 
     * @param principalPaymentStructureFilter (optional) 
     * @param interestPaymentStructureFilter (optional) 
     * @param interestRateTypeFilter (optional) 
     * @param baseRateFilter (optional) 
     * @param originationContractualInterestRateFilter (optional) 
     * @param maxIntroductoryPeriodFilter (optional) 
     * @param minIntroductoryPeriodFilter (optional) 
     * @param maxPostIPContractualInterestRateFilter (optional) 
     * @param minPostIPContractualInterestRateFilter (optional) 
     * @param maxCurrentContractualInterestRateFilter (optional) 
     * @param minCurrentContractualInterestRateFilter (optional) 
     * @param maxEIRFilter (optional) 
     * @param minEIRFilter (optional) 
     * @param maxDebentureOMVFilter (optional) 
     * @param minDebentureOMVFilter (optional) 
     * @param maxDebentureFSVFilter (optional) 
     * @param minDebentureFSVFilter (optional) 
     * @param maxCashOMVFilter (optional) 
     * @param minCashOMVFilter (optional) 
     * @param maxCashFSVFilter (optional) 
     * @param minCashFSVFilter (optional) 
     * @param maxInventoryOMVFilter (optional) 
     * @param minInventoryOMVFilter (optional) 
     * @param maxInventoryFSVFilter (optional) 
     * @param minInventoryFSVFilter (optional) 
     * @param maxPlantEquipmentOMVFilter (optional) 
     * @param minPlantEquipmentOMVFilter (optional) 
     * @param maxPlantEquipmentFSVFilter (optional) 
     * @param minPlantEquipmentFSVFilter (optional) 
     * @param maxResidentialPropertyOMVFilter (optional) 
     * @param minResidentialPropertyOMVFilter (optional) 
     * @param maxResidentialPropertyFSVFilter (optional) 
     * @param minResidentialPropertyFSVFilter (optional) 
     * @param maxCommercialPropertyOMVFilter (optional) 
     * @param minCommercialPropertyOMVFilter (optional) 
     * @param maxCommercialPropertyFilter (optional) 
     * @param minCommercialPropertyFilter (optional) 
     * @param maxReceivablesOMVFilter (optional) 
     * @param minReceivablesOMVFilter (optional) 
     * @param maxReceivablesFSVFilter (optional) 
     * @param minReceivablesFSVFilter (optional) 
     * @param maxSharesOMVFilter (optional) 
     * @param minSharesOMVFilter (optional) 
     * @param maxSharesFSVFilter (optional) 
     * @param minSharesFSVFilter (optional) 
     * @param maxVehicleOMVFilter (optional) 
     * @param minVehicleOMVFilter (optional) 
     * @param maxVehicleFSVFilter (optional) 
     * @param minVehicleFSVFilter (optional) 
     * @param maxCureRateFilter (optional) 
     * @param minCureRateFilter (optional) 
     * @param guaranteeIndicatorFilter (optional) 
     * @param guarantorPDFilter (optional) 
     * @param guarantorLGDFilter (optional) 
     * @param maxGuaranteeValueFilter (optional) 
     * @param minGuaranteeValueFilter (optional) 
     * @param maxGuaranteeLevelFilter (optional) 
     * @param minGuaranteeLevelFilter (optional) 
     * @param contractIdFilter (optional) 
     * @param wholesaleEclUploadUploadCommentFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, customerNoFilter: string | null | undefined, accountNoFilter: string | null | undefined, contractNoFilter: string | null | undefined, customerNameFilter: string | null | undefined, currencyFilter: string | null | undefined, productTypeFilter: string | null | undefined, productMappingFilter: string | null | undefined, specialisedLendingFilter: string | null | undefined, ratingModelFilter: string | null | undefined, maxOriginalRatingFilter: number | null | undefined, minOriginalRatingFilter: number | null | undefined, maxCurrentRatingFilter: number | null | undefined, minCurrentRatingFilter: number | null | undefined, maxLifetimePDFilter: number | null | undefined, minLifetimePDFilter: number | null | undefined, maxMonth12PDFilter: number | null | undefined, minMonth12PDFilter: number | null | undefined, maxDaysPastDueFilter: number | null | undefined, minDaysPastDueFilter: number | null | undefined, watchlistIndicatorFilter: number | null | undefined, classificationFilter: string | null | undefined, maxImpairedDateFilter: moment.Moment | null | undefined, minImpairedDateFilter: moment.Moment | null | undefined, maxDefaultDateFilter: moment.Moment | null | undefined, minDefaultDateFilter: moment.Moment | null | undefined, maxCreditLimitFilter: number | null | undefined, minCreditLimitFilter: number | null | undefined, maxOriginalBalanceLCYFilter: number | null | undefined, minOriginalBalanceLCYFilter: number | null | undefined, maxOutstandingBalanceLCYFilter: number | null | undefined, minOutstandingBalanceLCYFilter: number | null | undefined, maxOutstandingBalanceACYFilter: number | null | undefined, minOutstandingBalanceACYFilter: number | null | undefined, maxContractStartDateFilter: moment.Moment | null | undefined, minContractStartDateFilter: moment.Moment | null | undefined, maxContractEndDateFilter: moment.Moment | null | undefined, minContractEndDateFilter: moment.Moment | null | undefined, restructureIndicatorFilter: number | null | undefined, restructureRiskFilter: string | null | undefined, restructureTypeFilter: string | null | undefined, maxRestructureStartDateFilter: moment.Moment | null | undefined, minRestructureStartDateFilter: moment.Moment | null | undefined, maxRestructureEndDateFilter: moment.Moment | null | undefined, minRestructureEndDateFilter: moment.Moment | null | undefined, principalPaymentTermsOriginationFilter: string | null | undefined, maxPPTOPeriodFilter: number | null | undefined, minPPTOPeriodFilter: number | null | undefined, interestPaymentTermsOriginationFilter: string | null | undefined, maxIPTOPeriodFilter: number | null | undefined, minIPTOPeriodFilter: number | null | undefined, principalPaymentStructureFilter: string | null | undefined, interestPaymentStructureFilter: string | null | undefined, interestRateTypeFilter: string | null | undefined, baseRateFilter: string | null | undefined, originationContractualInterestRateFilter: string | null | undefined, maxIntroductoryPeriodFilter: number | null | undefined, minIntroductoryPeriodFilter: number | null | undefined, maxPostIPContractualInterestRateFilter: number | null | undefined, minPostIPContractualInterestRateFilter: number | null | undefined, maxCurrentContractualInterestRateFilter: number | null | undefined, minCurrentContractualInterestRateFilter: number | null | undefined, maxEIRFilter: number | null | undefined, minEIRFilter: number | null | undefined, maxDebentureOMVFilter: number | null | undefined, minDebentureOMVFilter: number | null | undefined, maxDebentureFSVFilter: number | null | undefined, minDebentureFSVFilter: number | null | undefined, maxCashOMVFilter: number | null | undefined, minCashOMVFilter: number | null | undefined, maxCashFSVFilter: number | null | undefined, minCashFSVFilter: number | null | undefined, maxInventoryOMVFilter: number | null | undefined, minInventoryOMVFilter: number | null | undefined, maxInventoryFSVFilter: number | null | undefined, minInventoryFSVFilter: number | null | undefined, maxPlantEquipmentOMVFilter: number | null | undefined, minPlantEquipmentOMVFilter: number | null | undefined, maxPlantEquipmentFSVFilter: number | null | undefined, minPlantEquipmentFSVFilter: number | null | undefined, maxResidentialPropertyOMVFilter: number | null | undefined, minResidentialPropertyOMVFilter: number | null | undefined, maxResidentialPropertyFSVFilter: number | null | undefined, minResidentialPropertyFSVFilter: number | null | undefined, maxCommercialPropertyOMVFilter: number | null | undefined, minCommercialPropertyOMVFilter: number | null | undefined, maxCommercialPropertyFilter: number | null | undefined, minCommercialPropertyFilter: number | null | undefined, maxReceivablesOMVFilter: number | null | undefined, minReceivablesOMVFilter: number | null | undefined, maxReceivablesFSVFilter: number | null | undefined, minReceivablesFSVFilter: number | null | undefined, maxSharesOMVFilter: number | null | undefined, minSharesOMVFilter: number | null | undefined, maxSharesFSVFilter: number | null | undefined, minSharesFSVFilter: number | null | undefined, maxVehicleOMVFilter: number | null | undefined, minVehicleOMVFilter: number | null | undefined, maxVehicleFSVFilter: number | null | undefined, minVehicleFSVFilter: number | null | undefined, maxCureRateFilter: number | null | undefined, minCureRateFilter: number | null | undefined, guaranteeIndicatorFilter: number | null | undefined, guarantorPDFilter: string | null | undefined, guarantorLGDFilter: string | null | undefined, maxGuaranteeValueFilter: number | null | undefined, minGuaranteeValueFilter: number | null | undefined, maxGuaranteeLevelFilter: number | null | undefined, minGuaranteeLevelFilter: number | null | undefined, contractIdFilter: string | null | undefined, wholesaleEclUploadUploadCommentFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataLoanBooks/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (customerNoFilter !== undefined)
            url_ += "CustomerNoFilter=" + encodeURIComponent("" + customerNoFilter) + "&"; 
        if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&"; 
        if (contractNoFilter !== undefined)
            url_ += "ContractNoFilter=" + encodeURIComponent("" + contractNoFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&"; 
        if (productTypeFilter !== undefined)
            url_ += "ProductTypeFilter=" + encodeURIComponent("" + productTypeFilter) + "&"; 
        if (productMappingFilter !== undefined)
            url_ += "ProductMappingFilter=" + encodeURIComponent("" + productMappingFilter) + "&"; 
        if (specialisedLendingFilter !== undefined)
            url_ += "SpecialisedLendingFilter=" + encodeURIComponent("" + specialisedLendingFilter) + "&"; 
        if (ratingModelFilter !== undefined)
            url_ += "RatingModelFilter=" + encodeURIComponent("" + ratingModelFilter) + "&"; 
        if (maxOriginalRatingFilter !== undefined)
            url_ += "MaxOriginalRatingFilter=" + encodeURIComponent("" + maxOriginalRatingFilter) + "&"; 
        if (minOriginalRatingFilter !== undefined)
            url_ += "MinOriginalRatingFilter=" + encodeURIComponent("" + minOriginalRatingFilter) + "&"; 
        if (maxCurrentRatingFilter !== undefined)
            url_ += "MaxCurrentRatingFilter=" + encodeURIComponent("" + maxCurrentRatingFilter) + "&"; 
        if (minCurrentRatingFilter !== undefined)
            url_ += "MinCurrentRatingFilter=" + encodeURIComponent("" + minCurrentRatingFilter) + "&"; 
        if (maxLifetimePDFilter !== undefined)
            url_ += "MaxLifetimePDFilter=" + encodeURIComponent("" + maxLifetimePDFilter) + "&"; 
        if (minLifetimePDFilter !== undefined)
            url_ += "MinLifetimePDFilter=" + encodeURIComponent("" + minLifetimePDFilter) + "&"; 
        if (maxMonth12PDFilter !== undefined)
            url_ += "MaxMonth12PDFilter=" + encodeURIComponent("" + maxMonth12PDFilter) + "&"; 
        if (minMonth12PDFilter !== undefined)
            url_ += "MinMonth12PDFilter=" + encodeURIComponent("" + minMonth12PDFilter) + "&"; 
        if (maxDaysPastDueFilter !== undefined)
            url_ += "MaxDaysPastDueFilter=" + encodeURIComponent("" + maxDaysPastDueFilter) + "&"; 
        if (minDaysPastDueFilter !== undefined)
            url_ += "MinDaysPastDueFilter=" + encodeURIComponent("" + minDaysPastDueFilter) + "&"; 
        if (watchlistIndicatorFilter !== undefined)
            url_ += "WatchlistIndicatorFilter=" + encodeURIComponent("" + watchlistIndicatorFilter) + "&"; 
        if (classificationFilter !== undefined)
            url_ += "ClassificationFilter=" + encodeURIComponent("" + classificationFilter) + "&"; 
        if (maxImpairedDateFilter !== undefined)
            url_ += "MaxImpairedDateFilter=" + encodeURIComponent(maxImpairedDateFilter ? "" + maxImpairedDateFilter.toJSON() : "") + "&"; 
        if (minImpairedDateFilter !== undefined)
            url_ += "MinImpairedDateFilter=" + encodeURIComponent(minImpairedDateFilter ? "" + minImpairedDateFilter.toJSON() : "") + "&"; 
        if (maxDefaultDateFilter !== undefined)
            url_ += "MaxDefaultDateFilter=" + encodeURIComponent(maxDefaultDateFilter ? "" + maxDefaultDateFilter.toJSON() : "") + "&"; 
        if (minDefaultDateFilter !== undefined)
            url_ += "MinDefaultDateFilter=" + encodeURIComponent(minDefaultDateFilter ? "" + minDefaultDateFilter.toJSON() : "") + "&"; 
        if (maxCreditLimitFilter !== undefined)
            url_ += "MaxCreditLimitFilter=" + encodeURIComponent("" + maxCreditLimitFilter) + "&"; 
        if (minCreditLimitFilter !== undefined)
            url_ += "MinCreditLimitFilter=" + encodeURIComponent("" + minCreditLimitFilter) + "&"; 
        if (maxOriginalBalanceLCYFilter !== undefined)
            url_ += "MaxOriginalBalanceLCYFilter=" + encodeURIComponent("" + maxOriginalBalanceLCYFilter) + "&"; 
        if (minOriginalBalanceLCYFilter !== undefined)
            url_ += "MinOriginalBalanceLCYFilter=" + encodeURIComponent("" + minOriginalBalanceLCYFilter) + "&"; 
        if (maxOutstandingBalanceLCYFilter !== undefined)
            url_ += "MaxOutstandingBalanceLCYFilter=" + encodeURIComponent("" + maxOutstandingBalanceLCYFilter) + "&"; 
        if (minOutstandingBalanceLCYFilter !== undefined)
            url_ += "MinOutstandingBalanceLCYFilter=" + encodeURIComponent("" + minOutstandingBalanceLCYFilter) + "&"; 
        if (maxOutstandingBalanceACYFilter !== undefined)
            url_ += "MaxOutstandingBalanceACYFilter=" + encodeURIComponent("" + maxOutstandingBalanceACYFilter) + "&"; 
        if (minOutstandingBalanceACYFilter !== undefined)
            url_ += "MinOutstandingBalanceACYFilter=" + encodeURIComponent("" + minOutstandingBalanceACYFilter) + "&"; 
        if (maxContractStartDateFilter !== undefined)
            url_ += "MaxContractStartDateFilter=" + encodeURIComponent(maxContractStartDateFilter ? "" + maxContractStartDateFilter.toJSON() : "") + "&"; 
        if (minContractStartDateFilter !== undefined)
            url_ += "MinContractStartDateFilter=" + encodeURIComponent(minContractStartDateFilter ? "" + minContractStartDateFilter.toJSON() : "") + "&"; 
        if (maxContractEndDateFilter !== undefined)
            url_ += "MaxContractEndDateFilter=" + encodeURIComponent(maxContractEndDateFilter ? "" + maxContractEndDateFilter.toJSON() : "") + "&"; 
        if (minContractEndDateFilter !== undefined)
            url_ += "MinContractEndDateFilter=" + encodeURIComponent(minContractEndDateFilter ? "" + minContractEndDateFilter.toJSON() : "") + "&"; 
        if (restructureIndicatorFilter !== undefined)
            url_ += "RestructureIndicatorFilter=" + encodeURIComponent("" + restructureIndicatorFilter) + "&"; 
        if (restructureRiskFilter !== undefined)
            url_ += "RestructureRiskFilter=" + encodeURIComponent("" + restructureRiskFilter) + "&"; 
        if (restructureTypeFilter !== undefined)
            url_ += "RestructureTypeFilter=" + encodeURIComponent("" + restructureTypeFilter) + "&"; 
        if (maxRestructureStartDateFilter !== undefined)
            url_ += "MaxRestructureStartDateFilter=" + encodeURIComponent(maxRestructureStartDateFilter ? "" + maxRestructureStartDateFilter.toJSON() : "") + "&"; 
        if (minRestructureStartDateFilter !== undefined)
            url_ += "MinRestructureStartDateFilter=" + encodeURIComponent(minRestructureStartDateFilter ? "" + minRestructureStartDateFilter.toJSON() : "") + "&"; 
        if (maxRestructureEndDateFilter !== undefined)
            url_ += "MaxRestructureEndDateFilter=" + encodeURIComponent(maxRestructureEndDateFilter ? "" + maxRestructureEndDateFilter.toJSON() : "") + "&"; 
        if (minRestructureEndDateFilter !== undefined)
            url_ += "MinRestructureEndDateFilter=" + encodeURIComponent(minRestructureEndDateFilter ? "" + minRestructureEndDateFilter.toJSON() : "") + "&"; 
        if (principalPaymentTermsOriginationFilter !== undefined)
            url_ += "PrincipalPaymentTermsOriginationFilter=" + encodeURIComponent("" + principalPaymentTermsOriginationFilter) + "&"; 
        if (maxPPTOPeriodFilter !== undefined)
            url_ += "MaxPPTOPeriodFilter=" + encodeURIComponent("" + maxPPTOPeriodFilter) + "&"; 
        if (minPPTOPeriodFilter !== undefined)
            url_ += "MinPPTOPeriodFilter=" + encodeURIComponent("" + minPPTOPeriodFilter) + "&"; 
        if (interestPaymentTermsOriginationFilter !== undefined)
            url_ += "InterestPaymentTermsOriginationFilter=" + encodeURIComponent("" + interestPaymentTermsOriginationFilter) + "&"; 
        if (maxIPTOPeriodFilter !== undefined)
            url_ += "MaxIPTOPeriodFilter=" + encodeURIComponent("" + maxIPTOPeriodFilter) + "&"; 
        if (minIPTOPeriodFilter !== undefined)
            url_ += "MinIPTOPeriodFilter=" + encodeURIComponent("" + minIPTOPeriodFilter) + "&"; 
        if (principalPaymentStructureFilter !== undefined)
            url_ += "PrincipalPaymentStructureFilter=" + encodeURIComponent("" + principalPaymentStructureFilter) + "&"; 
        if (interestPaymentStructureFilter !== undefined)
            url_ += "InterestPaymentStructureFilter=" + encodeURIComponent("" + interestPaymentStructureFilter) + "&"; 
        if (interestRateTypeFilter !== undefined)
            url_ += "InterestRateTypeFilter=" + encodeURIComponent("" + interestRateTypeFilter) + "&"; 
        if (baseRateFilter !== undefined)
            url_ += "BaseRateFilter=" + encodeURIComponent("" + baseRateFilter) + "&"; 
        if (originationContractualInterestRateFilter !== undefined)
            url_ += "OriginationContractualInterestRateFilter=" + encodeURIComponent("" + originationContractualInterestRateFilter) + "&"; 
        if (maxIntroductoryPeriodFilter !== undefined)
            url_ += "MaxIntroductoryPeriodFilter=" + encodeURIComponent("" + maxIntroductoryPeriodFilter) + "&"; 
        if (minIntroductoryPeriodFilter !== undefined)
            url_ += "MinIntroductoryPeriodFilter=" + encodeURIComponent("" + minIntroductoryPeriodFilter) + "&"; 
        if (maxPostIPContractualInterestRateFilter !== undefined)
            url_ += "MaxPostIPContractualInterestRateFilter=" + encodeURIComponent("" + maxPostIPContractualInterestRateFilter) + "&"; 
        if (minPostIPContractualInterestRateFilter !== undefined)
            url_ += "MinPostIPContractualInterestRateFilter=" + encodeURIComponent("" + minPostIPContractualInterestRateFilter) + "&"; 
        if (maxCurrentContractualInterestRateFilter !== undefined)
            url_ += "MaxCurrentContractualInterestRateFilter=" + encodeURIComponent("" + maxCurrentContractualInterestRateFilter) + "&"; 
        if (minCurrentContractualInterestRateFilter !== undefined)
            url_ += "MinCurrentContractualInterestRateFilter=" + encodeURIComponent("" + minCurrentContractualInterestRateFilter) + "&"; 
        if (maxEIRFilter !== undefined)
            url_ += "MaxEIRFilter=" + encodeURIComponent("" + maxEIRFilter) + "&"; 
        if (minEIRFilter !== undefined)
            url_ += "MinEIRFilter=" + encodeURIComponent("" + minEIRFilter) + "&"; 
        if (maxDebentureOMVFilter !== undefined)
            url_ += "MaxDebentureOMVFilter=" + encodeURIComponent("" + maxDebentureOMVFilter) + "&"; 
        if (minDebentureOMVFilter !== undefined)
            url_ += "MinDebentureOMVFilter=" + encodeURIComponent("" + minDebentureOMVFilter) + "&"; 
        if (maxDebentureFSVFilter !== undefined)
            url_ += "MaxDebentureFSVFilter=" + encodeURIComponent("" + maxDebentureFSVFilter) + "&"; 
        if (minDebentureFSVFilter !== undefined)
            url_ += "MinDebentureFSVFilter=" + encodeURIComponent("" + minDebentureFSVFilter) + "&"; 
        if (maxCashOMVFilter !== undefined)
            url_ += "MaxCashOMVFilter=" + encodeURIComponent("" + maxCashOMVFilter) + "&"; 
        if (minCashOMVFilter !== undefined)
            url_ += "MinCashOMVFilter=" + encodeURIComponent("" + minCashOMVFilter) + "&"; 
        if (maxCashFSVFilter !== undefined)
            url_ += "MaxCashFSVFilter=" + encodeURIComponent("" + maxCashFSVFilter) + "&"; 
        if (minCashFSVFilter !== undefined)
            url_ += "MinCashFSVFilter=" + encodeURIComponent("" + minCashFSVFilter) + "&"; 
        if (maxInventoryOMVFilter !== undefined)
            url_ += "MaxInventoryOMVFilter=" + encodeURIComponent("" + maxInventoryOMVFilter) + "&"; 
        if (minInventoryOMVFilter !== undefined)
            url_ += "MinInventoryOMVFilter=" + encodeURIComponent("" + minInventoryOMVFilter) + "&"; 
        if (maxInventoryFSVFilter !== undefined)
            url_ += "MaxInventoryFSVFilter=" + encodeURIComponent("" + maxInventoryFSVFilter) + "&"; 
        if (minInventoryFSVFilter !== undefined)
            url_ += "MinInventoryFSVFilter=" + encodeURIComponent("" + minInventoryFSVFilter) + "&"; 
        if (maxPlantEquipmentOMVFilter !== undefined)
            url_ += "MaxPlantEquipmentOMVFilter=" + encodeURIComponent("" + maxPlantEquipmentOMVFilter) + "&"; 
        if (minPlantEquipmentOMVFilter !== undefined)
            url_ += "MinPlantEquipmentOMVFilter=" + encodeURIComponent("" + minPlantEquipmentOMVFilter) + "&"; 
        if (maxPlantEquipmentFSVFilter !== undefined)
            url_ += "MaxPlantEquipmentFSVFilter=" + encodeURIComponent("" + maxPlantEquipmentFSVFilter) + "&"; 
        if (minPlantEquipmentFSVFilter !== undefined)
            url_ += "MinPlantEquipmentFSVFilter=" + encodeURIComponent("" + minPlantEquipmentFSVFilter) + "&"; 
        if (maxResidentialPropertyOMVFilter !== undefined)
            url_ += "MaxResidentialPropertyOMVFilter=" + encodeURIComponent("" + maxResidentialPropertyOMVFilter) + "&"; 
        if (minResidentialPropertyOMVFilter !== undefined)
            url_ += "MinResidentialPropertyOMVFilter=" + encodeURIComponent("" + minResidentialPropertyOMVFilter) + "&"; 
        if (maxResidentialPropertyFSVFilter !== undefined)
            url_ += "MaxResidentialPropertyFSVFilter=" + encodeURIComponent("" + maxResidentialPropertyFSVFilter) + "&"; 
        if (minResidentialPropertyFSVFilter !== undefined)
            url_ += "MinResidentialPropertyFSVFilter=" + encodeURIComponent("" + minResidentialPropertyFSVFilter) + "&"; 
        if (maxCommercialPropertyOMVFilter !== undefined)
            url_ += "MaxCommercialPropertyOMVFilter=" + encodeURIComponent("" + maxCommercialPropertyOMVFilter) + "&"; 
        if (minCommercialPropertyOMVFilter !== undefined)
            url_ += "MinCommercialPropertyOMVFilter=" + encodeURIComponent("" + minCommercialPropertyOMVFilter) + "&"; 
        if (maxCommercialPropertyFilter !== undefined)
            url_ += "MaxCommercialPropertyFilter=" + encodeURIComponent("" + maxCommercialPropertyFilter) + "&"; 
        if (minCommercialPropertyFilter !== undefined)
            url_ += "MinCommercialPropertyFilter=" + encodeURIComponent("" + minCommercialPropertyFilter) + "&"; 
        if (maxReceivablesOMVFilter !== undefined)
            url_ += "MaxReceivablesOMVFilter=" + encodeURIComponent("" + maxReceivablesOMVFilter) + "&"; 
        if (minReceivablesOMVFilter !== undefined)
            url_ += "MinReceivablesOMVFilter=" + encodeURIComponent("" + minReceivablesOMVFilter) + "&"; 
        if (maxReceivablesFSVFilter !== undefined)
            url_ += "MaxReceivablesFSVFilter=" + encodeURIComponent("" + maxReceivablesFSVFilter) + "&"; 
        if (minReceivablesFSVFilter !== undefined)
            url_ += "MinReceivablesFSVFilter=" + encodeURIComponent("" + minReceivablesFSVFilter) + "&"; 
        if (maxSharesOMVFilter !== undefined)
            url_ += "MaxSharesOMVFilter=" + encodeURIComponent("" + maxSharesOMVFilter) + "&"; 
        if (minSharesOMVFilter !== undefined)
            url_ += "MinSharesOMVFilter=" + encodeURIComponent("" + minSharesOMVFilter) + "&"; 
        if (maxSharesFSVFilter !== undefined)
            url_ += "MaxSharesFSVFilter=" + encodeURIComponent("" + maxSharesFSVFilter) + "&"; 
        if (minSharesFSVFilter !== undefined)
            url_ += "MinSharesFSVFilter=" + encodeURIComponent("" + minSharesFSVFilter) + "&"; 
        if (maxVehicleOMVFilter !== undefined)
            url_ += "MaxVehicleOMVFilter=" + encodeURIComponent("" + maxVehicleOMVFilter) + "&"; 
        if (minVehicleOMVFilter !== undefined)
            url_ += "MinVehicleOMVFilter=" + encodeURIComponent("" + minVehicleOMVFilter) + "&"; 
        if (maxVehicleFSVFilter !== undefined)
            url_ += "MaxVehicleFSVFilter=" + encodeURIComponent("" + maxVehicleFSVFilter) + "&"; 
        if (minVehicleFSVFilter !== undefined)
            url_ += "MinVehicleFSVFilter=" + encodeURIComponent("" + minVehicleFSVFilter) + "&"; 
        if (maxCureRateFilter !== undefined)
            url_ += "MaxCureRateFilter=" + encodeURIComponent("" + maxCureRateFilter) + "&"; 
        if (minCureRateFilter !== undefined)
            url_ += "MinCureRateFilter=" + encodeURIComponent("" + minCureRateFilter) + "&"; 
        if (guaranteeIndicatorFilter !== undefined)
            url_ += "GuaranteeIndicatorFilter=" + encodeURIComponent("" + guaranteeIndicatorFilter) + "&"; 
        if (guarantorPDFilter !== undefined)
            url_ += "GuarantorPDFilter=" + encodeURIComponent("" + guarantorPDFilter) + "&"; 
        if (guarantorLGDFilter !== undefined)
            url_ += "GuarantorLGDFilter=" + encodeURIComponent("" + guarantorLGDFilter) + "&"; 
        if (maxGuaranteeValueFilter !== undefined)
            url_ += "MaxGuaranteeValueFilter=" + encodeURIComponent("" + maxGuaranteeValueFilter) + "&"; 
        if (minGuaranteeValueFilter !== undefined)
            url_ += "MinGuaranteeValueFilter=" + encodeURIComponent("" + minGuaranteeValueFilter) + "&"; 
        if (maxGuaranteeLevelFilter !== undefined)
            url_ += "MaxGuaranteeLevelFilter=" + encodeURIComponent("" + maxGuaranteeLevelFilter) + "&"; 
        if (minGuaranteeLevelFilter !== undefined)
            url_ += "MinGuaranteeLevelFilter=" + encodeURIComponent("" + minGuaranteeLevelFilter) + "&"; 
        if (contractIdFilter !== undefined)
            url_ += "ContractIdFilter=" + encodeURIComponent("" + contractIdFilter) + "&"; 
        if (wholesaleEclUploadUploadCommentFilter !== undefined)
            url_ += "WholesaleEclUploadUploadCommentFilter=" + encodeURIComponent("" + wholesaleEclUploadUploadCommentFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclDataLoanBookForEdit(id: string | null | undefined): Observable<GetWholesaleEclDataLoanBookForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataLoanBooks/GetWholesaleEclDataLoanBookForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclDataLoanBookForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclDataLoanBookForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclDataLoanBookForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclDataLoanBookForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclDataLoanBookForEdit(response: HttpResponseBase): Observable<GetWholesaleEclDataLoanBookForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclDataLoanBookForEditOutput.fromJS(resultData200) : new GetWholesaleEclDataLoanBookForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclDataLoanBookForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclDataLoanBookDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataLoanBooks/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataLoanBooks/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataLoanBooks/GetAllWholesaleEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclDataPaymentSchedulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param contractRefNoFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param componentFilter (optional) 
     * @param maxNoOfSchedulesFilter (optional) 
     * @param minNoOfSchedulesFilter (optional) 
     * @param frequencyFilter (optional) 
     * @param maxAmountFilter (optional) 
     * @param minAmountFilter (optional) 
     * @param wholesaleEclUploadUploadCommentFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, contractRefNoFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, componentFilter: string | null | undefined, maxNoOfSchedulesFilter: number | null | undefined, minNoOfSchedulesFilter: number | null | undefined, frequencyFilter: string | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, wholesaleEclUploadUploadCommentFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataPaymentSchedules/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (contractRefNoFilter !== undefined)
            url_ += "ContractRefNoFilter=" + encodeURIComponent("" + contractRefNoFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (componentFilter !== undefined)
            url_ += "ComponentFilter=" + encodeURIComponent("" + componentFilter) + "&"; 
        if (maxNoOfSchedulesFilter !== undefined)
            url_ += "MaxNoOfSchedulesFilter=" + encodeURIComponent("" + maxNoOfSchedulesFilter) + "&"; 
        if (minNoOfSchedulesFilter !== undefined)
            url_ += "MinNoOfSchedulesFilter=" + encodeURIComponent("" + minNoOfSchedulesFilter) + "&"; 
        if (frequencyFilter !== undefined)
            url_ += "FrequencyFilter=" + encodeURIComponent("" + frequencyFilter) + "&"; 
        if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&"; 
        if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&"; 
        if (wholesaleEclUploadUploadCommentFilter !== undefined)
            url_ += "WholesaleEclUploadUploadCommentFilter=" + encodeURIComponent("" + wholesaleEclUploadUploadCommentFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclDataPaymentScheduleForEdit(id: string | null | undefined): Observable<GetWholesaleEclDataPaymentScheduleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataPaymentSchedules/GetWholesaleEclDataPaymentScheduleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclDataPaymentScheduleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclDataPaymentScheduleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclDataPaymentScheduleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclDataPaymentScheduleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclDataPaymentScheduleForEdit(response: HttpResponseBase): Observable<GetWholesaleEclDataPaymentScheduleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclDataPaymentScheduleForEditOutput.fromJS(resultData200) : new GetWholesaleEclDataPaymentScheduleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclDataPaymentScheduleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclDataPaymentScheduleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataPaymentSchedules/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataPaymentSchedules/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclDataPaymentSchedules/GetAllWholesaleEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclLgdAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param inputNameFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, inputNameFilter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclLgdAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (inputNameFilter !== undefined)
            url_ += "InputNameFilter=" + encodeURIComponent("" + inputNameFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclLgdAssumptionForEdit(id: string | null | undefined): Observable<GetWholesaleEclLgdAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclLgdAssumptions/GetWholesaleEclLgdAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclLgdAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclLgdAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclLgdAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclLgdAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclLgdAssumptionForEdit(response: HttpResponseBase): Observable<GetWholesaleEclLgdAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclLgdAssumptionForEditOutput.fromJS(resultData200) : new GetWholesaleEclLgdAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclLgdAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclLgdAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclLgdAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclLgdAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclLgdAssumptions/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclPdAssumption12MonthsesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxCreditFilter (optional) 
     * @param minCreditFilter (optional) 
     * @param maxPDFilter (optional) 
     * @param minPDFilter (optional) 
     * @param snPMappingEtiCreditPolicyFilter (optional) 
     * @param snPMappingBestFitFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxCreditFilter: number | null | undefined, minCreditFilter: number | null | undefined, maxPDFilter: number | null | undefined, minPDFilter: number | null | undefined, snPMappingEtiCreditPolicyFilter: string | null | undefined, snPMappingBestFitFilter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumption12Monthses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxCreditFilter !== undefined)
            url_ += "MaxCreditFilter=" + encodeURIComponent("" + maxCreditFilter) + "&"; 
        if (minCreditFilter !== undefined)
            url_ += "MinCreditFilter=" + encodeURIComponent("" + minCreditFilter) + "&"; 
        if (maxPDFilter !== undefined)
            url_ += "MaxPDFilter=" + encodeURIComponent("" + maxPDFilter) + "&"; 
        if (minPDFilter !== undefined)
            url_ += "MinPDFilter=" + encodeURIComponent("" + minPDFilter) + "&"; 
        if (snPMappingEtiCreditPolicyFilter !== undefined)
            url_ += "SnPMappingEtiCreditPolicyFilter=" + encodeURIComponent("" + snPMappingEtiCreditPolicyFilter) + "&"; 
        if (snPMappingBestFitFilter !== undefined)
            url_ += "SnPMappingBestFitFilter=" + encodeURIComponent("" + snPMappingBestFitFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclPdAssumption12MonthsForEdit(id: string | null | undefined): Observable<GetWholesaleEclPdAssumption12MonthsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumption12Monthses/GetWholesaleEclPdAssumption12MonthsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclPdAssumption12MonthsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclPdAssumption12MonthsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclPdAssumption12MonthsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclPdAssumption12MonthsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclPdAssumption12MonthsForEdit(response: HttpResponseBase): Observable<GetWholesaleEclPdAssumption12MonthsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclPdAssumption12MonthsForEditOutput.fromJS(resultData200) : new GetWholesaleEclPdAssumption12MonthsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclPdAssumption12MonthsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclPdAssumption12MonthsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumption12Monthses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumption12Monthses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumption12Monthses/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclPdAssumptionMacroeconomicInputsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicInputs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclPdAssumptionMacroeconomicInputForEdit(id: string | null | undefined): Observable<GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicInputs/GetWholesaleEclPdAssumptionMacroeconomicInputForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclPdAssumptionMacroeconomicInputForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclPdAssumptionMacroeconomicInputForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclPdAssumptionMacroeconomicInputForEdit(response: HttpResponseBase): Observable<GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput.fromJS(resultData200) : new GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicInputs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicInputs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicInputs/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclPdAssumptionMacroeconomicProjectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicProjections/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclPdAssumptionMacroeconomicProjectionForEdit(id: string | null | undefined): Observable<GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicProjections/GetWholesaleEclPdAssumptionMacroeconomicProjectionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclPdAssumptionMacroeconomicProjectionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclPdAssumptionMacroeconomicProjectionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclPdAssumptionMacroeconomicProjectionForEdit(response: HttpResponseBase): Observable<GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput.fromJS(resultData200) : new GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicProjections/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicProjections/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionMacroeconomicProjections/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclPdAssumptionNplIndexesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionNplIndexes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclPdAssumptionNplIndexForEdit(id: string | null | undefined): Observable<GetWholesaleEclPdAssumptionNplIndexForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionNplIndexes/GetWholesaleEclPdAssumptionNplIndexForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclPdAssumptionNplIndexForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclPdAssumptionNplIndexForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclPdAssumptionNplIndexForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclPdAssumptionNplIndexForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclPdAssumptionNplIndexForEdit(response: HttpResponseBase): Observable<GetWholesaleEclPdAssumptionNplIndexForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclPdAssumptionNplIndexForEditOutput.fromJS(resultData200) : new GetWholesaleEclPdAssumptionNplIndexForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclPdAssumptionNplIndexForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclPdAssumptionNplIndexDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionNplIndexes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionNplIndexes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptionNplIndexes/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclPdAssumptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclPdAssumptionForEdit(id: string | null | undefined): Observable<GetWholesaleEclPdAssumptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptions/GetWholesaleEclPdAssumptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclPdAssumptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclPdAssumptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclPdAssumptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclPdAssumptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclPdAssumptionForEdit(response: HttpResponseBase): Observable<GetWholesaleEclPdAssumptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclPdAssumptionForEditOutput.fromJS(resultData200) : new GetWholesaleEclPdAssumptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclPdAssumptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclPdAssumptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdAssumptions/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclPdSnPCummulativeDefaultRatesesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param keyFilter (optional) 
     * @param ratingFilter (optional) 
     * @param maxYearsFilter (optional) 
     * @param minYearsFilter (optional) 
     * @param maxValueFilter (optional) 
     * @param minValueFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, keyFilter: string | null | undefined, ratingFilter: string | null | undefined, maxYearsFilter: number | null | undefined, minYearsFilter: number | null | undefined, maxValueFilter: number | null | undefined, minValueFilter: number | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdSnPCummulativeDefaultRateses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (keyFilter !== undefined)
            url_ += "KeyFilter=" + encodeURIComponent("" + keyFilter) + "&"; 
        if (ratingFilter !== undefined)
            url_ += "RatingFilter=" + encodeURIComponent("" + ratingFilter) + "&"; 
        if (maxYearsFilter !== undefined)
            url_ += "MaxYearsFilter=" + encodeURIComponent("" + maxYearsFilter) + "&"; 
        if (minYearsFilter !== undefined)
            url_ += "MinYearsFilter=" + encodeURIComponent("" + minYearsFilter) + "&"; 
        if (maxValueFilter !== undefined)
            url_ += "MaxValueFilter=" + encodeURIComponent("" + maxValueFilter) + "&"; 
        if (minValueFilter !== undefined)
            url_ += "MinValueFilter=" + encodeURIComponent("" + minValueFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclPdSnPCummulativeDefaultRatesForEdit(id: string | null | undefined): Observable<GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdSnPCummulativeDefaultRateses/GetWholesaleEclPdSnPCummulativeDefaultRatesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclPdSnPCummulativeDefaultRatesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclPdSnPCummulativeDefaultRatesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclPdSnPCummulativeDefaultRatesForEdit(response: HttpResponseBase): Observable<GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput.fromJS(resultData200) : new GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdSnPCummulativeDefaultRateses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdSnPCummulativeDefaultRateses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclPdSnPCummulativeDefaultRateses/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclResultDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param contractIDFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param customerNoFilter (optional) 
     * @param segmentFilter (optional) 
     * @param productTypeFilter (optional) 
     * @param sectorFilter (optional) 
     * @param maxStageFilter (optional) 
     * @param minStageFilter (optional) 
     * @param maxOutstandingBalanceFilter (optional) 
     * @param minOutstandingBalanceFilter (optional) 
     * @param maxPreOverrideEclBestFilter (optional) 
     * @param minPreOverrideEclBestFilter (optional) 
     * @param maxPreOverrideEclOptimisticFilter (optional) 
     * @param minPreOverrideEclOptimisticFilter (optional) 
     * @param maxPreOverrideEclDownturnFilter (optional) 
     * @param minPreOverrideEclDownturnFilter (optional) 
     * @param maxOverrideStageFilter (optional) 
     * @param minOverrideStageFilter (optional) 
     * @param maxOverrideTTRYearsFilter (optional) 
     * @param minOverrideTTRYearsFilter (optional) 
     * @param maxOverrideFSVFilter (optional) 
     * @param minOverrideFSVFilter (optional) 
     * @param maxOverrideOverlayFilter (optional) 
     * @param minOverrideOverlayFilter (optional) 
     * @param maxPostOverrideEclBestFilter (optional) 
     * @param minPostOverrideEclBestFilter (optional) 
     * @param maxPostOverrideEclOptimisticFilter (optional) 
     * @param minPostOverrideEclOptimisticFilter (optional) 
     * @param maxPostOverrideEclDownturnFilter (optional) 
     * @param minPostOverrideEclDownturnFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param wholesaleEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, contractIDFilter: string | null | undefined, accountNoFilter: string | null | undefined, customerNoFilter: string | null | undefined, segmentFilter: string | null | undefined, productTypeFilter: string | null | undefined, sectorFilter: string | null | undefined, maxStageFilter: number | null | undefined, minStageFilter: number | null | undefined, maxOutstandingBalanceFilter: number | null | undefined, minOutstandingBalanceFilter: number | null | undefined, maxPreOverrideEclBestFilter: number | null | undefined, minPreOverrideEclBestFilter: number | null | undefined, maxPreOverrideEclOptimisticFilter: number | null | undefined, minPreOverrideEclOptimisticFilter: number | null | undefined, maxPreOverrideEclDownturnFilter: number | null | undefined, minPreOverrideEclDownturnFilter: number | null | undefined, maxOverrideStageFilter: number | null | undefined, minOverrideStageFilter: number | null | undefined, maxOverrideTTRYearsFilter: number | null | undefined, minOverrideTTRYearsFilter: number | null | undefined, maxOverrideFSVFilter: number | null | undefined, minOverrideFSVFilter: number | null | undefined, maxOverrideOverlayFilter: number | null | undefined, minOverrideOverlayFilter: number | null | undefined, maxPostOverrideEclBestFilter: number | null | undefined, minPostOverrideEclBestFilter: number | null | undefined, maxPostOverrideEclOptimisticFilter: number | null | undefined, minPostOverrideEclOptimisticFilter: number | null | undefined, maxPostOverrideEclDownturnFilter: number | null | undefined, minPostOverrideEclDownturnFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, wholesaleEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclResultDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (contractIDFilter !== undefined)
            url_ += "ContractIDFilter=" + encodeURIComponent("" + contractIDFilter) + "&"; 
        if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&"; 
        if (customerNoFilter !== undefined)
            url_ += "CustomerNoFilter=" + encodeURIComponent("" + customerNoFilter) + "&"; 
        if (segmentFilter !== undefined)
            url_ += "SegmentFilter=" + encodeURIComponent("" + segmentFilter) + "&"; 
        if (productTypeFilter !== undefined)
            url_ += "ProductTypeFilter=" + encodeURIComponent("" + productTypeFilter) + "&"; 
        if (sectorFilter !== undefined)
            url_ += "SectorFilter=" + encodeURIComponent("" + sectorFilter) + "&"; 
        if (maxStageFilter !== undefined)
            url_ += "MaxStageFilter=" + encodeURIComponent("" + maxStageFilter) + "&"; 
        if (minStageFilter !== undefined)
            url_ += "MinStageFilter=" + encodeURIComponent("" + minStageFilter) + "&"; 
        if (maxOutstandingBalanceFilter !== undefined)
            url_ += "MaxOutstandingBalanceFilter=" + encodeURIComponent("" + maxOutstandingBalanceFilter) + "&"; 
        if (minOutstandingBalanceFilter !== undefined)
            url_ += "MinOutstandingBalanceFilter=" + encodeURIComponent("" + minOutstandingBalanceFilter) + "&"; 
        if (maxPreOverrideEclBestFilter !== undefined)
            url_ += "MaxPreOverrideEclBestFilter=" + encodeURIComponent("" + maxPreOverrideEclBestFilter) + "&"; 
        if (minPreOverrideEclBestFilter !== undefined)
            url_ += "MinPreOverrideEclBestFilter=" + encodeURIComponent("" + minPreOverrideEclBestFilter) + "&"; 
        if (maxPreOverrideEclOptimisticFilter !== undefined)
            url_ += "MaxPreOverrideEclOptimisticFilter=" + encodeURIComponent("" + maxPreOverrideEclOptimisticFilter) + "&"; 
        if (minPreOverrideEclOptimisticFilter !== undefined)
            url_ += "MinPreOverrideEclOptimisticFilter=" + encodeURIComponent("" + minPreOverrideEclOptimisticFilter) + "&"; 
        if (maxPreOverrideEclDownturnFilter !== undefined)
            url_ += "MaxPreOverrideEclDownturnFilter=" + encodeURIComponent("" + maxPreOverrideEclDownturnFilter) + "&"; 
        if (minPreOverrideEclDownturnFilter !== undefined)
            url_ += "MinPreOverrideEclDownturnFilter=" + encodeURIComponent("" + minPreOverrideEclDownturnFilter) + "&"; 
        if (maxOverrideStageFilter !== undefined)
            url_ += "MaxOverrideStageFilter=" + encodeURIComponent("" + maxOverrideStageFilter) + "&"; 
        if (minOverrideStageFilter !== undefined)
            url_ += "MinOverrideStageFilter=" + encodeURIComponent("" + minOverrideStageFilter) + "&"; 
        if (maxOverrideTTRYearsFilter !== undefined)
            url_ += "MaxOverrideTTRYearsFilter=" + encodeURIComponent("" + maxOverrideTTRYearsFilter) + "&"; 
        if (minOverrideTTRYearsFilter !== undefined)
            url_ += "MinOverrideTTRYearsFilter=" + encodeURIComponent("" + minOverrideTTRYearsFilter) + "&"; 
        if (maxOverrideFSVFilter !== undefined)
            url_ += "MaxOverrideFSVFilter=" + encodeURIComponent("" + maxOverrideFSVFilter) + "&"; 
        if (minOverrideFSVFilter !== undefined)
            url_ += "MinOverrideFSVFilter=" + encodeURIComponent("" + minOverrideFSVFilter) + "&"; 
        if (maxOverrideOverlayFilter !== undefined)
            url_ += "MaxOverrideOverlayFilter=" + encodeURIComponent("" + maxOverrideOverlayFilter) + "&"; 
        if (minOverrideOverlayFilter !== undefined)
            url_ += "MinOverrideOverlayFilter=" + encodeURIComponent("" + minOverrideOverlayFilter) + "&"; 
        if (maxPostOverrideEclBestFilter !== undefined)
            url_ += "MaxPostOverrideEclBestFilter=" + encodeURIComponent("" + maxPostOverrideEclBestFilter) + "&"; 
        if (minPostOverrideEclBestFilter !== undefined)
            url_ += "MinPostOverrideEclBestFilter=" + encodeURIComponent("" + minPostOverrideEclBestFilter) + "&"; 
        if (maxPostOverrideEclOptimisticFilter !== undefined)
            url_ += "MaxPostOverrideEclOptimisticFilter=" + encodeURIComponent("" + maxPostOverrideEclOptimisticFilter) + "&"; 
        if (minPostOverrideEclOptimisticFilter !== undefined)
            url_ += "MinPostOverrideEclOptimisticFilter=" + encodeURIComponent("" + minPostOverrideEclOptimisticFilter) + "&"; 
        if (maxPostOverrideEclDownturnFilter !== undefined)
            url_ += "MaxPostOverrideEclDownturnFilter=" + encodeURIComponent("" + maxPostOverrideEclDownturnFilter) + "&"; 
        if (minPostOverrideEclDownturnFilter !== undefined)
            url_ += "MinPostOverrideEclDownturnFilter=" + encodeURIComponent("" + minPostOverrideEclDownturnFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (wholesaleEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "WholesaleEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + wholesaleEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclResultDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclResultDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclResultDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclResultDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclResultDetailForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclResultDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclResultDetailForEdit(id: string | null | undefined): Observable<GetWholesaleEclResultDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultDetails/GetWholesaleEclResultDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclResultDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclResultDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclResultDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclResultDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclResultDetailForEdit(response: HttpResponseBase): Observable<GetWholesaleEclResultDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclResultDetailForEditOutput.fromJS(resultData200) : new GetWholesaleEclResultDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclResultDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclResultDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultDetails/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultDetails/GetAllWholesaleEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclResultSummariesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param summaryTypeFilter (optional) 
     * @param titleFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, summaryTypeFilter: number | null | undefined, titleFilter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaries/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (summaryTypeFilter !== undefined)
            url_ += "SummaryTypeFilter=" + encodeURIComponent("" + summaryTypeFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclResultSummaryForEdit(id: string | null | undefined): Observable<GetWholesaleEclResultSummaryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaries/GetWholesaleEclResultSummaryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclResultSummaryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclResultSummaryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclResultSummaryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclResultSummaryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclResultSummaryForEdit(response: HttpResponseBase): Observable<GetWholesaleEclResultSummaryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclResultSummaryForEditOutput.fromJS(resultData200) : new GetWholesaleEclResultSummaryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclResultSummaryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclResultSummaryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaries/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaries/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclResultSummaryKeyInputsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param pDGroupingFilter (optional) 
     * @param maxExposureFilter (optional) 
     * @param minExposureFilter (optional) 
     * @param maxCollateralFilter (optional) 
     * @param minCollateralFilter (optional) 
     * @param maxUnsecuredPercentageFilter (optional) 
     * @param minUnsecuredPercentageFilter (optional) 
     * @param maxPercentageOfBookFilter (optional) 
     * @param minPercentageOfBookFilter (optional) 
     * @param maxMonths6CummulativeBestPDsFilter (optional) 
     * @param minMonths6CummulativeBestPDsFilter (optional) 
     * @param maxMonths12CummulativeBestPDsFilter (optional) 
     * @param minMonths12CummulativeBestPDsFilter (optional) 
     * @param maxMonths24CummulativeBestPDsFilter (optional) 
     * @param minMonths24CummulativeBestPDsFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, pDGroupingFilter: string | null | undefined, maxExposureFilter: number | null | undefined, minExposureFilter: number | null | undefined, maxCollateralFilter: number | null | undefined, minCollateralFilter: number | null | undefined, maxUnsecuredPercentageFilter: number | null | undefined, minUnsecuredPercentageFilter: number | null | undefined, maxPercentageOfBookFilter: number | null | undefined, minPercentageOfBookFilter: number | null | undefined, maxMonths6CummulativeBestPDsFilter: number | null | undefined, minMonths6CummulativeBestPDsFilter: number | null | undefined, maxMonths12CummulativeBestPDsFilter: number | null | undefined, minMonths12CummulativeBestPDsFilter: number | null | undefined, maxMonths24CummulativeBestPDsFilter: number | null | undefined, minMonths24CummulativeBestPDsFilter: number | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryKeyInputs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (pDGroupingFilter !== undefined)
            url_ += "PDGroupingFilter=" + encodeURIComponent("" + pDGroupingFilter) + "&"; 
        if (maxExposureFilter !== undefined)
            url_ += "MaxExposureFilter=" + encodeURIComponent("" + maxExposureFilter) + "&"; 
        if (minExposureFilter !== undefined)
            url_ += "MinExposureFilter=" + encodeURIComponent("" + minExposureFilter) + "&"; 
        if (maxCollateralFilter !== undefined)
            url_ += "MaxCollateralFilter=" + encodeURIComponent("" + maxCollateralFilter) + "&"; 
        if (minCollateralFilter !== undefined)
            url_ += "MinCollateralFilter=" + encodeURIComponent("" + minCollateralFilter) + "&"; 
        if (maxUnsecuredPercentageFilter !== undefined)
            url_ += "MaxUnsecuredPercentageFilter=" + encodeURIComponent("" + maxUnsecuredPercentageFilter) + "&"; 
        if (minUnsecuredPercentageFilter !== undefined)
            url_ += "MinUnsecuredPercentageFilter=" + encodeURIComponent("" + minUnsecuredPercentageFilter) + "&"; 
        if (maxPercentageOfBookFilter !== undefined)
            url_ += "MaxPercentageOfBookFilter=" + encodeURIComponent("" + maxPercentageOfBookFilter) + "&"; 
        if (minPercentageOfBookFilter !== undefined)
            url_ += "MinPercentageOfBookFilter=" + encodeURIComponent("" + minPercentageOfBookFilter) + "&"; 
        if (maxMonths6CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths6CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths6CummulativeBestPDsFilter) + "&"; 
        if (minMonths6CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths6CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths6CummulativeBestPDsFilter) + "&"; 
        if (maxMonths12CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths12CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths12CummulativeBestPDsFilter) + "&"; 
        if (minMonths12CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths12CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths12CummulativeBestPDsFilter) + "&"; 
        if (maxMonths24CummulativeBestPDsFilter !== undefined)
            url_ += "MaxMonths24CummulativeBestPDsFilter=" + encodeURIComponent("" + maxMonths24CummulativeBestPDsFilter) + "&"; 
        if (minMonths24CummulativeBestPDsFilter !== undefined)
            url_ += "MinMonths24CummulativeBestPDsFilter=" + encodeURIComponent("" + minMonths24CummulativeBestPDsFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclResultSummaryKeyInputForEdit(id: string | null | undefined): Observable<GetWholesaleEclResultSummaryKeyInputForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryKeyInputs/GetWholesaleEclResultSummaryKeyInputForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclResultSummaryKeyInputForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclResultSummaryKeyInputForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclResultSummaryKeyInputForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclResultSummaryKeyInputForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclResultSummaryKeyInputForEdit(response: HttpResponseBase): Observable<GetWholesaleEclResultSummaryKeyInputForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclResultSummaryKeyInputForEditOutput.fromJS(resultData200) : new GetWholesaleEclResultSummaryKeyInputForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclResultSummaryKeyInputForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclResultSummaryKeyInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryKeyInputs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryKeyInputs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryKeyInputs/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclResultSummaryTopExposuresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPreOverrideExposureFilter (optional) 
     * @param minPreOverrideExposureFilter (optional) 
     * @param maxPreOverrideImpairmentFilter (optional) 
     * @param minPreOverrideImpairmentFilter (optional) 
     * @param maxPreOverrideCoverageRatioFilter (optional) 
     * @param minPreOverrideCoverageRatioFilter (optional) 
     * @param maxPostOverrideExposureFilter (optional) 
     * @param minPostOverrideExposureFilter (optional) 
     * @param maxPostOverrideImpairmentFilter (optional) 
     * @param minPostOverrideImpairmentFilter (optional) 
     * @param maxPostOverrideCoverageRatioFilter (optional) 
     * @param minPostOverrideCoverageRatioFilter (optional) 
     * @param contractIdFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param wholesaleEclDataLoanBookCustomerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxPreOverrideExposureFilter: number | null | undefined, minPreOverrideExposureFilter: number | null | undefined, maxPreOverrideImpairmentFilter: number | null | undefined, minPreOverrideImpairmentFilter: number | null | undefined, maxPreOverrideCoverageRatioFilter: number | null | undefined, minPreOverrideCoverageRatioFilter: number | null | undefined, maxPostOverrideExposureFilter: number | null | undefined, minPostOverrideExposureFilter: number | null | undefined, maxPostOverrideImpairmentFilter: number | null | undefined, minPostOverrideImpairmentFilter: number | null | undefined, maxPostOverrideCoverageRatioFilter: number | null | undefined, minPostOverrideCoverageRatioFilter: number | null | undefined, contractIdFilter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, wholesaleEclDataLoanBookCustomerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryTopExposures/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPreOverrideExposureFilter !== undefined)
            url_ += "MaxPreOverrideExposureFilter=" + encodeURIComponent("" + maxPreOverrideExposureFilter) + "&"; 
        if (minPreOverrideExposureFilter !== undefined)
            url_ += "MinPreOverrideExposureFilter=" + encodeURIComponent("" + minPreOverrideExposureFilter) + "&"; 
        if (maxPreOverrideImpairmentFilter !== undefined)
            url_ += "MaxPreOverrideImpairmentFilter=" + encodeURIComponent("" + maxPreOverrideImpairmentFilter) + "&"; 
        if (minPreOverrideImpairmentFilter !== undefined)
            url_ += "MinPreOverrideImpairmentFilter=" + encodeURIComponent("" + minPreOverrideImpairmentFilter) + "&"; 
        if (maxPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPreOverrideCoverageRatioFilter) + "&"; 
        if (minPreOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPreOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPreOverrideCoverageRatioFilter) + "&"; 
        if (maxPostOverrideExposureFilter !== undefined)
            url_ += "MaxPostOverrideExposureFilter=" + encodeURIComponent("" + maxPostOverrideExposureFilter) + "&"; 
        if (minPostOverrideExposureFilter !== undefined)
            url_ += "MinPostOverrideExposureFilter=" + encodeURIComponent("" + minPostOverrideExposureFilter) + "&"; 
        if (maxPostOverrideImpairmentFilter !== undefined)
            url_ += "MaxPostOverrideImpairmentFilter=" + encodeURIComponent("" + maxPostOverrideImpairmentFilter) + "&"; 
        if (minPostOverrideImpairmentFilter !== undefined)
            url_ += "MinPostOverrideImpairmentFilter=" + encodeURIComponent("" + minPostOverrideImpairmentFilter) + "&"; 
        if (maxPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MaxPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + maxPostOverrideCoverageRatioFilter) + "&"; 
        if (minPostOverrideCoverageRatioFilter !== undefined)
            url_ += "MinPostOverrideCoverageRatioFilter=" + encodeURIComponent("" + minPostOverrideCoverageRatioFilter) + "&"; 
        if (contractIdFilter !== undefined)
            url_ += "ContractIdFilter=" + encodeURIComponent("" + contractIdFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (wholesaleEclDataLoanBookCustomerNameFilter !== undefined)
            url_ += "WholesaleEclDataLoanBookCustomerNameFilter=" + encodeURIComponent("" + wholesaleEclDataLoanBookCustomerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclResultSummaryTopExposureForEdit(id: string | null | undefined): Observable<GetWholesaleEclResultSummaryTopExposureForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryTopExposures/GetWholesaleEclResultSummaryTopExposureForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclResultSummaryTopExposureForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclResultSummaryTopExposureForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclResultSummaryTopExposureForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclResultSummaryTopExposureForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclResultSummaryTopExposureForEdit(response: HttpResponseBase): Observable<GetWholesaleEclResultSummaryTopExposureForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclResultSummaryTopExposureForEditOutput.fromJS(resultData200) : new GetWholesaleEclResultSummaryTopExposureForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclResultSummaryTopExposureForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclResultSummaryTopExposureDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryTopExposures/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryTopExposures/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryTopExposures/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclResultSummaryTopExposures/GetAllWholesaleEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReportingDateFilter (optional) 
     * @param minReportingDateFilter (optional) 
     * @param maxClosedDateFilter (optional) 
     * @param minClosedDateFilter (optional) 
     * @param isApprovedFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReportingDateFilter: moment.Moment | null | undefined, minReportingDateFilter: moment.Moment | null | undefined, maxClosedDateFilter: moment.Moment | null | undefined, minClosedDateFilter: moment.Moment | null | undefined, isApprovedFilter: number | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEcls/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReportingDateFilter !== undefined)
            url_ += "MaxReportingDateFilter=" + encodeURIComponent(maxReportingDateFilter ? "" + maxReportingDateFilter.toJSON() : "") + "&"; 
        if (minReportingDateFilter !== undefined)
            url_ += "MinReportingDateFilter=" + encodeURIComponent(minReportingDateFilter ? "" + minReportingDateFilter.toJSON() : "") + "&"; 
        if (maxClosedDateFilter !== undefined)
            url_ += "MaxClosedDateFilter=" + encodeURIComponent(maxClosedDateFilter ? "" + maxClosedDateFilter.toJSON() : "") + "&"; 
        if (minClosedDateFilter !== undefined)
            url_ += "MinClosedDateFilter=" + encodeURIComponent(minClosedDateFilter ? "" + minClosedDateFilter.toJSON() : "") + "&"; 
        if (isApprovedFilter !== undefined)
            url_ += "IsApprovedFilter=" + encodeURIComponent("" + isApprovedFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclForEdit(id: string | null | undefined): Observable<GetWholesaleEclForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEcls/GetWholesaleEclForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclForEdit(response: HttpResponseBase): Observable<GetWholesaleEclForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclForEditOutput.fromJS(resultData200) : new GetWholesaleEclForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEcls/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEcls/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEcls/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclUserLookupTableDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    runEcl(input: EntityDtoOfGuid | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEcls/RunEcl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunEcl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunEcl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRunEcl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class WholesaleEclSicrApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param userNameFilter (optional) 
     * @param wholesaleEclSicrOverrideCommentFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, userNameFilter: string | null | undefined, wholesaleEclSicrOverrideCommentFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (wholesaleEclSicrOverrideCommentFilter !== undefined)
            url_ += "WholesaleEclSicrOverrideCommentFilter=" + encodeURIComponent("" + wholesaleEclSicrOverrideCommentFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclSicrApprovalForEdit(id: string | null | undefined): Observable<GetWholesaleEclSicrApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrApprovals/GetWholesaleEclSicrApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclSicrApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclSicrApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclSicrApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclSicrApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclSicrApprovalForEdit(response: HttpResponseBase): Observable<GetWholesaleEclSicrApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclSicrApprovalForEditOutput.fromJS(resultData200) : new GetWholesaleEclSicrApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclSicrApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclSicrApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclSicrForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrApprovals/GetAllWholesaleEclSicrForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclSicrForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclSicrForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclSicrForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclSicrsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxComputedSICRFilter (optional) 
     * @param minComputedSICRFilter (optional) 
     * @param overrideSICRFilter (optional) 
     * @param overrideCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param wholesaleEclDataLoanBookContractNoFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxComputedSICRFilter: number | null | undefined, minComputedSICRFilter: number | null | undefined, overrideSICRFilter: string | null | undefined, overrideCommentFilter: string | null | undefined, statusFilter: number | null | undefined, wholesaleEclDataLoanBookContractNoFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclSicrForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxComputedSICRFilter !== undefined)
            url_ += "MaxComputedSICRFilter=" + encodeURIComponent("" + maxComputedSICRFilter) + "&"; 
        if (minComputedSICRFilter !== undefined)
            url_ += "MinComputedSICRFilter=" + encodeURIComponent("" + minComputedSICRFilter) + "&"; 
        if (overrideSICRFilter !== undefined)
            url_ += "OverrideSICRFilter=" + encodeURIComponent("" + overrideSICRFilter) + "&"; 
        if (overrideCommentFilter !== undefined)
            url_ += "OverrideCommentFilter=" + encodeURIComponent("" + overrideCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (wholesaleEclDataLoanBookContractNoFilter !== undefined)
            url_ += "WholesaleEclDataLoanBookContractNoFilter=" + encodeURIComponent("" + wholesaleEclDataLoanBookContractNoFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclSicrForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclSicrForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclSicrForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclSicrForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclSicrForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclSicrForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclSicrForEdit(id: string | null | undefined): Observable<GetWholesaleEclSicrForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrs/GetWholesaleEclSicrForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclSicrForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclSicrForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclSicrForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclSicrForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclSicrForEdit(response: HttpResponseBase): Observable<GetWholesaleEclSicrForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclSicrForEditOutput.fromJS(resultData200) : new GetWholesaleEclSicrForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclSicrForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclSicrDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclDataLoanBookForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclSicrs/GetAllWholesaleEclDataLoanBookForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclDataLoanBookForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclDataLoanBookForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclDataLoanBookForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclUploadApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxReviewedDateFilter (optional) 
     * @param minReviewedDateFilter (optional) 
     * @param reviewCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param wholesaleEclUploadUploadCommentFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxReviewedDateFilter: moment.Moment | null | undefined, minReviewedDateFilter: moment.Moment | null | undefined, reviewCommentFilter: string | null | undefined, statusFilter: number | null | undefined, wholesaleEclUploadUploadCommentFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploadApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxReviewedDateFilter !== undefined)
            url_ += "MaxReviewedDateFilter=" + encodeURIComponent(maxReviewedDateFilter ? "" + maxReviewedDateFilter.toJSON() : "") + "&"; 
        if (minReviewedDateFilter !== undefined)
            url_ += "MinReviewedDateFilter=" + encodeURIComponent(minReviewedDateFilter ? "" + minReviewedDateFilter.toJSON() : "") + "&"; 
        if (reviewCommentFilter !== undefined)
            url_ += "ReviewCommentFilter=" + encodeURIComponent("" + reviewCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (wholesaleEclUploadUploadCommentFilter !== undefined)
            url_ += "WholesaleEclUploadUploadCommentFilter=" + encodeURIComponent("" + wholesaleEclUploadUploadCommentFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclUploadApprovalForEdit(id: string | null | undefined): Observable<GetWholesaleEclUploadApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploadApprovals/GetWholesaleEclUploadApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclUploadApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclUploadApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclUploadApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclUploadApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclUploadApprovalForEdit(response: HttpResponseBase): Observable<GetWholesaleEclUploadApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclUploadApprovalForEditOutput.fromJS(resultData200) : new GetWholesaleEclUploadApprovalForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclUploadApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclUploadApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploadApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploadApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclUploadForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploadApprovals/GetAllWholesaleEclUploadForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclUploadForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclUploadForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclUploadForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploadApprovals/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesaleEclUploadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param docTypeFilter (optional) 
     * @param uploadCommentFilter (optional) 
     * @param statusFilter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, docTypeFilter: number | null | undefined, uploadCommentFilter: string | null | undefined, statusFilter: number | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesaleEclUploadForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploads/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (docTypeFilter !== undefined)
            url_ += "DocTypeFilter=" + encodeURIComponent("" + docTypeFilter) + "&"; 
        if (uploadCommentFilter !== undefined)
            url_ += "UploadCommentFilter=" + encodeURIComponent("" + uploadCommentFilter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesaleEclUploadForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesaleEclUploadForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesaleEclUploadForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesaleEclUploadForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesaleEclUploadForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesaleEclUploadForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesaleEclUploadForEdit(id: string | null | undefined): Observable<GetWholesaleEclUploadForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploads/GetWholesaleEclUploadForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesaleEclUploadForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesaleEclUploadForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesaleEclUploadForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesaleEclUploadForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesaleEclUploadForEdit(response: HttpResponseBase): Observable<GetWholesaleEclUploadForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesaleEclUploadForEditOutput.fromJS(resultData200) : new GetWholesaleEclUploadForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesaleEclUploadForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesaleEclUploadDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploads/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploads/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesaleEclUploads/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WholesalePdAssumptionNonInternalModelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param wholesaleEclTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, wholesaleEclTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesalePdAssumptionNonInternalModels/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (wholesaleEclTenantIdFilter !== undefined)
            url_ += "WholesaleEclTenantIdFilter=" + encodeURIComponent("" + wholesaleEclTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWholesalePdAssumptionNonInternalModelForEdit(id: string | null | undefined): Observable<GetWholesalePdAssumptionNonInternalModelForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WholesalePdAssumptionNonInternalModels/GetWholesalePdAssumptionNonInternalModelForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWholesalePdAssumptionNonInternalModelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWholesalePdAssumptionNonInternalModelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWholesalePdAssumptionNonInternalModelForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWholesalePdAssumptionNonInternalModelForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWholesalePdAssumptionNonInternalModelForEdit(response: HttpResponseBase): Observable<GetWholesalePdAssumptionNonInternalModelForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWholesalePdAssumptionNonInternalModelForEditOutput.fromJS(resultData200) : new GetWholesalePdAssumptionNonInternalModelForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWholesalePdAssumptionNonInternalModelForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWholesalePdAssumptionNonInternalModelDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesalePdAssumptionNonInternalModels/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WholesalePdAssumptionNonInternalModels/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWholesaleEclForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WholesalePdAssumptionNonInternalModels/GetAllWholesaleEclForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWholesaleEclForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWholesaleEclForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWholesaleEclForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1, 
    InActive = 2, 
    NotFound = 3, 
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class PagedResultDtoOfGetAssumptionForViewDto implements IPagedResultDtoOfGetAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetAssumptionForViewDto[] | undefined;
}

export class GetAssumptionForViewDto implements IGetAssumptionForViewDto {
    assumption!: AssumptionDto | undefined;

    constructor(data?: IGetAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumption = data["assumption"] ? AssumptionDto.fromJS(data["assumption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumption"] = this.assumption ? this.assumption.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssumptionForViewDto {
    assumption: AssumptionDto | undefined;
}

export class AssumptionDto implements IAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.assumptionGroup = data["assumptionGroup"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["assumptionGroup"] = this.assumptionGroup;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    assumptionGroup: AssumptionGroupEnum | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export enum DataTypeEnum {
    String = 1, 
    Datetime = 2, 
    Double = 3, 
    Int = 4, 
    DoublePercentage = 5, 
    DoubleMoney = 6, 
    StringDropdown = 7, 
    DoubleDropDown = 8, 
    IntDropdown = 9, 
}

export enum AssumptionGroupEnum {
    General = 0, 
    ScenarioInputs = 1, 
    AbsoluteCreditQuality = 2, 
    RelativeCreditQuality = 3, 
    ForwardTransitions = 4, 
    BackwardTransitions = 5, 
    CreditRatingRank = 6, 
}

export enum GeneralStatusEnum {
    Draft = 0, 
    Submitted = 1, 
    Approved = 2, 
    Rejected = 3, 
}

export class GetAssumptionForEditOutput implements IGetAssumptionForEditOutput {
    assumption!: CreateOrEditAssumptionDto | undefined;

    constructor(data?: IGetAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumption = data["assumption"] ? CreateOrEditAssumptionDto.fromJS(data["assumption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumption"] = this.assumption ? this.assumption.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssumptionForEditOutput {
    assumption: CreateOrEditAssumptionDto | undefined;
}

export class CreateOrEditAssumptionDto implements ICreateOrEditAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.assumptionGroup = data["assumptionGroup"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["assumptionGroup"] = this.assumptionGroup;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    assumptionGroup: AssumptionGroupEnum | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = 0, 
    Updated = 1, 
    Deleted = 2, 
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [] as any;
                for (let item of data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export enum FriendshipState {
    Accepted = 1, 
    Blocked = 2, 
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export enum ChatSide {
    Sender = 1, 
    Receiver = 2, 
}

export enum ChatMessageReadState {
    Unread = 1, 
    Read = 2, 
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class PagedResultDtoOfGetEadInputAssumptionForViewDto implements IPagedResultDtoOfGetEadInputAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetEadInputAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEadInputAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEadInputAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetEadInputAssumptionForViewDto[] | undefined;
}

export class GetEadInputAssumptionForViewDto implements IGetEadInputAssumptionForViewDto {
    eadInputAssumption!: EadInputAssumptionDto | undefined;

    constructor(data?: IGetEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eadInputAssumption = data["eadInputAssumption"] ? EadInputAssumptionDto.fromJS(data["eadInputAssumption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eadInputAssumption"] = this.eadInputAssumption ? this.eadInputAssumption.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEadInputAssumptionForViewDto {
    eadInputAssumption: EadInputAssumptionDto | undefined;
}

export class EadInputAssumptionDto implements IEadInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    assumptionGroup!: EadInputAssumptionGroupEnum | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.assumptionGroup = data["assumptionGroup"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["assumptionGroup"] = this.assumptionGroup;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEadInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    assumptionGroup: EadInputAssumptionGroupEnum | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export enum EadInputAssumptionGroupEnum {
    General = 0, 
    CreditConversionFactors = 1, 
    VariableInterestRateProjections = 2, 
    ExchangeRateProjections = 3, 
    BehaviouralLife = 4, 
}

export class GetEadInputAssumptionForEditOutput implements IGetEadInputAssumptionForEditOutput {
    eadInputAssumption!: CreateOrEditEadInputAssumptionDto | undefined;

    constructor(data?: IGetEadInputAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eadInputAssumption = data["eadInputAssumption"] ? CreateOrEditEadInputAssumptionDto.fromJS(data["eadInputAssumption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEadInputAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEadInputAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eadInputAssumption"] = this.eadInputAssumption ? this.eadInputAssumption.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEadInputAssumptionForEditOutput {
    eadInputAssumption: CreateOrEditEadInputAssumptionDto | undefined;
}

export class CreateOrEditEadInputAssumptionDto implements ICreateOrEditEadInputAssumptionDto {
    inputName!: string | undefined;
    value!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEadInputAssumptionDto {
    inputName: string | undefined;
    value: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetAllEclForWorkspaceDto implements IPagedResultDtoOfGetAllEclForWorkspaceDto {
    totalCount!: number | undefined;
    items!: GetAllEclForWorkspaceDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllEclForWorkspaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAllEclForWorkspaceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllEclForWorkspaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllEclForWorkspaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAllEclForWorkspaceDto {
    totalCount: number | undefined;
    items: GetAllEclForWorkspaceDto[] | undefined;
}

export class GetAllEclForWorkspaceDto implements IGetAllEclForWorkspaceDto {
    framework!: FrameworkEnum | undefined;
    reportingDate!: moment.Moment | undefined;
    status!: EclStatusEnum | undefined;
    organisationUnitName!: string | undefined;
    createdByUserName!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: IGetAllEclForWorkspaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.framework = data["framework"];
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.organisationUnitName = data["organisationUnitName"];
            this.createdByUserName = data["createdByUserName"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetAllEclForWorkspaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEclForWorkspaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["framework"] = this.framework;
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["organisationUnitName"] = this.organisationUnitName;
        data["createdByUserName"] = this.createdByUserName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAllEclForWorkspaceDto {
    framework: FrameworkEnum | undefined;
    reportingDate: moment.Moment | undefined;
    status: EclStatusEnum | undefined;
    organisationUnitName: string | undefined;
    createdByUserName: string | undefined;
    dateCreated: moment.Moment | undefined;
    id: string | undefined;
}

export enum FrameworkEnum {
    All = 0, 
    Wholesale = 1, 
    Retail = 2, 
    OBE = 3, 
}

export enum EclStatusEnum {
    Draft = 0, 
    Submitted = 1, 
    Approved = 2, 
    Running = 3, 
    ComputedPD = 4, 
    ComputedSICR = 5, 
    ComputedEAD = 6, 
    ComputedLGD = 7, 
    ComputedECL = 8, 
    Completed = 9, 
    Closed = 10, 
}

export class LgdAssumptionDto implements ILgdAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    assumptionGroup!: LdgInputAssumptionGroupEnum | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: ILgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.assumptionGroup = data["assumptionGroup"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["assumptionGroup"] = this.assumptionGroup;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILgdAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    assumptionGroup: LdgInputAssumptionGroupEnum | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export enum LdgInputAssumptionGroupEnum {
    General = 0, 
    UnsecuredRecoveriesCureRate = 1, 
    UnsecuredRecoveriesTimeInDefault = 2, 
    CostOfRecoveryHigh = 3, 
    CostOfRecoveryLow = 4, 
    CollateralGrowthBest = 5, 
    CollateralGrowthOptimistic = 6, 
    CollateralGrowthDownturn = 7, 
    CollateralTTR = 8, 
    CollateralProjectionBest = 9, 
    CollateralProjectionOptimistic = 10, 
    CollateralProjectionDownturn = 11, 
    Haircut = 12, 
    PdAssumptions = 13, 
}

export class PagedResultDtoOfGetAllAffiliateAssumptionDto implements IPagedResultDtoOfGetAllAffiliateAssumptionDto {
    totalCount!: number | undefined;
    items!: GetAllAffiliateAssumptionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllAffiliateAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAllAffiliateAssumptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllAffiliateAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllAffiliateAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAllAffiliateAssumptionDto {
    totalCount: number | undefined;
    items: GetAllAffiliateAssumptionDto[] | undefined;
}

export class GetAllAffiliateAssumptionDto implements IGetAllAffiliateAssumptionDto {
    organizationUnitId!: number | undefined;
    affiliateName!: string | undefined;
    lastAssumptionUpdate!: moment.Moment | undefined;
    lastWholesaleReportingDate!: moment.Moment | undefined;
    lastRetailReportingDate!: moment.Moment | undefined;
    lastObeReportingDate!: moment.Moment | undefined;
    lastSecuritiesReportingDate!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: IGetAllAffiliateAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.affiliateName = data["affiliateName"];
            this.lastAssumptionUpdate = data["lastAssumptionUpdate"] ? moment(data["lastAssumptionUpdate"].toString()) : <any>undefined;
            this.lastWholesaleReportingDate = data["lastWholesaleReportingDate"] ? moment(data["lastWholesaleReportingDate"].toString()) : <any>undefined;
            this.lastRetailReportingDate = data["lastRetailReportingDate"] ? moment(data["lastRetailReportingDate"].toString()) : <any>undefined;
            this.lastObeReportingDate = data["lastObeReportingDate"] ? moment(data["lastObeReportingDate"].toString()) : <any>undefined;
            this.lastSecuritiesReportingDate = data["lastSecuritiesReportingDate"] ? moment(data["lastSecuritiesReportingDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetAllAffiliateAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAffiliateAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["affiliateName"] = this.affiliateName;
        data["lastAssumptionUpdate"] = this.lastAssumptionUpdate ? this.lastAssumptionUpdate.toISOString() : <any>undefined;
        data["lastWholesaleReportingDate"] = this.lastWholesaleReportingDate ? this.lastWholesaleReportingDate.toISOString() : <any>undefined;
        data["lastRetailReportingDate"] = this.lastRetailReportingDate ? this.lastRetailReportingDate.toISOString() : <any>undefined;
        data["lastObeReportingDate"] = this.lastObeReportingDate ? this.lastObeReportingDate.toISOString() : <any>undefined;
        data["lastSecuritiesReportingDate"] = this.lastSecuritiesReportingDate ? this.lastSecuritiesReportingDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAllAffiliateAssumptionDto {
    organizationUnitId: number | undefined;
    affiliateName: string | undefined;
    lastAssumptionUpdate: moment.Moment | undefined;
    lastWholesaleReportingDate: moment.Moment | undefined;
    lastRetailReportingDate: moment.Moment | undefined;
    lastObeReportingDate: moment.Moment | undefined;
    lastSecuritiesReportingDate: moment.Moment | undefined;
    id: string | undefined;
}

export class PdInputAssumptionDto implements IPdInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    assumptionGroup!: PdInputAssumptionGroupEnum | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.assumptionGroup = data["assumptionGroup"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["assumptionGroup"] = this.assumptionGroup;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    assumptionGroup: PdInputAssumptionGroupEnum | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export enum PdInputAssumptionGroupEnum {
    General = 0, 
    CreditPD = 1, 
    CreditEtiPolicy = 2, 
    CreditBestFit = 3, 
    StatisticsIndexWeights = 4, 
}

export class PdInputAssumptionMacroeconomicInputDto implements IPdInputAssumptionMacroeconomicInputDto {
    key!: string | undefined;
    inputName!: string | undefined;
    macroeconomicVariable!: string | undefined;
    value!: number | undefined;
    assumptionGroup!: number | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputAssumptionMacroeconomicInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.macroeconomicVariable = data["macroeconomicVariable"];
            this.value = data["value"];
            this.assumptionGroup = data["assumptionGroup"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputAssumptionMacroeconomicInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputAssumptionMacroeconomicInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["macroeconomicVariable"] = this.macroeconomicVariable;
        data["value"] = this.value;
        data["assumptionGroup"] = this.assumptionGroup;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputAssumptionMacroeconomicInputDto {
    key: string | undefined;
    inputName: string | undefined;
    macroeconomicVariable: string | undefined;
    value: number | undefined;
    assumptionGroup: number | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export class PdInputAssumptionMacroeconomicProjectionDto implements IPdInputAssumptionMacroeconomicProjectionDto {
    key!: string | undefined;
    date!: moment.Moment | undefined;
    inputName!: string | undefined;
    bestValue!: number | undefined;
    optimisticValue!: number | undefined;
    downturnValue!: number | undefined;
    assumptionGroup!: number | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.inputName = data["inputName"];
            this.bestValue = data["bestValue"];
            this.optimisticValue = data["optimisticValue"];
            this.downturnValue = data["downturnValue"];
            this.assumptionGroup = data["assumptionGroup"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["inputName"] = this.inputName;
        data["bestValue"] = this.bestValue;
        data["optimisticValue"] = this.optimisticValue;
        data["downturnValue"] = this.downturnValue;
        data["assumptionGroup"] = this.assumptionGroup;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputAssumptionMacroeconomicProjectionDto {
    key: string | undefined;
    date: moment.Moment | undefined;
    inputName: string | undefined;
    bestValue: number | undefined;
    optimisticValue: number | undefined;
    downturnValue: number | undefined;
    assumptionGroup: number | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export class PdInputAssumptionNonInternalModelDto implements IPdInputAssumptionNonInternalModelDto {
    key!: string | undefined;
    month!: number | undefined;
    pdGroup!: string | undefined;
    marginalDefaultRate!: number | undefined;
    cummulativeSurvival!: number | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputAssumptionNonInternalModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.month = data["month"];
            this.pdGroup = data["pdGroup"];
            this.marginalDefaultRate = data["marginalDefaultRate"];
            this.cummulativeSurvival = data["cummulativeSurvival"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputAssumptionNonInternalModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputAssumptionNonInternalModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["month"] = this.month;
        data["pdGroup"] = this.pdGroup;
        data["marginalDefaultRate"] = this.marginalDefaultRate;
        data["cummulativeSurvival"] = this.cummulativeSurvival;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputAssumptionNonInternalModelDto {
    key: string | undefined;
    month: number | undefined;
    pdGroup: string | undefined;
    marginalDefaultRate: number | undefined;
    cummulativeSurvival: number | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export class PdInputAssumptionNplIndexDto implements IPdInputAssumptionNplIndexDto {
    key!: string | undefined;
    date!: moment.Moment | undefined;
    actual!: number | undefined;
    standardised!: number | undefined;
    etiNplSeries!: number | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.actual = data["actual"];
            this.standardised = data["standardised"];
            this.etiNplSeries = data["etiNplSeries"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["actual"] = this.actual;
        data["standardised"] = this.standardised;
        data["etiNplSeries"] = this.etiNplSeries;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputAssumptionNplIndexDto {
    key: string | undefined;
    date: moment.Moment | undefined;
    actual: number | undefined;
    standardised: number | undefined;
    etiNplSeries: number | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export class PdInputSnPCummulativeDefaultRateDto implements IPdInputSnPCummulativeDefaultRateDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    isComputed!: boolean | undefined;
    requiresGroupApproval!: boolean | undefined;
    canAffiliateEdit!: boolean | undefined;
    organizationUnitId!: number | undefined;
    lastUpdated!: moment.Moment | undefined;
    lastUpdatedBy!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputSnPCummulativeDefaultRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.isComputed = data["isComputed"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.organizationUnitId = data["organizationUnitId"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.lastUpdatedBy = data["lastUpdatedBy"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputSnPCummulativeDefaultRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputSnPCummulativeDefaultRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["isComputed"] = this.isComputed;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["organizationUnitId"] = this.organizationUnitId;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputSnPCummulativeDefaultRateDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    isComputed: boolean | undefined;
    requiresGroupApproval: boolean | undefined;
    canAffiliateEdit: boolean | undefined;
    organizationUnitId: number | undefined;
    lastUpdated: moment.Moment | undefined;
    lastUpdatedBy: string | undefined;
    status: GeneralStatusEnum | undefined;
    id: string | undefined;
}

export class GetAllPdAssumptionsDto implements IGetAllPdAssumptionsDto {
    pdInputAssumption!: PdInputAssumptionDto[] | undefined;
    pdInputAssumptionMacroeconomicInput!: PdInputAssumptionMacroeconomicInputDto[] | undefined;
    pdInputAssumptionMacroeconomicProjections!: PdInputAssumptionMacroeconomicProjectionDto[] | undefined;
    pdInputAssumptionNonInternalModels!: PdInputAssumptionNonInternalModelDto[] | undefined;
    pdInputAssumptionNplIndex!: PdInputAssumptionNplIndexDto[] | undefined;
    pdInputSnPCummulativeDefaultRate!: PdInputSnPCummulativeDefaultRateDto[] | undefined;

    constructor(data?: IGetAllPdAssumptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["pdInputAssumption"] && data["pdInputAssumption"].constructor === Array) {
                this.pdInputAssumption = [] as any;
                for (let item of data["pdInputAssumption"])
                    this.pdInputAssumption!.push(PdInputAssumptionDto.fromJS(item));
            }
            if (data["pdInputAssumptionMacroeconomicInput"] && data["pdInputAssumptionMacroeconomicInput"].constructor === Array) {
                this.pdInputAssumptionMacroeconomicInput = [] as any;
                for (let item of data["pdInputAssumptionMacroeconomicInput"])
                    this.pdInputAssumptionMacroeconomicInput!.push(PdInputAssumptionMacroeconomicInputDto.fromJS(item));
            }
            if (data["pdInputAssumptionMacroeconomicProjections"] && data["pdInputAssumptionMacroeconomicProjections"].constructor === Array) {
                this.pdInputAssumptionMacroeconomicProjections = [] as any;
                for (let item of data["pdInputAssumptionMacroeconomicProjections"])
                    this.pdInputAssumptionMacroeconomicProjections!.push(PdInputAssumptionMacroeconomicProjectionDto.fromJS(item));
            }
            if (data["pdInputAssumptionNonInternalModels"] && data["pdInputAssumptionNonInternalModels"].constructor === Array) {
                this.pdInputAssumptionNonInternalModels = [] as any;
                for (let item of data["pdInputAssumptionNonInternalModels"])
                    this.pdInputAssumptionNonInternalModels!.push(PdInputAssumptionNonInternalModelDto.fromJS(item));
            }
            if (data["pdInputAssumptionNplIndex"] && data["pdInputAssumptionNplIndex"].constructor === Array) {
                this.pdInputAssumptionNplIndex = [] as any;
                for (let item of data["pdInputAssumptionNplIndex"])
                    this.pdInputAssumptionNplIndex!.push(PdInputAssumptionNplIndexDto.fromJS(item));
            }
            if (data["pdInputSnPCummulativeDefaultRate"] && data["pdInputSnPCummulativeDefaultRate"].constructor === Array) {
                this.pdInputSnPCummulativeDefaultRate = [] as any;
                for (let item of data["pdInputSnPCummulativeDefaultRate"])
                    this.pdInputSnPCummulativeDefaultRate!.push(PdInputSnPCummulativeDefaultRateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPdAssumptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPdAssumptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.pdInputAssumption && this.pdInputAssumption.constructor === Array) {
            data["pdInputAssumption"] = [];
            for (let item of this.pdInputAssumption)
                data["pdInputAssumption"].push(item.toJSON());
        }
        if (this.pdInputAssumptionMacroeconomicInput && this.pdInputAssumptionMacroeconomicInput.constructor === Array) {
            data["pdInputAssumptionMacroeconomicInput"] = [];
            for (let item of this.pdInputAssumptionMacroeconomicInput)
                data["pdInputAssumptionMacroeconomicInput"].push(item.toJSON());
        }
        if (this.pdInputAssumptionMacroeconomicProjections && this.pdInputAssumptionMacroeconomicProjections.constructor === Array) {
            data["pdInputAssumptionMacroeconomicProjections"] = [];
            for (let item of this.pdInputAssumptionMacroeconomicProjections)
                data["pdInputAssumptionMacroeconomicProjections"].push(item.toJSON());
        }
        if (this.pdInputAssumptionNonInternalModels && this.pdInputAssumptionNonInternalModels.constructor === Array) {
            data["pdInputAssumptionNonInternalModels"] = [];
            for (let item of this.pdInputAssumptionNonInternalModels)
                data["pdInputAssumptionNonInternalModels"].push(item.toJSON());
        }
        if (this.pdInputAssumptionNplIndex && this.pdInputAssumptionNplIndex.constructor === Array) {
            data["pdInputAssumptionNplIndex"] = [];
            for (let item of this.pdInputAssumptionNplIndex)
                data["pdInputAssumptionNplIndex"].push(item.toJSON());
        }
        if (this.pdInputSnPCummulativeDefaultRate && this.pdInputSnPCummulativeDefaultRate.constructor === Array) {
            data["pdInputSnPCummulativeDefaultRate"] = [];
            for (let item of this.pdInputSnPCummulativeDefaultRate)
                data["pdInputSnPCummulativeDefaultRate"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAllPdAssumptionsDto {
    pdInputAssumption: PdInputAssumptionDto[] | undefined;
    pdInputAssumptionMacroeconomicInput: PdInputAssumptionMacroeconomicInputDto[] | undefined;
    pdInputAssumptionMacroeconomicProjections: PdInputAssumptionMacroeconomicProjectionDto[] | undefined;
    pdInputAssumptionNonInternalModels: PdInputAssumptionNonInternalModelDto[] | undefined;
    pdInputAssumptionNplIndex: PdInputAssumptionNplIndexDto[] | undefined;
    pdInputSnPCummulativeDefaultRate: PdInputSnPCummulativeDefaultRateDto[] | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number | undefined;
    targetEditionId!: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export enum ChartDateInterval {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [] as any;
                for (let item of data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [] as any;
                for (let item of data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;
    otherSettings!: OtherSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto | undefined;
    billInfo!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment | undefined;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [] as any;
                for (let item of data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [] as any;
                for (let item of data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto implements IPagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto {
    totalCount!: number | undefined;
    items!: GetLgdAssumptionUnsecuredRecoveryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetLgdAssumptionUnsecuredRecoveryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetLgdAssumptionUnsecuredRecoveryForViewDto {
    totalCount: number | undefined;
    items: GetLgdAssumptionUnsecuredRecoveryForViewDto[] | undefined;
}

export class GetLgdAssumptionUnsecuredRecoveryForViewDto implements IGetLgdAssumptionUnsecuredRecoveryForViewDto {
    lgdAssumptionUnsecuredRecovery!: LgdAssumptionDto | undefined;

    constructor(data?: IGetLgdAssumptionUnsecuredRecoveryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lgdAssumptionUnsecuredRecovery = data["lgdAssumptionUnsecuredRecovery"] ? LgdAssumptionDto.fromJS(data["lgdAssumptionUnsecuredRecovery"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLgdAssumptionUnsecuredRecoveryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLgdAssumptionUnsecuredRecoveryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lgdAssumptionUnsecuredRecovery"] = this.lgdAssumptionUnsecuredRecovery ? this.lgdAssumptionUnsecuredRecovery.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLgdAssumptionUnsecuredRecoveryForViewDto {
    lgdAssumptionUnsecuredRecovery: LgdAssumptionDto | undefined;
}

export class GetLgdAssumptionUnsecuredRecoveryForEditOutput implements IGetLgdAssumptionUnsecuredRecoveryForEditOutput {
    lgdAssumptionUnsecuredRecovery!: CreateOrEditLgdAssumptionUnsecuredRecoveryDto | undefined;

    constructor(data?: IGetLgdAssumptionUnsecuredRecoveryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lgdAssumptionUnsecuredRecovery = data["lgdAssumptionUnsecuredRecovery"] ? CreateOrEditLgdAssumptionUnsecuredRecoveryDto.fromJS(data["lgdAssumptionUnsecuredRecovery"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLgdAssumptionUnsecuredRecoveryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLgdAssumptionUnsecuredRecoveryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lgdAssumptionUnsecuredRecovery"] = this.lgdAssumptionUnsecuredRecovery ? this.lgdAssumptionUnsecuredRecovery.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLgdAssumptionUnsecuredRecoveryForEditOutput {
    lgdAssumptionUnsecuredRecovery: CreateOrEditLgdAssumptionUnsecuredRecoveryDto | undefined;
}

export class CreateOrEditLgdAssumptionUnsecuredRecoveryDto implements ICreateOrEditLgdAssumptionUnsecuredRecoveryDto {
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    lgdGroup!: LdgInputAssumptionGroupEnum | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditLgdAssumptionUnsecuredRecoveryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.isComputed = data["isComputed"];
            this.lgdGroup = data["lgdGroup"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLgdAssumptionUnsecuredRecoveryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLgdAssumptionUnsecuredRecoveryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["isComputed"] = this.isComputed;
        data["lgdGroup"] = this.lgdGroup;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditLgdAssumptionUnsecuredRecoveryDto {
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    lgdGroup: LdgInputAssumptionGroupEnum | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMacroeconomicVariableForViewDto implements IPagedResultDtoOfGetMacroeconomicVariableForViewDto {
    totalCount!: number | undefined;
    items!: GetMacroeconomicVariableForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMacroeconomicVariableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMacroeconomicVariableForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMacroeconomicVariableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMacroeconomicVariableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMacroeconomicVariableForViewDto {
    totalCount: number | undefined;
    items: GetMacroeconomicVariableForViewDto[] | undefined;
}

export class GetMacroeconomicVariableForViewDto implements IGetMacroeconomicVariableForViewDto {
    macroeconomicVariable!: MacroeconomicVariableDto | undefined;

    constructor(data?: IGetMacroeconomicVariableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.macroeconomicVariable = data["macroeconomicVariable"] ? MacroeconomicVariableDto.fromJS(data["macroeconomicVariable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMacroeconomicVariableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMacroeconomicVariableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["macroeconomicVariable"] = this.macroeconomicVariable ? this.macroeconomicVariable.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMacroeconomicVariableForViewDto {
    macroeconomicVariable: MacroeconomicVariableDto | undefined;
}

export class MacroeconomicVariableDto implements IMacroeconomicVariableDto {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: IMacroeconomicVariableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MacroeconomicVariableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MacroeconomicVariableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMacroeconomicVariableDto {
    name: string | undefined;
    id: number | undefined;
}

export class GetMacroeconomicVariableForEditOutput implements IGetMacroeconomicVariableForEditOutput {
    macroeconomicVariable!: CreateOrEditMacroeconomicVariableDto | undefined;

    constructor(data?: IGetMacroeconomicVariableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.macroeconomicVariable = data["macroeconomicVariable"] ? CreateOrEditMacroeconomicVariableDto.fromJS(data["macroeconomicVariable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMacroeconomicVariableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMacroeconomicVariableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["macroeconomicVariable"] = this.macroeconomicVariable ? this.macroeconomicVariable.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMacroeconomicVariableForEditOutput {
    macroeconomicVariable: CreateOrEditMacroeconomicVariableDto | undefined;
}

export class CreateOrEditMacroeconomicVariableDto implements ICreateOrEditMacroeconomicVariableDto {
    name!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMacroeconomicVariableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMacroeconomicVariableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMacroeconomicVariableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMacroeconomicVariableDto {
    name: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export enum UserNotificationState {
    Unread = 0, 
    Read = 1, 
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotification | undefined;
    id!: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties![key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0, 
    Success = 1, 
    Warn = 2, 
    Error = 3, 
    Fatal = 4, 
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class PagedResultDtoOfGetObeEclApprovalForViewDto implements IPagedResultDtoOfGetObeEclApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclApprovalForViewDto {
    totalCount: number | undefined;
    items: GetObeEclApprovalForViewDto[] | undefined;
}

export class GetObeEclApprovalForViewDto implements IGetObeEclApprovalForViewDto {
    obeEclApproval!: ObeEclApprovalDto | undefined;
    obeEclTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclApproval = data["obeEclApproval"] ? ObeEclApprovalDto.fromJS(data["obeEclApproval"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclApproval"] = this.obeEclApproval ? this.obeEclApproval.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclApprovalForViewDto {
    obeEclApproval: ObeEclApprovalDto | undefined;
    obeEclTenantId: string | undefined;
    userName: string | undefined;
}

export class ObeEclApprovalDto implements IObeEclApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.obeEclId = data["obeEclId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["obeEclId"] = this.obeEclId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class GetObeEclApprovalForEditOutput implements IGetObeEclApprovalForEditOutput {
    obeEclApproval!: CreateOrEditObeEclApprovalDto | undefined;
    obeEclTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclApproval = data["obeEclApproval"] ? CreateOrEditObeEclApprovalDto.fromJS(data["obeEclApproval"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclApproval"] = this.obeEclApproval ? this.obeEclApproval.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclApprovalForEditOutput {
    obeEclApproval: CreateOrEditObeEclApprovalDto | undefined;
    obeEclTenantId: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditObeEclApprovalDto implements ICreateOrEditObeEclApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.obeEclId = data["obeEclId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["obeEclId"] = this.obeEclId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclApprovalObeEclLookupTableDto implements IPagedResultDtoOfObeEclApprovalObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclApprovalObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclApprovalObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclApprovalObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclApprovalObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclApprovalObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclApprovalObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclApprovalObeEclLookupTableDto[] | undefined;
}

export class ObeEclApprovalObeEclLookupTableDto implements IObeEclApprovalObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclApprovalObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclApprovalObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclApprovalObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclApprovalObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfObeEclApprovalUserLookupTableDto implements IPagedResultDtoOfObeEclApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclApprovalUserLookupTableDto[] | undefined;
}

export class ObeEclApprovalUserLookupTableDto implements IObeEclApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto implements IPagedResultDtoOfGetObeEclAssumptionApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclAssumptionApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclAssumptionApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclAssumptionApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclAssumptionApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclAssumptionApprovalForViewDto {
    totalCount: number | undefined;
    items: GetObeEclAssumptionApprovalForViewDto[] | undefined;
}

export class GetObeEclAssumptionApprovalForViewDto implements IGetObeEclAssumptionApprovalForViewDto {
    obeEclAssumptionApproval!: ObeEclAssumptionApprovalDto | undefined;
    obeEclTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclAssumptionApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclAssumptionApproval = data["obeEclAssumptionApproval"] ? ObeEclAssumptionApprovalDto.fromJS(data["obeEclAssumptionApproval"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclAssumptionApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclAssumptionApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclAssumptionApproval"] = this.obeEclAssumptionApproval ? this.obeEclAssumptionApproval.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclAssumptionApprovalForViewDto {
    obeEclAssumptionApproval: ObeEclAssumptionApprovalDto | undefined;
    obeEclTenantId: string | undefined;
    userName: string | undefined;
}

export class ObeEclAssumptionApprovalDto implements IObeEclAssumptionApprovalDto {
    assumptionType!: AssumptionTypeEnum | undefined;
    oldValue!: string | undefined;
    newValue!: string | undefined;
    dateReviewed!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    obeEclId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclAssumptionApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumptionType = data["assumptionType"];
            this.oldValue = data["oldValue"];
            this.newValue = data["newValue"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclAssumptionApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclAssumptionApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumptionType"] = this.assumptionType;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclAssumptionApprovalDto {
    assumptionType: AssumptionTypeEnum | undefined;
    oldValue: string | undefined;
    newValue: string | undefined;
    dateReviewed: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    obeEclId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export enum AssumptionTypeEnum {
    General = 0, 
    EadInputAssumption = 1, 
    LgdInputAssumption = 2, 
    PdInputAssumption = 3, 
    PdSnPAssumption = 4, 
    PdMacroeconomicProjection = 5, 
    PdMacroeconomicInput = 6, 
    PdNonInternalModel = 7, 
    PdNplIndex = 8, 
}

export class GetObeEclAssumptionApprovalForEditOutput implements IGetObeEclAssumptionApprovalForEditOutput {
    obeEclAssumptionApproval!: CreateOrEditObeEclAssumptionApprovalDto | undefined;
    obeEclTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclAssumptionApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclAssumptionApproval = data["obeEclAssumptionApproval"] ? CreateOrEditObeEclAssumptionApprovalDto.fromJS(data["obeEclAssumptionApproval"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclAssumptionApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclAssumptionApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclAssumptionApproval"] = this.obeEclAssumptionApproval ? this.obeEclAssumptionApproval.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclAssumptionApprovalForEditOutput {
    obeEclAssumptionApproval: CreateOrEditObeEclAssumptionApprovalDto | undefined;
    obeEclTenantId: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditObeEclAssumptionApprovalDto implements ICreateOrEditObeEclAssumptionApprovalDto {
    assumptionType!: AssumptionTypeEnum | undefined;
    oldValue!: string | undefined;
    newValue!: string | undefined;
    dateReviewed!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    requiresGroupApproval!: boolean;
    obeEclId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclAssumptionApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumptionType = data["assumptionType"];
            this.oldValue = data["oldValue"];
            this.newValue = data["newValue"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclAssumptionApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclAssumptionApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumptionType"] = this.assumptionType;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclAssumptionApprovalDto {
    assumptionType: AssumptionTypeEnum | undefined;
    oldValue: string | undefined;
    newValue: string | undefined;
    dateReviewed: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    requiresGroupApproval: boolean;
    obeEclId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto implements IPagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclAssumptionApprovalObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclAssumptionApprovalObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclAssumptionApprovalObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclAssumptionApprovalObeEclLookupTableDto[] | undefined;
}

export class ObeEclAssumptionApprovalObeEclLookupTableDto implements IObeEclAssumptionApprovalObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclAssumptionApprovalObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclAssumptionApprovalObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclAssumptionApprovalObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclAssumptionApprovalObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto implements IPagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclAssumptionApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclAssumptionApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclAssumptionApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclAssumptionApprovalUserLookupTableDto[] | undefined;
}

export class ObeEclAssumptionApprovalUserLookupTableDto implements IObeEclAssumptionApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclAssumptionApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclAssumptionApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclAssumptionApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclAssumptionApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclAssumptionForViewDto implements IPagedResultDtoOfGetObeEclAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetObeEclAssumptionForViewDto[] | undefined;
}

export class GetObeEclAssumptionForViewDto implements IGetObeEclAssumptionForViewDto {
    obeEclAssumption!: ObeEclAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclAssumption = data["obeEclAssumption"] ? ObeEclAssumptionDto.fromJS(data["obeEclAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclAssumption"] = this.obeEclAssumption ? this.obeEclAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclAssumptionForViewDto {
    obeEclAssumption: ObeEclAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclAssumptionDto implements IObeEclAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.assumptionGroup = data["assumptionGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["assumptionGroup"] = this.assumptionGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    assumptionGroup: AssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclAssumptionForEditOutput implements IGetObeEclAssumptionForEditOutput {
    obeEclAssumption!: CreateOrEditObeEclAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclAssumption = data["obeEclAssumption"] ? CreateOrEditObeEclAssumptionDto.fromJS(data["obeEclAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclAssumption"] = this.obeEclAssumption ? this.obeEclAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclAssumptionForEditOutput {
    obeEclAssumption: CreateOrEditObeEclAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclAssumptionDto implements ICreateOrEditObeEclAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.assumptionGroup = data["assumptionGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["assumptionGroup"] = this.assumptionGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean;
    assumptionGroup: AssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto implements IPagedResultDtoOfObeEclAssumptionObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclAssumptionObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclAssumptionObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclAssumptionObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclAssumptionObeEclLookupTableDto[] | undefined;
}

export class ObeEclAssumptionObeEclLookupTableDto implements IObeEclAssumptionObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclAssumptionObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclDataLoanBookForViewDto implements IPagedResultDtoOfGetObeEclDataLoanBookForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclDataLoanBookForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclDataLoanBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclDataLoanBookForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclDataLoanBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclDataLoanBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclDataLoanBookForViewDto {
    totalCount: number | undefined;
    items: GetObeEclDataLoanBookForViewDto[] | undefined;
}

export class GetObeEclDataLoanBookForViewDto implements IGetObeEclDataLoanBookForViewDto {
    obeEclDataLoanBook!: ObeEclDataLoanBookDto | undefined;
    obeEclUploadTenantId!: string | undefined;

    constructor(data?: IGetObeEclDataLoanBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclDataLoanBook = data["obeEclDataLoanBook"] ? ObeEclDataLoanBookDto.fromJS(data["obeEclDataLoanBook"]) : <any>undefined;
            this.obeEclUploadTenantId = data["obeEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclDataLoanBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclDataLoanBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclDataLoanBook"] = this.obeEclDataLoanBook ? this.obeEclDataLoanBook.toJSON() : <any>undefined;
        data["obeEclUploadTenantId"] = this.obeEclUploadTenantId;
        return data; 
    }
}

export interface IGetObeEclDataLoanBookForViewDto {
    obeEclDataLoanBook: ObeEclDataLoanBookDto | undefined;
    obeEclUploadTenantId: string | undefined;
}

export class ObeEclDataLoanBookDto implements IObeEclDataLoanBookDto {
    customerNo!: string | undefined;
    accountNo!: string | undefined;
    contractNo!: string | undefined;
    customerName!: string | undefined;
    snapshotDate!: moment.Moment | undefined;
    segment!: string | undefined;
    sector!: string | undefined;
    currency!: string | undefined;
    productType!: string | undefined;
    productMapping!: string | undefined;
    specialisedLending!: string | undefined;
    ratingModel!: string | undefined;
    originalRating!: number | undefined;
    currentRating!: number | undefined;
    lifetimePD!: number | undefined;
    month12PD!: number | undefined;
    daysPastDue!: number | undefined;
    watchlistIndicator!: boolean | undefined;
    classification!: string | undefined;
    impairedDate!: moment.Moment | undefined;
    defaultDate!: moment.Moment | undefined;
    creditLimit!: number | undefined;
    originalBalanceLCY!: number | undefined;
    outstandingBalanceLCY!: number | undefined;
    outstandingBalanceACY!: number | undefined;
    contractStartDate!: moment.Moment | undefined;
    contractEndDate!: moment.Moment | undefined;
    restructureIndicator!: boolean | undefined;
    restructureRisk!: string | undefined;
    restructureType!: string | undefined;
    restructureStartDate!: moment.Moment | undefined;
    restructureEndDate!: moment.Moment | undefined;
    principalPaymentTermsOrigination!: string | undefined;
    pptoPeriod!: number | undefined;
    interestPaymentTermsOrigination!: string | undefined;
    iptoPeriod!: number | undefined;
    principalPaymentStructure!: string | undefined;
    interestPaymentStructure!: string | undefined;
    interestRateType!: string | undefined;
    baseRate!: string | undefined;
    originationContractualInterestRate!: string | undefined;
    introductoryPeriod!: number | undefined;
    postIPContractualInterestRate!: number | undefined;
    currentContractualInterestRate!: number | undefined;
    eir!: number | undefined;
    debentureOMV!: number | undefined;
    debentureFSV!: number | undefined;
    cashOMV!: number | undefined;
    cashFSV!: number | undefined;
    inventoryOMV!: number | undefined;
    inventoryFSV!: number | undefined;
    plantEquipmentOMV!: number | undefined;
    plantEquipmentFSV!: number | undefined;
    residentialPropertyOMV!: number | undefined;
    residentialPropertyFSV!: number | undefined;
    commercialPropertyOMV!: number | undefined;
    commercialProperty!: number | undefined;
    receivablesOMV!: number | undefined;
    receivablesFSV!: number | undefined;
    sharesOMV!: number | undefined;
    sharesFSV!: number | undefined;
    vehicleOMV!: number | undefined;
    vehicleFSV!: number | undefined;
    cureRate!: number | undefined;
    guaranteeIndicator!: boolean | undefined;
    guarantorPD!: string | undefined;
    guarantorLGD!: string | undefined;
    guaranteeValue!: number | undefined;
    guaranteeLevel!: number | undefined;
    contractId!: string | undefined;
    obeEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclDataLoanBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNo = data["customerNo"];
            this.accountNo = data["accountNo"];
            this.contractNo = data["contractNo"];
            this.customerName = data["customerName"];
            this.snapshotDate = data["snapshotDate"] ? moment(data["snapshotDate"].toString()) : <any>undefined;
            this.segment = data["segment"];
            this.sector = data["sector"];
            this.currency = data["currency"];
            this.productType = data["productType"];
            this.productMapping = data["productMapping"];
            this.specialisedLending = data["specialisedLending"];
            this.ratingModel = data["ratingModel"];
            this.originalRating = data["originalRating"];
            this.currentRating = data["currentRating"];
            this.lifetimePD = data["lifetimePD"];
            this.month12PD = data["month12PD"];
            this.daysPastDue = data["daysPastDue"];
            this.watchlistIndicator = data["watchlistIndicator"];
            this.classification = data["classification"];
            this.impairedDate = data["impairedDate"] ? moment(data["impairedDate"].toString()) : <any>undefined;
            this.defaultDate = data["defaultDate"] ? moment(data["defaultDate"].toString()) : <any>undefined;
            this.creditLimit = data["creditLimit"];
            this.originalBalanceLCY = data["originalBalanceLCY"];
            this.outstandingBalanceLCY = data["outstandingBalanceLCY"];
            this.outstandingBalanceACY = data["outstandingBalanceACY"];
            this.contractStartDate = data["contractStartDate"] ? moment(data["contractStartDate"].toString()) : <any>undefined;
            this.contractEndDate = data["contractEndDate"] ? moment(data["contractEndDate"].toString()) : <any>undefined;
            this.restructureIndicator = data["restructureIndicator"];
            this.restructureRisk = data["restructureRisk"];
            this.restructureType = data["restructureType"];
            this.restructureStartDate = data["restructureStartDate"] ? moment(data["restructureStartDate"].toString()) : <any>undefined;
            this.restructureEndDate = data["restructureEndDate"] ? moment(data["restructureEndDate"].toString()) : <any>undefined;
            this.principalPaymentTermsOrigination = data["principalPaymentTermsOrigination"];
            this.pptoPeriod = data["pptoPeriod"];
            this.interestPaymentTermsOrigination = data["interestPaymentTermsOrigination"];
            this.iptoPeriod = data["iptoPeriod"];
            this.principalPaymentStructure = data["principalPaymentStructure"];
            this.interestPaymentStructure = data["interestPaymentStructure"];
            this.interestRateType = data["interestRateType"];
            this.baseRate = data["baseRate"];
            this.originationContractualInterestRate = data["originationContractualInterestRate"];
            this.introductoryPeriod = data["introductoryPeriod"];
            this.postIPContractualInterestRate = data["postIPContractualInterestRate"];
            this.currentContractualInterestRate = data["currentContractualInterestRate"];
            this.eir = data["eir"];
            this.debentureOMV = data["debentureOMV"];
            this.debentureFSV = data["debentureFSV"];
            this.cashOMV = data["cashOMV"];
            this.cashFSV = data["cashFSV"];
            this.inventoryOMV = data["inventoryOMV"];
            this.inventoryFSV = data["inventoryFSV"];
            this.plantEquipmentOMV = data["plantEquipmentOMV"];
            this.plantEquipmentFSV = data["plantEquipmentFSV"];
            this.residentialPropertyOMV = data["residentialPropertyOMV"];
            this.residentialPropertyFSV = data["residentialPropertyFSV"];
            this.commercialPropertyOMV = data["commercialPropertyOMV"];
            this.commercialProperty = data["commercialProperty"];
            this.receivablesOMV = data["receivablesOMV"];
            this.receivablesFSV = data["receivablesFSV"];
            this.sharesOMV = data["sharesOMV"];
            this.sharesFSV = data["sharesFSV"];
            this.vehicleOMV = data["vehicleOMV"];
            this.vehicleFSV = data["vehicleFSV"];
            this.cureRate = data["cureRate"];
            this.guaranteeIndicator = data["guaranteeIndicator"];
            this.guarantorPD = data["guarantorPD"];
            this.guarantorLGD = data["guarantorLGD"];
            this.guaranteeValue = data["guaranteeValue"];
            this.guaranteeLevel = data["guaranteeLevel"];
            this.contractId = data["contractId"];
            this.obeEclUploadId = data["obeEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclDataLoanBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclDataLoanBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["contractNo"] = this.contractNo;
        data["customerName"] = this.customerName;
        data["snapshotDate"] = this.snapshotDate ? this.snapshotDate.toISOString() : <any>undefined;
        data["segment"] = this.segment;
        data["sector"] = this.sector;
        data["currency"] = this.currency;
        data["productType"] = this.productType;
        data["productMapping"] = this.productMapping;
        data["specialisedLending"] = this.specialisedLending;
        data["ratingModel"] = this.ratingModel;
        data["originalRating"] = this.originalRating;
        data["currentRating"] = this.currentRating;
        data["lifetimePD"] = this.lifetimePD;
        data["month12PD"] = this.month12PD;
        data["daysPastDue"] = this.daysPastDue;
        data["watchlistIndicator"] = this.watchlistIndicator;
        data["classification"] = this.classification;
        data["impairedDate"] = this.impairedDate ? this.impairedDate.toISOString() : <any>undefined;
        data["defaultDate"] = this.defaultDate ? this.defaultDate.toISOString() : <any>undefined;
        data["creditLimit"] = this.creditLimit;
        data["originalBalanceLCY"] = this.originalBalanceLCY;
        data["outstandingBalanceLCY"] = this.outstandingBalanceLCY;
        data["outstandingBalanceACY"] = this.outstandingBalanceACY;
        data["contractStartDate"] = this.contractStartDate ? this.contractStartDate.toISOString() : <any>undefined;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["restructureIndicator"] = this.restructureIndicator;
        data["restructureRisk"] = this.restructureRisk;
        data["restructureType"] = this.restructureType;
        data["restructureStartDate"] = this.restructureStartDate ? this.restructureStartDate.toISOString() : <any>undefined;
        data["restructureEndDate"] = this.restructureEndDate ? this.restructureEndDate.toISOString() : <any>undefined;
        data["principalPaymentTermsOrigination"] = this.principalPaymentTermsOrigination;
        data["pptoPeriod"] = this.pptoPeriod;
        data["interestPaymentTermsOrigination"] = this.interestPaymentTermsOrigination;
        data["iptoPeriod"] = this.iptoPeriod;
        data["principalPaymentStructure"] = this.principalPaymentStructure;
        data["interestPaymentStructure"] = this.interestPaymentStructure;
        data["interestRateType"] = this.interestRateType;
        data["baseRate"] = this.baseRate;
        data["originationContractualInterestRate"] = this.originationContractualInterestRate;
        data["introductoryPeriod"] = this.introductoryPeriod;
        data["postIPContractualInterestRate"] = this.postIPContractualInterestRate;
        data["currentContractualInterestRate"] = this.currentContractualInterestRate;
        data["eir"] = this.eir;
        data["debentureOMV"] = this.debentureOMV;
        data["debentureFSV"] = this.debentureFSV;
        data["cashOMV"] = this.cashOMV;
        data["cashFSV"] = this.cashFSV;
        data["inventoryOMV"] = this.inventoryOMV;
        data["inventoryFSV"] = this.inventoryFSV;
        data["plantEquipmentOMV"] = this.plantEquipmentOMV;
        data["plantEquipmentFSV"] = this.plantEquipmentFSV;
        data["residentialPropertyOMV"] = this.residentialPropertyOMV;
        data["residentialPropertyFSV"] = this.residentialPropertyFSV;
        data["commercialPropertyOMV"] = this.commercialPropertyOMV;
        data["commercialProperty"] = this.commercialProperty;
        data["receivablesOMV"] = this.receivablesOMV;
        data["receivablesFSV"] = this.receivablesFSV;
        data["sharesOMV"] = this.sharesOMV;
        data["sharesFSV"] = this.sharesFSV;
        data["vehicleOMV"] = this.vehicleOMV;
        data["vehicleFSV"] = this.vehicleFSV;
        data["cureRate"] = this.cureRate;
        data["guaranteeIndicator"] = this.guaranteeIndicator;
        data["guarantorPD"] = this.guarantorPD;
        data["guarantorLGD"] = this.guarantorLGD;
        data["guaranteeValue"] = this.guaranteeValue;
        data["guaranteeLevel"] = this.guaranteeLevel;
        data["contractId"] = this.contractId;
        data["obeEclUploadId"] = this.obeEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclDataLoanBookDto {
    customerNo: string | undefined;
    accountNo: string | undefined;
    contractNo: string | undefined;
    customerName: string | undefined;
    snapshotDate: moment.Moment | undefined;
    segment: string | undefined;
    sector: string | undefined;
    currency: string | undefined;
    productType: string | undefined;
    productMapping: string | undefined;
    specialisedLending: string | undefined;
    ratingModel: string | undefined;
    originalRating: number | undefined;
    currentRating: number | undefined;
    lifetimePD: number | undefined;
    month12PD: number | undefined;
    daysPastDue: number | undefined;
    watchlistIndicator: boolean | undefined;
    classification: string | undefined;
    impairedDate: moment.Moment | undefined;
    defaultDate: moment.Moment | undefined;
    creditLimit: number | undefined;
    originalBalanceLCY: number | undefined;
    outstandingBalanceLCY: number | undefined;
    outstandingBalanceACY: number | undefined;
    contractStartDate: moment.Moment | undefined;
    contractEndDate: moment.Moment | undefined;
    restructureIndicator: boolean | undefined;
    restructureRisk: string | undefined;
    restructureType: string | undefined;
    restructureStartDate: moment.Moment | undefined;
    restructureEndDate: moment.Moment | undefined;
    principalPaymentTermsOrigination: string | undefined;
    pptoPeriod: number | undefined;
    interestPaymentTermsOrigination: string | undefined;
    iptoPeriod: number | undefined;
    principalPaymentStructure: string | undefined;
    interestPaymentStructure: string | undefined;
    interestRateType: string | undefined;
    baseRate: string | undefined;
    originationContractualInterestRate: string | undefined;
    introductoryPeriod: number | undefined;
    postIPContractualInterestRate: number | undefined;
    currentContractualInterestRate: number | undefined;
    eir: number | undefined;
    debentureOMV: number | undefined;
    debentureFSV: number | undefined;
    cashOMV: number | undefined;
    cashFSV: number | undefined;
    inventoryOMV: number | undefined;
    inventoryFSV: number | undefined;
    plantEquipmentOMV: number | undefined;
    plantEquipmentFSV: number | undefined;
    residentialPropertyOMV: number | undefined;
    residentialPropertyFSV: number | undefined;
    commercialPropertyOMV: number | undefined;
    commercialProperty: number | undefined;
    receivablesOMV: number | undefined;
    receivablesFSV: number | undefined;
    sharesOMV: number | undefined;
    sharesFSV: number | undefined;
    vehicleOMV: number | undefined;
    vehicleFSV: number | undefined;
    cureRate: number | undefined;
    guaranteeIndicator: boolean | undefined;
    guarantorPD: string | undefined;
    guarantorLGD: string | undefined;
    guaranteeValue: number | undefined;
    guaranteeLevel: number | undefined;
    contractId: string | undefined;
    obeEclUploadId: string | undefined;
    id: string | undefined;
}

export class GetObeEclDataLoanBookForEditOutput implements IGetObeEclDataLoanBookForEditOutput {
    obeEclDataLoanBook!: CreateOrEditObeEclDataLoanBookDto | undefined;
    obeEclUploadTenantId!: string | undefined;

    constructor(data?: IGetObeEclDataLoanBookForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclDataLoanBook = data["obeEclDataLoanBook"] ? CreateOrEditObeEclDataLoanBookDto.fromJS(data["obeEclDataLoanBook"]) : <any>undefined;
            this.obeEclUploadTenantId = data["obeEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclDataLoanBookForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclDataLoanBookForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclDataLoanBook"] = this.obeEclDataLoanBook ? this.obeEclDataLoanBook.toJSON() : <any>undefined;
        data["obeEclUploadTenantId"] = this.obeEclUploadTenantId;
        return data; 
    }
}

export interface IGetObeEclDataLoanBookForEditOutput {
    obeEclDataLoanBook: CreateOrEditObeEclDataLoanBookDto | undefined;
    obeEclUploadTenantId: string | undefined;
}

export class CreateOrEditObeEclDataLoanBookDto implements ICreateOrEditObeEclDataLoanBookDto {
    customerNo!: string | undefined;
    accountNo!: string | undefined;
    contractNo!: string | undefined;
    customerName!: string | undefined;
    snapshotDate!: moment.Moment | undefined;
    segment!: string | undefined;
    sector!: string | undefined;
    currency!: string | undefined;
    productType!: string | undefined;
    productMapping!: string | undefined;
    specialisedLending!: string | undefined;
    ratingModel!: string | undefined;
    originalRating!: number | undefined;
    currentRating!: number | undefined;
    lifetimePD!: number | undefined;
    month12PD!: number | undefined;
    daysPastDue!: number | undefined;
    watchlistIndicator!: boolean;
    classification!: string | undefined;
    impairedDate!: moment.Moment | undefined;
    defaultDate!: moment.Moment | undefined;
    creditLimit!: number | undefined;
    originalBalanceLCY!: number | undefined;
    outstandingBalanceLCY!: number | undefined;
    outstandingBalanceACY!: number | undefined;
    contractStartDate!: moment.Moment | undefined;
    contractEndDate!: moment.Moment | undefined;
    restructureIndicator!: boolean;
    restructureRisk!: string | undefined;
    restructureType!: string | undefined;
    restructureStartDate!: moment.Moment | undefined;
    restructureEndDate!: moment.Moment | undefined;
    principalPaymentTermsOrigination!: string | undefined;
    pptoPeriod!: number | undefined;
    interestPaymentTermsOrigination!: string | undefined;
    iptoPeriod!: number | undefined;
    principalPaymentStructure!: string | undefined;
    interestPaymentStructure!: string | undefined;
    interestRateType!: string | undefined;
    baseRate!: string | undefined;
    originationContractualInterestRate!: string | undefined;
    introductoryPeriod!: number | undefined;
    postIPContractualInterestRate!: number | undefined;
    currentContractualInterestRate!: number | undefined;
    eir!: number | undefined;
    debentureOMV!: number | undefined;
    debentureFSV!: number | undefined;
    cashOMV!: number | undefined;
    cashFSV!: number | undefined;
    inventoryOMV!: number | undefined;
    inventoryFSV!: number | undefined;
    plantEquipmentOMV!: number | undefined;
    plantEquipmentFSV!: number | undefined;
    residentialPropertyOMV!: number | undefined;
    residentialPropertyFSV!: number | undefined;
    commercialPropertyOMV!: number | undefined;
    commercialProperty!: number | undefined;
    receivablesOMV!: number | undefined;
    receivablesFSV!: number | undefined;
    sharesOMV!: number | undefined;
    sharesFSV!: number | undefined;
    vehicleOMV!: number | undefined;
    vehicleFSV!: number | undefined;
    cureRate!: number | undefined;
    guaranteeIndicator!: boolean;
    guarantorPD!: string | undefined;
    guarantorLGD!: string | undefined;
    guaranteeValue!: number | undefined;
    guaranteeLevel!: number | undefined;
    contractId!: string | undefined;
    obeEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclDataLoanBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNo = data["customerNo"];
            this.accountNo = data["accountNo"];
            this.contractNo = data["contractNo"];
            this.customerName = data["customerName"];
            this.snapshotDate = data["snapshotDate"] ? moment(data["snapshotDate"].toString()) : <any>undefined;
            this.segment = data["segment"];
            this.sector = data["sector"];
            this.currency = data["currency"];
            this.productType = data["productType"];
            this.productMapping = data["productMapping"];
            this.specialisedLending = data["specialisedLending"];
            this.ratingModel = data["ratingModel"];
            this.originalRating = data["originalRating"];
            this.currentRating = data["currentRating"];
            this.lifetimePD = data["lifetimePD"];
            this.month12PD = data["month12PD"];
            this.daysPastDue = data["daysPastDue"];
            this.watchlistIndicator = data["watchlistIndicator"];
            this.classification = data["classification"];
            this.impairedDate = data["impairedDate"] ? moment(data["impairedDate"].toString()) : <any>undefined;
            this.defaultDate = data["defaultDate"] ? moment(data["defaultDate"].toString()) : <any>undefined;
            this.creditLimit = data["creditLimit"];
            this.originalBalanceLCY = data["originalBalanceLCY"];
            this.outstandingBalanceLCY = data["outstandingBalanceLCY"];
            this.outstandingBalanceACY = data["outstandingBalanceACY"];
            this.contractStartDate = data["contractStartDate"] ? moment(data["contractStartDate"].toString()) : <any>undefined;
            this.contractEndDate = data["contractEndDate"] ? moment(data["contractEndDate"].toString()) : <any>undefined;
            this.restructureIndicator = data["restructureIndicator"];
            this.restructureRisk = data["restructureRisk"];
            this.restructureType = data["restructureType"];
            this.restructureStartDate = data["restructureStartDate"] ? moment(data["restructureStartDate"].toString()) : <any>undefined;
            this.restructureEndDate = data["restructureEndDate"] ? moment(data["restructureEndDate"].toString()) : <any>undefined;
            this.principalPaymentTermsOrigination = data["principalPaymentTermsOrigination"];
            this.pptoPeriod = data["pptoPeriod"];
            this.interestPaymentTermsOrigination = data["interestPaymentTermsOrigination"];
            this.iptoPeriod = data["iptoPeriod"];
            this.principalPaymentStructure = data["principalPaymentStructure"];
            this.interestPaymentStructure = data["interestPaymentStructure"];
            this.interestRateType = data["interestRateType"];
            this.baseRate = data["baseRate"];
            this.originationContractualInterestRate = data["originationContractualInterestRate"];
            this.introductoryPeriod = data["introductoryPeriod"];
            this.postIPContractualInterestRate = data["postIPContractualInterestRate"];
            this.currentContractualInterestRate = data["currentContractualInterestRate"];
            this.eir = data["eir"];
            this.debentureOMV = data["debentureOMV"];
            this.debentureFSV = data["debentureFSV"];
            this.cashOMV = data["cashOMV"];
            this.cashFSV = data["cashFSV"];
            this.inventoryOMV = data["inventoryOMV"];
            this.inventoryFSV = data["inventoryFSV"];
            this.plantEquipmentOMV = data["plantEquipmentOMV"];
            this.plantEquipmentFSV = data["plantEquipmentFSV"];
            this.residentialPropertyOMV = data["residentialPropertyOMV"];
            this.residentialPropertyFSV = data["residentialPropertyFSV"];
            this.commercialPropertyOMV = data["commercialPropertyOMV"];
            this.commercialProperty = data["commercialProperty"];
            this.receivablesOMV = data["receivablesOMV"];
            this.receivablesFSV = data["receivablesFSV"];
            this.sharesOMV = data["sharesOMV"];
            this.sharesFSV = data["sharesFSV"];
            this.vehicleOMV = data["vehicleOMV"];
            this.vehicleFSV = data["vehicleFSV"];
            this.cureRate = data["cureRate"];
            this.guaranteeIndicator = data["guaranteeIndicator"];
            this.guarantorPD = data["guarantorPD"];
            this.guarantorLGD = data["guarantorLGD"];
            this.guaranteeValue = data["guaranteeValue"];
            this.guaranteeLevel = data["guaranteeLevel"];
            this.contractId = data["contractId"];
            this.obeEclUploadId = data["obeEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclDataLoanBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclDataLoanBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["contractNo"] = this.contractNo;
        data["customerName"] = this.customerName;
        data["snapshotDate"] = this.snapshotDate ? this.snapshotDate.toISOString() : <any>undefined;
        data["segment"] = this.segment;
        data["sector"] = this.sector;
        data["currency"] = this.currency;
        data["productType"] = this.productType;
        data["productMapping"] = this.productMapping;
        data["specialisedLending"] = this.specialisedLending;
        data["ratingModel"] = this.ratingModel;
        data["originalRating"] = this.originalRating;
        data["currentRating"] = this.currentRating;
        data["lifetimePD"] = this.lifetimePD;
        data["month12PD"] = this.month12PD;
        data["daysPastDue"] = this.daysPastDue;
        data["watchlistIndicator"] = this.watchlistIndicator;
        data["classification"] = this.classification;
        data["impairedDate"] = this.impairedDate ? this.impairedDate.toISOString() : <any>undefined;
        data["defaultDate"] = this.defaultDate ? this.defaultDate.toISOString() : <any>undefined;
        data["creditLimit"] = this.creditLimit;
        data["originalBalanceLCY"] = this.originalBalanceLCY;
        data["outstandingBalanceLCY"] = this.outstandingBalanceLCY;
        data["outstandingBalanceACY"] = this.outstandingBalanceACY;
        data["contractStartDate"] = this.contractStartDate ? this.contractStartDate.toISOString() : <any>undefined;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["restructureIndicator"] = this.restructureIndicator;
        data["restructureRisk"] = this.restructureRisk;
        data["restructureType"] = this.restructureType;
        data["restructureStartDate"] = this.restructureStartDate ? this.restructureStartDate.toISOString() : <any>undefined;
        data["restructureEndDate"] = this.restructureEndDate ? this.restructureEndDate.toISOString() : <any>undefined;
        data["principalPaymentTermsOrigination"] = this.principalPaymentTermsOrigination;
        data["pptoPeriod"] = this.pptoPeriod;
        data["interestPaymentTermsOrigination"] = this.interestPaymentTermsOrigination;
        data["iptoPeriod"] = this.iptoPeriod;
        data["principalPaymentStructure"] = this.principalPaymentStructure;
        data["interestPaymentStructure"] = this.interestPaymentStructure;
        data["interestRateType"] = this.interestRateType;
        data["baseRate"] = this.baseRate;
        data["originationContractualInterestRate"] = this.originationContractualInterestRate;
        data["introductoryPeriod"] = this.introductoryPeriod;
        data["postIPContractualInterestRate"] = this.postIPContractualInterestRate;
        data["currentContractualInterestRate"] = this.currentContractualInterestRate;
        data["eir"] = this.eir;
        data["debentureOMV"] = this.debentureOMV;
        data["debentureFSV"] = this.debentureFSV;
        data["cashOMV"] = this.cashOMV;
        data["cashFSV"] = this.cashFSV;
        data["inventoryOMV"] = this.inventoryOMV;
        data["inventoryFSV"] = this.inventoryFSV;
        data["plantEquipmentOMV"] = this.plantEquipmentOMV;
        data["plantEquipmentFSV"] = this.plantEquipmentFSV;
        data["residentialPropertyOMV"] = this.residentialPropertyOMV;
        data["residentialPropertyFSV"] = this.residentialPropertyFSV;
        data["commercialPropertyOMV"] = this.commercialPropertyOMV;
        data["commercialProperty"] = this.commercialProperty;
        data["receivablesOMV"] = this.receivablesOMV;
        data["receivablesFSV"] = this.receivablesFSV;
        data["sharesOMV"] = this.sharesOMV;
        data["sharesFSV"] = this.sharesFSV;
        data["vehicleOMV"] = this.vehicleOMV;
        data["vehicleFSV"] = this.vehicleFSV;
        data["cureRate"] = this.cureRate;
        data["guaranteeIndicator"] = this.guaranteeIndicator;
        data["guarantorPD"] = this.guarantorPD;
        data["guarantorLGD"] = this.guarantorLGD;
        data["guaranteeValue"] = this.guaranteeValue;
        data["guaranteeLevel"] = this.guaranteeLevel;
        data["contractId"] = this.contractId;
        data["obeEclUploadId"] = this.obeEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclDataLoanBookDto {
    customerNo: string | undefined;
    accountNo: string | undefined;
    contractNo: string | undefined;
    customerName: string | undefined;
    snapshotDate: moment.Moment | undefined;
    segment: string | undefined;
    sector: string | undefined;
    currency: string | undefined;
    productType: string | undefined;
    productMapping: string | undefined;
    specialisedLending: string | undefined;
    ratingModel: string | undefined;
    originalRating: number | undefined;
    currentRating: number | undefined;
    lifetimePD: number | undefined;
    month12PD: number | undefined;
    daysPastDue: number | undefined;
    watchlistIndicator: boolean;
    classification: string | undefined;
    impairedDate: moment.Moment | undefined;
    defaultDate: moment.Moment | undefined;
    creditLimit: number | undefined;
    originalBalanceLCY: number | undefined;
    outstandingBalanceLCY: number | undefined;
    outstandingBalanceACY: number | undefined;
    contractStartDate: moment.Moment | undefined;
    contractEndDate: moment.Moment | undefined;
    restructureIndicator: boolean;
    restructureRisk: string | undefined;
    restructureType: string | undefined;
    restructureStartDate: moment.Moment | undefined;
    restructureEndDate: moment.Moment | undefined;
    principalPaymentTermsOrigination: string | undefined;
    pptoPeriod: number | undefined;
    interestPaymentTermsOrigination: string | undefined;
    iptoPeriod: number | undefined;
    principalPaymentStructure: string | undefined;
    interestPaymentStructure: string | undefined;
    interestRateType: string | undefined;
    baseRate: string | undefined;
    originationContractualInterestRate: string | undefined;
    introductoryPeriod: number | undefined;
    postIPContractualInterestRate: number | undefined;
    currentContractualInterestRate: number | undefined;
    eir: number | undefined;
    debentureOMV: number | undefined;
    debentureFSV: number | undefined;
    cashOMV: number | undefined;
    cashFSV: number | undefined;
    inventoryOMV: number | undefined;
    inventoryFSV: number | undefined;
    plantEquipmentOMV: number | undefined;
    plantEquipmentFSV: number | undefined;
    residentialPropertyOMV: number | undefined;
    residentialPropertyFSV: number | undefined;
    commercialPropertyOMV: number | undefined;
    commercialProperty: number | undefined;
    receivablesOMV: number | undefined;
    receivablesFSV: number | undefined;
    sharesOMV: number | undefined;
    sharesFSV: number | undefined;
    vehicleOMV: number | undefined;
    vehicleFSV: number | undefined;
    cureRate: number | undefined;
    guaranteeIndicator: boolean;
    guarantorPD: string | undefined;
    guarantorLGD: string | undefined;
    guaranteeValue: number | undefined;
    guaranteeLevel: number | undefined;
    contractId: string | undefined;
    obeEclUploadId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto implements IPagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclDataLoanBookObeEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclDataLoanBookObeEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclDataLoanBookObeEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclDataLoanBookObeEclUploadLookupTableDto[] | undefined;
}

export class ObeEclDataLoanBookObeEclUploadLookupTableDto implements IObeEclDataLoanBookObeEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclDataLoanBookObeEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclDataLoanBookObeEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclDataLoanBookObeEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclDataLoanBookObeEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto implements IPagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclDataPaymentScheduleForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclDataPaymentScheduleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclDataPaymentScheduleForViewDto {
    totalCount: number | undefined;
    items: GetObeEclDataPaymentScheduleForViewDto[] | undefined;
}

export class GetObeEclDataPaymentScheduleForViewDto implements IGetObeEclDataPaymentScheduleForViewDto {
    obeEclDataPaymentSchedule!: ObeEclDataPaymentScheduleDto | undefined;
    obeEclUploadTenantId!: string | undefined;

    constructor(data?: IGetObeEclDataPaymentScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclDataPaymentSchedule = data["obeEclDataPaymentSchedule"] ? ObeEclDataPaymentScheduleDto.fromJS(data["obeEclDataPaymentSchedule"]) : <any>undefined;
            this.obeEclUploadTenantId = data["obeEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclDataPaymentScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclDataPaymentScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclDataPaymentSchedule"] = this.obeEclDataPaymentSchedule ? this.obeEclDataPaymentSchedule.toJSON() : <any>undefined;
        data["obeEclUploadTenantId"] = this.obeEclUploadTenantId;
        return data; 
    }
}

export interface IGetObeEclDataPaymentScheduleForViewDto {
    obeEclDataPaymentSchedule: ObeEclDataPaymentScheduleDto | undefined;
    obeEclUploadTenantId: string | undefined;
}

export class ObeEclDataPaymentScheduleDto implements IObeEclDataPaymentScheduleDto {
    contractRefNo!: string | undefined;
    startDate!: moment.Moment | undefined;
    component!: string | undefined;
    noOfSchedules!: number | undefined;
    frequency!: string | undefined;
    amount!: number | undefined;
    obeEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclDataPaymentScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractRefNo = data["contractRefNo"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.component = data["component"];
            this.noOfSchedules = data["noOfSchedules"];
            this.frequency = data["frequency"];
            this.amount = data["amount"];
            this.obeEclUploadId = data["obeEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclDataPaymentScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclDataPaymentScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractRefNo"] = this.contractRefNo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["component"] = this.component;
        data["noOfSchedules"] = this.noOfSchedules;
        data["frequency"] = this.frequency;
        data["amount"] = this.amount;
        data["obeEclUploadId"] = this.obeEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclDataPaymentScheduleDto {
    contractRefNo: string | undefined;
    startDate: moment.Moment | undefined;
    component: string | undefined;
    noOfSchedules: number | undefined;
    frequency: string | undefined;
    amount: number | undefined;
    obeEclUploadId: string | undefined;
    id: string | undefined;
}

export class GetObeEclDataPaymentScheduleForEditOutput implements IGetObeEclDataPaymentScheduleForEditOutput {
    obeEclDataPaymentSchedule!: CreateOrEditObeEclDataPaymentScheduleDto | undefined;
    obeEclUploadTenantId!: string | undefined;

    constructor(data?: IGetObeEclDataPaymentScheduleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclDataPaymentSchedule = data["obeEclDataPaymentSchedule"] ? CreateOrEditObeEclDataPaymentScheduleDto.fromJS(data["obeEclDataPaymentSchedule"]) : <any>undefined;
            this.obeEclUploadTenantId = data["obeEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclDataPaymentScheduleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclDataPaymentScheduleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclDataPaymentSchedule"] = this.obeEclDataPaymentSchedule ? this.obeEclDataPaymentSchedule.toJSON() : <any>undefined;
        data["obeEclUploadTenantId"] = this.obeEclUploadTenantId;
        return data; 
    }
}

export interface IGetObeEclDataPaymentScheduleForEditOutput {
    obeEclDataPaymentSchedule: CreateOrEditObeEclDataPaymentScheduleDto | undefined;
    obeEclUploadTenantId: string | undefined;
}

export class CreateOrEditObeEclDataPaymentScheduleDto implements ICreateOrEditObeEclDataPaymentScheduleDto {
    contractRefNo!: string | undefined;
    startDate!: moment.Moment | undefined;
    component!: string | undefined;
    noOfSchedules!: number | undefined;
    frequency!: string | undefined;
    amount!: number | undefined;
    obeEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclDataPaymentScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractRefNo = data["contractRefNo"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.component = data["component"];
            this.noOfSchedules = data["noOfSchedules"];
            this.frequency = data["frequency"];
            this.amount = data["amount"];
            this.obeEclUploadId = data["obeEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclDataPaymentScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclDataPaymentScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractRefNo"] = this.contractRefNo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["component"] = this.component;
        data["noOfSchedules"] = this.noOfSchedules;
        data["frequency"] = this.frequency;
        data["amount"] = this.amount;
        data["obeEclUploadId"] = this.obeEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclDataPaymentScheduleDto {
    contractRefNo: string | undefined;
    startDate: moment.Moment | undefined;
    component: string | undefined;
    noOfSchedules: number | undefined;
    frequency: string | undefined;
    amount: number | undefined;
    obeEclUploadId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto implements IPagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclDataPaymentScheduleObeEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclDataPaymentScheduleObeEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclDataPaymentScheduleObeEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclDataPaymentScheduleObeEclUploadLookupTableDto[] | undefined;
}

export class ObeEclDataPaymentScheduleObeEclUploadLookupTableDto implements IObeEclDataPaymentScheduleObeEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclDataPaymentScheduleObeEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclDataPaymentScheduleObeEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclDataPaymentScheduleObeEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclDataPaymentScheduleObeEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto implements IPagedResultDtoOfGetObeEclEadInputAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclEadInputAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclEadInputAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclEadInputAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetObeEclEadInputAssumptionForViewDto[] | undefined;
}

export class GetObeEclEadInputAssumptionForViewDto implements IGetObeEclEadInputAssumptionForViewDto {
    obeEclEadInputAssumption!: ObeEclEadInputAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclEadInputAssumption = data["obeEclEadInputAssumption"] ? ObeEclEadInputAssumptionDto.fromJS(data["obeEclEadInputAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclEadInputAssumption"] = this.obeEclEadInputAssumption ? this.obeEclEadInputAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclEadInputAssumptionForViewDto {
    obeEclEadInputAssumption: ObeEclEadInputAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclEadInputAssumptionDto implements IObeEclEadInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    eadGroup!: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.eadGroup = data["eadGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["eadGroup"] = this.eadGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclEadInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    eadGroup: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclEadInputAssumptionForEditOutput implements IGetObeEclEadInputAssumptionForEditOutput {
    obeEclEadInputAssumption!: CreateOrEditObeEclEadInputAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclEadInputAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclEadInputAssumption = data["obeEclEadInputAssumption"] ? CreateOrEditObeEclEadInputAssumptionDto.fromJS(data["obeEclEadInputAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclEadInputAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclEadInputAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclEadInputAssumption"] = this.obeEclEadInputAssumption ? this.obeEclEadInputAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclEadInputAssumptionForEditOutput {
    obeEclEadInputAssumption: CreateOrEditObeEclEadInputAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclEadInputAssumptionDto implements ICreateOrEditObeEclEadInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean;
    eadGroup!: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.eadGroup = data["eadGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["eadGroup"] = this.eadGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclEadInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean;
    eadGroup: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto implements IPagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclEadInputAssumptionObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclEadInputAssumptionObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclEadInputAssumptionObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclEadInputAssumptionObeEclLookupTableDto[] | undefined;
}

export class ObeEclEadInputAssumptionObeEclLookupTableDto implements IObeEclEadInputAssumptionObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclEadInputAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclEadInputAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclEadInputAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclEadInputAssumptionObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclLgdAssumptionForViewDto implements IPagedResultDtoOfGetObeEclLgdAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclLgdAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclLgdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclLgdAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclLgdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclLgdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclLgdAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetObeEclLgdAssumptionForViewDto[] | undefined;
}

export class GetObeEclLgdAssumptionForViewDto implements IGetObeEclLgdAssumptionForViewDto {
    obeEclLgdAssumption!: ObeEclLgdAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclLgdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclLgdAssumption = data["obeEclLgdAssumption"] ? ObeEclLgdAssumptionDto.fromJS(data["obeEclLgdAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclLgdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclLgdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclLgdAssumption"] = this.obeEclLgdAssumption ? this.obeEclLgdAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclLgdAssumptionForViewDto {
    obeEclLgdAssumption: ObeEclLgdAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclLgdAssumptionDto implements IObeEclLgdAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    lgdGroup!: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclLgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.isComputed = data["isComputed"];
            this.lgdGroup = data["lgdGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclLgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclLgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["isComputed"] = this.isComputed;
        data["lgdGroup"] = this.lgdGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclLgdAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    lgdGroup: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclLgdAssumptionForEditOutput implements IGetObeEclLgdAssumptionForEditOutput {
    obeEclLgdAssumption!: CreateOrEditObeEclLgdAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclLgdAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclLgdAssumption = data["obeEclLgdAssumption"] ? CreateOrEditObeEclLgdAssumptionDto.fromJS(data["obeEclLgdAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclLgdAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclLgdAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclLgdAssumption"] = this.obeEclLgdAssumption ? this.obeEclLgdAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclLgdAssumptionForEditOutput {
    obeEclLgdAssumption: CreateOrEditObeEclLgdAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclLgdAssumptionDto implements ICreateOrEditObeEclLgdAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    isComputed!: boolean;
    lgdGroup!: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclLgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.isComputed = data["isComputed"];
            this.lgdGroup = data["lgdGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclLgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclLgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["isComputed"] = this.isComputed;
        data["lgdGroup"] = this.lgdGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclLgdAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    isComputed: boolean;
    lgdGroup: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto implements IPagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclLgdAssumptionObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclLgdAssumptionObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclLgdAssumptionObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclLgdAssumptionObeEclLookupTableDto[] | undefined;
}

export class ObeEclLgdAssumptionObeEclLookupTableDto implements IObeEclLgdAssumptionObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclLgdAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclLgdAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclLgdAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclLgdAssumptionObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto implements IPagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdAssumption12MonthForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdAssumption12MonthForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdAssumption12MonthForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdAssumption12MonthForViewDto[] | undefined;
}

export class GetObeEclPdAssumption12MonthForViewDto implements IGetObeEclPdAssumption12MonthForViewDto {
    obeEclPdAssumption12Month!: ObeEclPdAssumption12MonthDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumption12MonthForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumption12Month = data["obeEclPdAssumption12Month"] ? ObeEclPdAssumption12MonthDto.fromJS(data["obeEclPdAssumption12Month"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumption12MonthForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumption12MonthForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumption12Month"] = this.obeEclPdAssumption12Month ? this.obeEclPdAssumption12Month.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumption12MonthForViewDto {
    obeEclPdAssumption12Month: ObeEclPdAssumption12MonthDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdAssumption12MonthDto implements IObeEclPdAssumption12MonthDto {
    credit!: number | undefined;
    pd!: number | undefined;
    snPMappingEtiCreditPolicy!: string | undefined;
    snPMappingBestFit!: string | undefined;
    requiresGroupApproval!: boolean | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdAssumption12MonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.credit = data["credit"];
            this.pd = data["pd"];
            this.snPMappingEtiCreditPolicy = data["snPMappingEtiCreditPolicy"];
            this.snPMappingBestFit = data["snPMappingBestFit"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumption12MonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumption12MonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["credit"] = this.credit;
        data["pd"] = this.pd;
        data["snPMappingEtiCreditPolicy"] = this.snPMappingEtiCreditPolicy;
        data["snPMappingBestFit"] = this.snPMappingBestFit;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdAssumption12MonthDto {
    credit: number | undefined;
    pd: number | undefined;
    snPMappingEtiCreditPolicy: string | undefined;
    snPMappingBestFit: string | undefined;
    requiresGroupApproval: boolean | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdAssumption12MonthForEditOutput implements IGetObeEclPdAssumption12MonthForEditOutput {
    obeEclPdAssumption12Month!: CreateOrEditObeEclPdAssumption12MonthDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumption12MonthForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumption12Month = data["obeEclPdAssumption12Month"] ? CreateOrEditObeEclPdAssumption12MonthDto.fromJS(data["obeEclPdAssumption12Month"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumption12MonthForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumption12MonthForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumption12Month"] = this.obeEclPdAssumption12Month ? this.obeEclPdAssumption12Month.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumption12MonthForEditOutput {
    obeEclPdAssumption12Month: CreateOrEditObeEclPdAssumption12MonthDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdAssumption12MonthDto implements ICreateOrEditObeEclPdAssumption12MonthDto {
    credit!: number;
    pd!: number | undefined;
    snPMappingEtiCreditPolicy!: string | undefined;
    snPMappingBestFit!: string | undefined;
    requiresGroupApproval!: boolean;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdAssumption12MonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.credit = data["credit"];
            this.pd = data["pd"];
            this.snPMappingEtiCreditPolicy = data["snPMappingEtiCreditPolicy"];
            this.snPMappingBestFit = data["snPMappingBestFit"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdAssumption12MonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdAssumption12MonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["credit"] = this.credit;
        data["pd"] = this.pd;
        data["snPMappingEtiCreditPolicy"] = this.snPMappingEtiCreditPolicy;
        data["snPMappingBestFit"] = this.snPMappingBestFit;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdAssumption12MonthDto {
    credit: number;
    pd: number | undefined;
    snPMappingEtiCreditPolicy: string | undefined;
    snPMappingBestFit: string | undefined;
    requiresGroupApproval: boolean;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdAssumption12MonthObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdAssumption12MonthObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdAssumption12MonthObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdAssumption12MonthObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdAssumption12MonthObeEclLookupTableDto implements IObeEclPdAssumption12MonthObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdAssumption12MonthObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumption12MonthObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumption12MonthObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdAssumption12MonthObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto implements IPagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdAssumptionMacroeconomicInputsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdAssumptionMacroeconomicInputsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdAssumptionMacroeconomicInputsForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdAssumptionMacroeconomicInputsForViewDto[] | undefined;
}

export class GetObeEclPdAssumptionMacroeconomicInputsForViewDto implements IGetObeEclPdAssumptionMacroeconomicInputsForViewDto {
    obeEclPdAssumptionMacroeconomicInputs!: ObeEclPdAssumptionMacroeconomicInputsDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionMacroeconomicInputsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionMacroeconomicInputs = data["obeEclPdAssumptionMacroeconomicInputs"] ? ObeEclPdAssumptionMacroeconomicInputsDto.fromJS(data["obeEclPdAssumptionMacroeconomicInputs"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionMacroeconomicInputsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionMacroeconomicInputsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionMacroeconomicInputs"] = this.obeEclPdAssumptionMacroeconomicInputs ? this.obeEclPdAssumptionMacroeconomicInputs.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionMacroeconomicInputsForViewDto {
    obeEclPdAssumptionMacroeconomicInputs: ObeEclPdAssumptionMacroeconomicInputsDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdAssumptionMacroeconomicInputsDto implements IObeEclPdAssumptionMacroeconomicInputsDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdAssumptionMacroeconomicInputsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionMacroeconomicInputsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionMacroeconomicInputsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdAssumptionMacroeconomicInputsDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdAssumptionMacroeconomicInputsForEditOutput implements IGetObeEclPdAssumptionMacroeconomicInputsForEditOutput {
    obeEclPdAssumptionMacroeconomicInputs!: CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionMacroeconomicInputsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionMacroeconomicInputs = data["obeEclPdAssumptionMacroeconomicInputs"] ? CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto.fromJS(data["obeEclPdAssumptionMacroeconomicInputs"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionMacroeconomicInputsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionMacroeconomicInputsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionMacroeconomicInputs"] = this.obeEclPdAssumptionMacroeconomicInputs ? this.obeEclPdAssumptionMacroeconomicInputs.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionMacroeconomicInputsForEditOutput {
    obeEclPdAssumptionMacroeconomicInputs: CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto implements ICreateOrEditObeEclPdAssumptionMacroeconomicInputsDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdAssumptionMacroeconomicInputsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdAssumptionMacroeconomicInputsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdAssumptionMacroeconomicInputsDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto implements IObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdAssumptionMacroeconomicInputsObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto implements IPagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdAssumptionMacroeconomicProjectionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdAssumptionMacroeconomicProjectionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdAssumptionMacroeconomicProjectionForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdAssumptionMacroeconomicProjectionForViewDto[] | undefined;
}

export class GetObeEclPdAssumptionMacroeconomicProjectionForViewDto implements IGetObeEclPdAssumptionMacroeconomicProjectionForViewDto {
    obeEclPdAssumptionMacroeconomicProjection!: ObeEclPdAssumptionMacroeconomicProjectionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionMacroeconomicProjection = data["obeEclPdAssumptionMacroeconomicProjection"] ? ObeEclPdAssumptionMacroeconomicProjectionDto.fromJS(data["obeEclPdAssumptionMacroeconomicProjection"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionMacroeconomicProjection"] = this.obeEclPdAssumptionMacroeconomicProjection ? this.obeEclPdAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionMacroeconomicProjectionForViewDto {
    obeEclPdAssumptionMacroeconomicProjection: ObeEclPdAssumptionMacroeconomicProjectionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdAssumptionMacroeconomicProjectionDto implements IObeEclPdAssumptionMacroeconomicProjectionDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdAssumptionMacroeconomicProjectionDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput implements IGetObeEclPdAssumptionMacroeconomicProjectionForEditOutput {
    obeEclPdAssumptionMacroeconomicProjection!: CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionMacroeconomicProjectionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionMacroeconomicProjection = data["obeEclPdAssumptionMacroeconomicProjection"] ? CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto.fromJS(data["obeEclPdAssumptionMacroeconomicProjection"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionMacroeconomicProjectionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionMacroeconomicProjection"] = this.obeEclPdAssumptionMacroeconomicProjection ? this.obeEclPdAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionMacroeconomicProjectionForEditOutput {
    obeEclPdAssumptionMacroeconomicProjection: CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto implements ICreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdAssumptionMacroeconomicProjectionDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto implements IObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdAssumptionMacroeconomicProjectionObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto implements IPagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdAssumptionNonInternalModelForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdAssumptionNonInternalModelForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdAssumptionNonInternalModelForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdAssumptionNonInternalModelForViewDto[] | undefined;
}

export class GetObeEclPdAssumptionNonInternalModelForViewDto implements IGetObeEclPdAssumptionNonInternalModelForViewDto {
    obeEclPdAssumptionNonInternalModel!: ObeEclPdAssumptionNonInternalModelDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionNonInternalModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionNonInternalModel = data["obeEclPdAssumptionNonInternalModel"] ? ObeEclPdAssumptionNonInternalModelDto.fromJS(data["obeEclPdAssumptionNonInternalModel"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionNonInternalModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionNonInternalModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionNonInternalModel"] = this.obeEclPdAssumptionNonInternalModel ? this.obeEclPdAssumptionNonInternalModel.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionNonInternalModelForViewDto {
    obeEclPdAssumptionNonInternalModel: ObeEclPdAssumptionNonInternalModelDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdAssumptionNonInternalModelDto implements IObeEclPdAssumptionNonInternalModelDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdAssumptionNonInternalModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionNonInternalModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionNonInternalModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdAssumptionNonInternalModelDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdAssumptionNonInternalModelForEditOutput implements IGetObeEclPdAssumptionNonInternalModelForEditOutput {
    obeEclPdAssumptionNonInternalModel!: CreateOrEditObeEclPdAssumptionNonInternalModelDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionNonInternalModelForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionNonInternalModel = data["obeEclPdAssumptionNonInternalModel"] ? CreateOrEditObeEclPdAssumptionNonInternalModelDto.fromJS(data["obeEclPdAssumptionNonInternalModel"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionNonInternalModelForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionNonInternalModelForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionNonInternalModel"] = this.obeEclPdAssumptionNonInternalModel ? this.obeEclPdAssumptionNonInternalModel.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionNonInternalModelForEditOutput {
    obeEclPdAssumptionNonInternalModel: CreateOrEditObeEclPdAssumptionNonInternalModelDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdAssumptionNonInternalModelDto implements ICreateOrEditObeEclPdAssumptionNonInternalModelDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdAssumptionNonInternalModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdAssumptionNonInternalModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdAssumptionNonInternalModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdAssumptionNonInternalModelDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdAssumptionNonInternalModelObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdAssumptionNonInternalModelObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdAssumptionNonInternalModelObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdAssumptionNonInternalModelObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdAssumptionNonInternalModelObeEclLookupTableDto implements IObeEclPdAssumptionNonInternalModelObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdAssumptionNonInternalModelObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionNonInternalModelObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionNonInternalModelObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdAssumptionNonInternalModelObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto implements IPagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdAssumptionNplIndexForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdAssumptionNplIndexForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdAssumptionNplIndexForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdAssumptionNplIndexForViewDto[] | undefined;
}

export class GetObeEclPdAssumptionNplIndexForViewDto implements IGetObeEclPdAssumptionNplIndexForViewDto {
    obeEclPdAssumptionNplIndex!: ObeEclPdAssumptionNplIndexDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionNplIndex = data["obeEclPdAssumptionNplIndex"] ? ObeEclPdAssumptionNplIndexDto.fromJS(data["obeEclPdAssumptionNplIndex"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionNplIndex"] = this.obeEclPdAssumptionNplIndex ? this.obeEclPdAssumptionNplIndex.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionNplIndexForViewDto {
    obeEclPdAssumptionNplIndex: ObeEclPdAssumptionNplIndexDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdAssumptionNplIndexDto implements IObeEclPdAssumptionNplIndexDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdAssumptionNplIndexDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdAssumptionNplIndexForEditOutput implements IGetObeEclPdAssumptionNplIndexForEditOutput {
    obeEclPdAssumptionNplIndex!: CreateOrEditObeEclPdAssumptionNplIndexDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionNplIndexForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumptionNplIndex = data["obeEclPdAssumptionNplIndex"] ? CreateOrEditObeEclPdAssumptionNplIndexDto.fromJS(data["obeEclPdAssumptionNplIndex"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionNplIndexForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionNplIndexForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumptionNplIndex"] = this.obeEclPdAssumptionNplIndex ? this.obeEclPdAssumptionNplIndex.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionNplIndexForEditOutput {
    obeEclPdAssumptionNplIndex: CreateOrEditObeEclPdAssumptionNplIndexDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdAssumptionNplIndexDto implements ICreateOrEditObeEclPdAssumptionNplIndexDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdAssumptionNplIndexDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdAssumptionNplIndexObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdAssumptionNplIndexObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdAssumptionNplIndexObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdAssumptionNplIndexObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdAssumptionNplIndexObeEclLookupTableDto implements IObeEclPdAssumptionNplIndexObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdAssumptionNplIndexObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionNplIndexObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionNplIndexObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdAssumptionNplIndexObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdAssumptionForViewDto implements IPagedResultDtoOfGetObeEclPdAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdAssumptionForViewDto[] | undefined;
}

export class GetObeEclPdAssumptionForViewDto implements IGetObeEclPdAssumptionForViewDto {
    obeEclPdAssumption!: ObeEclPdAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumption = data["obeEclPdAssumption"] ? ObeEclPdAssumptionDto.fromJS(data["obeEclPdAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumption"] = this.obeEclPdAssumption ? this.obeEclPdAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionForViewDto {
    obeEclPdAssumption: ObeEclPdAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdAssumptionDto implements IObeEclPdAssumptionDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdAssumptionDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdAssumptionForEditOutput implements IGetObeEclPdAssumptionForEditOutput {
    obeEclPdAssumption!: CreateOrEditObeEclPdAssumptionDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdAssumption = data["obeEclPdAssumption"] ? CreateOrEditObeEclPdAssumptionDto.fromJS(data["obeEclPdAssumption"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdAssumption"] = this.obeEclPdAssumption ? this.obeEclPdAssumption.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdAssumptionForEditOutput {
    obeEclPdAssumption: CreateOrEditObeEclPdAssumptionDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdAssumptionDto implements ICreateOrEditObeEclPdAssumptionDto {
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdAssumptionDto {
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdAssumptionObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdAssumptionObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdAssumptionObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdAssumptionObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdAssumptionObeEclLookupTableDto implements IObeEclPdAssumptionObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdAssumptionObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdAssumptionObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdAssumptionObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdAssumptionObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto implements IPagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclPdSnPCummulativeDefaultRateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclPdSnPCummulativeDefaultRateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclPdSnPCummulativeDefaultRateForViewDto {
    totalCount: number | undefined;
    items: GetObeEclPdSnPCummulativeDefaultRateForViewDto[] | undefined;
}

export class GetObeEclPdSnPCummulativeDefaultRateForViewDto implements IGetObeEclPdSnPCummulativeDefaultRateForViewDto {
    obeEclPdSnPCummulativeDefaultRate!: ObeEclPdSnPCummulativeDefaultRateDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdSnPCummulativeDefaultRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdSnPCummulativeDefaultRate = data["obeEclPdSnPCummulativeDefaultRate"] ? ObeEclPdSnPCummulativeDefaultRateDto.fromJS(data["obeEclPdSnPCummulativeDefaultRate"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdSnPCummulativeDefaultRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdSnPCummulativeDefaultRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdSnPCummulativeDefaultRate"] = this.obeEclPdSnPCummulativeDefaultRate ? this.obeEclPdSnPCummulativeDefaultRate.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdSnPCummulativeDefaultRateForViewDto {
    obeEclPdSnPCummulativeDefaultRate: ObeEclPdSnPCummulativeDefaultRateDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclPdSnPCummulativeDefaultRateDto implements IObeEclPdSnPCummulativeDefaultRateDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    requiresGroupApproval!: boolean | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclPdSnPCummulativeDefaultRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclPdSnPCummulativeDefaultRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdSnPCummulativeDefaultRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclPdSnPCummulativeDefaultRateDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    requiresGroupApproval: boolean | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclPdSnPCummulativeDefaultRateForEditOutput implements IGetObeEclPdSnPCummulativeDefaultRateForEditOutput {
    obeEclPdSnPCummulativeDefaultRate!: CreateOrEditObeEclPdSnPCummulativeDefaultRateDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclPdSnPCummulativeDefaultRateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclPdSnPCummulativeDefaultRate = data["obeEclPdSnPCummulativeDefaultRate"] ? CreateOrEditObeEclPdSnPCummulativeDefaultRateDto.fromJS(data["obeEclPdSnPCummulativeDefaultRate"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclPdSnPCummulativeDefaultRateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclPdSnPCummulativeDefaultRateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclPdSnPCummulativeDefaultRate"] = this.obeEclPdSnPCummulativeDefaultRate ? this.obeEclPdSnPCummulativeDefaultRate.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclPdSnPCummulativeDefaultRateForEditOutput {
    obeEclPdSnPCummulativeDefaultRate: CreateOrEditObeEclPdSnPCummulativeDefaultRateDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclPdSnPCummulativeDefaultRateDto implements ICreateOrEditObeEclPdSnPCummulativeDefaultRateDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    requiresGroupApproval!: boolean;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclPdSnPCummulativeDefaultRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclPdSnPCummulativeDefaultRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclPdSnPCummulativeDefaultRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclPdSnPCummulativeDefaultRateDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    requiresGroupApproval: boolean;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto implements IPagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto[] | undefined;
}

export class ObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto implements IObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclPdSnPCummulativeDefaultRateObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclResultDetailForViewDto implements IPagedResultDtoOfGetObeEclResultDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclResultDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclResultDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclResultDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclResultDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclResultDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclResultDetailForViewDto {
    totalCount: number | undefined;
    items: GetObeEclResultDetailForViewDto[] | undefined;
}

export class GetObeEclResultDetailForViewDto implements IGetObeEclResultDetailForViewDto {
    obeEclResultDetail!: ObeEclResultDetailDto | undefined;
    obeEclTenantId!: string | undefined;
    obeEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetObeEclResultDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclResultDetail = data["obeEclResultDetail"] ? ObeEclResultDetailDto.fromJS(data["obeEclResultDetail"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.obeEclDataLoanBookCustomerName = data["obeEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetObeEclResultDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclResultDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclResultDetail"] = this.obeEclResultDetail ? this.obeEclResultDetail.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["obeEclDataLoanBookCustomerName"] = this.obeEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetObeEclResultDetailForViewDto {
    obeEclResultDetail: ObeEclResultDetailDto | undefined;
    obeEclTenantId: string | undefined;
    obeEclDataLoanBookCustomerName: string | undefined;
}

export class ObeEclResultDetailDto implements IObeEclResultDetailDto {
    contractID!: string | undefined;
    accountNo!: string | undefined;
    customerNo!: string | undefined;
    segment!: string | undefined;
    productType!: string | undefined;
    sector!: string | undefined;
    stage!: number | undefined;
    outstandingBalance!: number | undefined;
    preOverrideEclBest!: number | undefined;
    preOverrideEclOptimistic!: number | undefined;
    preOverrideEclDownturn!: number | undefined;
    overrideStage!: number | undefined;
    overrideTTRYears!: number | undefined;
    overrideFSV!: number | undefined;
    overrideOverlay!: number | undefined;
    postOverrideEclBest!: number | undefined;
    postOverrideEclOptimistic!: number | undefined;
    postOverrideEclDownturn!: number | undefined;
    preOverrideImpairment!: number | undefined;
    postOverrideImpairment!: number | undefined;
    obeEclId!: string | undefined;
    obeEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractID = data["contractID"];
            this.accountNo = data["accountNo"];
            this.customerNo = data["customerNo"];
            this.segment = data["segment"];
            this.productType = data["productType"];
            this.sector = data["sector"];
            this.stage = data["stage"];
            this.outstandingBalance = data["outstandingBalance"];
            this.preOverrideEclBest = data["preOverrideEclBest"];
            this.preOverrideEclOptimistic = data["preOverrideEclOptimistic"];
            this.preOverrideEclDownturn = data["preOverrideEclDownturn"];
            this.overrideStage = data["overrideStage"];
            this.overrideTTRYears = data["overrideTTRYears"];
            this.overrideFSV = data["overrideFSV"];
            this.overrideOverlay = data["overrideOverlay"];
            this.postOverrideEclBest = data["postOverrideEclBest"];
            this.postOverrideEclOptimistic = data["postOverrideEclOptimistic"];
            this.postOverrideEclDownturn = data["postOverrideEclDownturn"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.obeEclId = data["obeEclId"];
            this.obeEclDataLoanBookId = data["obeEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractID"] = this.contractID;
        data["accountNo"] = this.accountNo;
        data["customerNo"] = this.customerNo;
        data["segment"] = this.segment;
        data["productType"] = this.productType;
        data["sector"] = this.sector;
        data["stage"] = this.stage;
        data["outstandingBalance"] = this.outstandingBalance;
        data["preOverrideEclBest"] = this.preOverrideEclBest;
        data["preOverrideEclOptimistic"] = this.preOverrideEclOptimistic;
        data["preOverrideEclDownturn"] = this.preOverrideEclDownturn;
        data["overrideStage"] = this.overrideStage;
        data["overrideTTRYears"] = this.overrideTTRYears;
        data["overrideFSV"] = this.overrideFSV;
        data["overrideOverlay"] = this.overrideOverlay;
        data["postOverrideEclBest"] = this.postOverrideEclBest;
        data["postOverrideEclOptimistic"] = this.postOverrideEclOptimistic;
        data["postOverrideEclDownturn"] = this.postOverrideEclDownturn;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["obeEclId"] = this.obeEclId;
        data["obeEclDataLoanBookId"] = this.obeEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclResultDetailDto {
    contractID: string | undefined;
    accountNo: string | undefined;
    customerNo: string | undefined;
    segment: string | undefined;
    productType: string | undefined;
    sector: string | undefined;
    stage: number | undefined;
    outstandingBalance: number | undefined;
    preOverrideEclBest: number | undefined;
    preOverrideEclOptimistic: number | undefined;
    preOverrideEclDownturn: number | undefined;
    overrideStage: number | undefined;
    overrideTTRYears: number | undefined;
    overrideFSV: number | undefined;
    overrideOverlay: number | undefined;
    postOverrideEclBest: number | undefined;
    postOverrideEclOptimistic: number | undefined;
    postOverrideEclDownturn: number | undefined;
    preOverrideImpairment: number | undefined;
    postOverrideImpairment: number | undefined;
    obeEclId: string | undefined;
    obeEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetObeEclResultDetailForEditOutput implements IGetObeEclResultDetailForEditOutput {
    obeEclResultDetail!: CreateOrEditObeEclResultDetailDto | undefined;
    obeEclTenantId!: string | undefined;
    obeEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetObeEclResultDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclResultDetail = data["obeEclResultDetail"] ? CreateOrEditObeEclResultDetailDto.fromJS(data["obeEclResultDetail"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.obeEclDataLoanBookCustomerName = data["obeEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetObeEclResultDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclResultDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclResultDetail"] = this.obeEclResultDetail ? this.obeEclResultDetail.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["obeEclDataLoanBookCustomerName"] = this.obeEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetObeEclResultDetailForEditOutput {
    obeEclResultDetail: CreateOrEditObeEclResultDetailDto | undefined;
    obeEclTenantId: string | undefined;
    obeEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditObeEclResultDetailDto implements ICreateOrEditObeEclResultDetailDto {
    contractID!: string | undefined;
    accountNo!: string | undefined;
    customerNo!: string | undefined;
    segment!: string | undefined;
    productType!: string | undefined;
    sector!: string | undefined;
    stage!: number | undefined;
    outstandingBalance!: number | undefined;
    preOverrideEclBest!: number | undefined;
    preOverrideEclOptimistic!: number | undefined;
    preOverrideEclDownturn!: number | undefined;
    overrideStage!: number | undefined;
    overrideTTRYears!: number | undefined;
    overrideFSV!: number | undefined;
    overrideOverlay!: number | undefined;
    postOverrideEclBest!: number | undefined;
    postOverrideEclOptimistic!: number | undefined;
    postOverrideEclDownturn!: number | undefined;
    preOverrideImpairment!: number | undefined;
    postOverrideImpairment!: number | undefined;
    obeEclId!: string | undefined;
    obeEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractID = data["contractID"];
            this.accountNo = data["accountNo"];
            this.customerNo = data["customerNo"];
            this.segment = data["segment"];
            this.productType = data["productType"];
            this.sector = data["sector"];
            this.stage = data["stage"];
            this.outstandingBalance = data["outstandingBalance"];
            this.preOverrideEclBest = data["preOverrideEclBest"];
            this.preOverrideEclOptimistic = data["preOverrideEclOptimistic"];
            this.preOverrideEclDownturn = data["preOverrideEclDownturn"];
            this.overrideStage = data["overrideStage"];
            this.overrideTTRYears = data["overrideTTRYears"];
            this.overrideFSV = data["overrideFSV"];
            this.overrideOverlay = data["overrideOverlay"];
            this.postOverrideEclBest = data["postOverrideEclBest"];
            this.postOverrideEclOptimistic = data["postOverrideEclOptimistic"];
            this.postOverrideEclDownturn = data["postOverrideEclDownturn"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.obeEclId = data["obeEclId"];
            this.obeEclDataLoanBookId = data["obeEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractID"] = this.contractID;
        data["accountNo"] = this.accountNo;
        data["customerNo"] = this.customerNo;
        data["segment"] = this.segment;
        data["productType"] = this.productType;
        data["sector"] = this.sector;
        data["stage"] = this.stage;
        data["outstandingBalance"] = this.outstandingBalance;
        data["preOverrideEclBest"] = this.preOverrideEclBest;
        data["preOverrideEclOptimistic"] = this.preOverrideEclOptimistic;
        data["preOverrideEclDownturn"] = this.preOverrideEclDownturn;
        data["overrideStage"] = this.overrideStage;
        data["overrideTTRYears"] = this.overrideTTRYears;
        data["overrideFSV"] = this.overrideFSV;
        data["overrideOverlay"] = this.overrideOverlay;
        data["postOverrideEclBest"] = this.postOverrideEclBest;
        data["postOverrideEclOptimistic"] = this.postOverrideEclOptimistic;
        data["postOverrideEclDownturn"] = this.postOverrideEclDownturn;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["obeEclId"] = this.obeEclId;
        data["obeEclDataLoanBookId"] = this.obeEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclResultDetailDto {
    contractID: string | undefined;
    accountNo: string | undefined;
    customerNo: string | undefined;
    segment: string | undefined;
    productType: string | undefined;
    sector: string | undefined;
    stage: number | undefined;
    outstandingBalance: number | undefined;
    preOverrideEclBest: number | undefined;
    preOverrideEclOptimistic: number | undefined;
    preOverrideEclDownturn: number | undefined;
    overrideStage: number | undefined;
    overrideTTRYears: number | undefined;
    overrideFSV: number | undefined;
    overrideOverlay: number | undefined;
    postOverrideEclBest: number | undefined;
    postOverrideEclOptimistic: number | undefined;
    postOverrideEclDownturn: number | undefined;
    preOverrideImpairment: number | undefined;
    postOverrideImpairment: number | undefined;
    obeEclId: string | undefined;
    obeEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto implements IPagedResultDtoOfObeEclResultDetailObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclResultDetailObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclResultDetailObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclResultDetailObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclResultDetailObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclResultDetailObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclResultDetailObeEclLookupTableDto[] | undefined;
}

export class ObeEclResultDetailObeEclLookupTableDto implements IObeEclResultDetailObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclResultDetailObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclResultDetailObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultDetailObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclResultDetailObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto implements IPagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclResultDetailObeEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclResultDetailObeEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclResultDetailObeEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclResultDetailObeEclDataLoanBookLookupTableDto[] | undefined;
}

export class ObeEclResultDetailObeEclDataLoanBookLookupTableDto implements IObeEclResultDetailObeEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclResultDetailObeEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclResultDetailObeEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultDetailObeEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclResultDetailObeEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto implements IPagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclResultSummaryKeyInputForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclResultSummaryKeyInputForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclResultSummaryKeyInputForViewDto {
    totalCount: number | undefined;
    items: GetObeEclResultSummaryKeyInputForViewDto[] | undefined;
}

export class GetObeEclResultSummaryKeyInputForViewDto implements IGetObeEclResultSummaryKeyInputForViewDto {
    obeEclResultSummaryKeyInput!: ObeEclResultSummaryKeyInputDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclResultSummaryKeyInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclResultSummaryKeyInput = data["obeEclResultSummaryKeyInput"] ? ObeEclResultSummaryKeyInputDto.fromJS(data["obeEclResultSummaryKeyInput"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclResultSummaryKeyInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclResultSummaryKeyInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclResultSummaryKeyInput"] = this.obeEclResultSummaryKeyInput ? this.obeEclResultSummaryKeyInput.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclResultSummaryKeyInputForViewDto {
    obeEclResultSummaryKeyInput: ObeEclResultSummaryKeyInputDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclResultSummaryKeyInputDto implements IObeEclResultSummaryKeyInputDto {
    pdGrouping!: string | undefined;
    exposure!: number | undefined;
    collateral!: number | undefined;
    unsecuredPercentage!: number | undefined;
    percentageOfBook!: number | undefined;
    months6CummulativeBestPDs!: number | undefined;
    months12CummulativeBestPDs!: number | undefined;
    months24CummulativeBestPDs!: number | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclResultSummaryKeyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdGrouping = data["pdGrouping"];
            this.exposure = data["exposure"];
            this.collateral = data["collateral"];
            this.unsecuredPercentage = data["unsecuredPercentage"];
            this.percentageOfBook = data["percentageOfBook"];
            this.months6CummulativeBestPDs = data["months6CummulativeBestPDs"];
            this.months12CummulativeBestPDs = data["months12CummulativeBestPDs"];
            this.months24CummulativeBestPDs = data["months24CummulativeBestPDs"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclResultSummaryKeyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultSummaryKeyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdGrouping"] = this.pdGrouping;
        data["exposure"] = this.exposure;
        data["collateral"] = this.collateral;
        data["unsecuredPercentage"] = this.unsecuredPercentage;
        data["percentageOfBook"] = this.percentageOfBook;
        data["months6CummulativeBestPDs"] = this.months6CummulativeBestPDs;
        data["months12CummulativeBestPDs"] = this.months12CummulativeBestPDs;
        data["months24CummulativeBestPDs"] = this.months24CummulativeBestPDs;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclResultSummaryKeyInputDto {
    pdGrouping: string | undefined;
    exposure: number | undefined;
    collateral: number | undefined;
    unsecuredPercentage: number | undefined;
    percentageOfBook: number | undefined;
    months6CummulativeBestPDs: number | undefined;
    months12CummulativeBestPDs: number | undefined;
    months24CummulativeBestPDs: number | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class GetObeEclResultSummaryKeyInputForEditOutput implements IGetObeEclResultSummaryKeyInputForEditOutput {
    obeEclResultSummaryKeyInput!: CreateOrEditObeEclResultSummaryKeyInputDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclResultSummaryKeyInputForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclResultSummaryKeyInput = data["obeEclResultSummaryKeyInput"] ? CreateOrEditObeEclResultSummaryKeyInputDto.fromJS(data["obeEclResultSummaryKeyInput"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclResultSummaryKeyInputForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclResultSummaryKeyInputForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclResultSummaryKeyInput"] = this.obeEclResultSummaryKeyInput ? this.obeEclResultSummaryKeyInput.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclResultSummaryKeyInputForEditOutput {
    obeEclResultSummaryKeyInput: CreateOrEditObeEclResultSummaryKeyInputDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclResultSummaryKeyInputDto implements ICreateOrEditObeEclResultSummaryKeyInputDto {
    pdGrouping!: string | undefined;
    exposure!: number | undefined;
    collateral!: number | undefined;
    unsecuredPercentage!: number | undefined;
    percentageOfBook!: number | undefined;
    months6CummulativeBestPDs!: number | undefined;
    months12CummulativeBestPDs!: number | undefined;
    months24CummulativeBestPDs!: number | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclResultSummaryKeyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdGrouping = data["pdGrouping"];
            this.exposure = data["exposure"];
            this.collateral = data["collateral"];
            this.unsecuredPercentage = data["unsecuredPercentage"];
            this.percentageOfBook = data["percentageOfBook"];
            this.months6CummulativeBestPDs = data["months6CummulativeBestPDs"];
            this.months12CummulativeBestPDs = data["months12CummulativeBestPDs"];
            this.months24CummulativeBestPDs = data["months24CummulativeBestPDs"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclResultSummaryKeyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclResultSummaryKeyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdGrouping"] = this.pdGrouping;
        data["exposure"] = this.exposure;
        data["collateral"] = this.collateral;
        data["unsecuredPercentage"] = this.unsecuredPercentage;
        data["percentageOfBook"] = this.percentageOfBook;
        data["months6CummulativeBestPDs"] = this.months6CummulativeBestPDs;
        data["months12CummulativeBestPDs"] = this.months12CummulativeBestPDs;
        data["months24CummulativeBestPDs"] = this.months24CummulativeBestPDs;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclResultSummaryKeyInputDto {
    pdGrouping: string | undefined;
    exposure: number | undefined;
    collateral: number | undefined;
    unsecuredPercentage: number | undefined;
    percentageOfBook: number | undefined;
    months6CummulativeBestPDs: number | undefined;
    months12CummulativeBestPDs: number | undefined;
    months24CummulativeBestPDs: number | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto implements IPagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclResultSummaryKeyInputObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclResultSummaryKeyInputObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclResultSummaryKeyInputObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclResultSummaryKeyInputObeEclLookupTableDto[] | undefined;
}

export class ObeEclResultSummaryKeyInputObeEclLookupTableDto implements IObeEclResultSummaryKeyInputObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclResultSummaryKeyInputObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclResultSummaryKeyInputObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultSummaryKeyInputObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclResultSummaryKeyInputObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto implements IPagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclResultSummaryTopExposureForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclResultSummaryTopExposureForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclResultSummaryTopExposureForViewDto {
    totalCount: number | undefined;
    items: GetObeEclResultSummaryTopExposureForViewDto[] | undefined;
}

export class GetObeEclResultSummaryTopExposureForViewDto implements IGetObeEclResultSummaryTopExposureForViewDto {
    obeEclResultSummaryTopExposure!: ObeEclResultSummaryTopExposureDto | undefined;
    obeEclTenantId!: string | undefined;
    obeEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetObeEclResultSummaryTopExposureForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclResultSummaryTopExposure = data["obeEclResultSummaryTopExposure"] ? ObeEclResultSummaryTopExposureDto.fromJS(data["obeEclResultSummaryTopExposure"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.obeEclDataLoanBookCustomerName = data["obeEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetObeEclResultSummaryTopExposureForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclResultSummaryTopExposureForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclResultSummaryTopExposure"] = this.obeEclResultSummaryTopExposure ? this.obeEclResultSummaryTopExposure.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["obeEclDataLoanBookCustomerName"] = this.obeEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetObeEclResultSummaryTopExposureForViewDto {
    obeEclResultSummaryTopExposure: ObeEclResultSummaryTopExposureDto | undefined;
    obeEclTenantId: string | undefined;
    obeEclDataLoanBookCustomerName: string | undefined;
}

export class ObeEclResultSummaryTopExposureDto implements IObeEclResultSummaryTopExposureDto {
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    obeEclId!: string | undefined;
    obeEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclResultSummaryTopExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.obeEclId = data["obeEclId"];
            this.obeEclDataLoanBookId = data["obeEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclResultSummaryTopExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultSummaryTopExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["obeEclId"] = this.obeEclId;
        data["obeEclDataLoanBookId"] = this.obeEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclResultSummaryTopExposureDto {
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    obeEclId: string | undefined;
    obeEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetObeEclResultSummaryTopExposureForEditOutput implements IGetObeEclResultSummaryTopExposureForEditOutput {
    obeEclResultSummaryTopExposure!: CreateOrEditObeEclResultSummaryTopExposureDto | undefined;
    obeEclTenantId!: string | undefined;
    obeEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetObeEclResultSummaryTopExposureForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclResultSummaryTopExposure = data["obeEclResultSummaryTopExposure"] ? CreateOrEditObeEclResultSummaryTopExposureDto.fromJS(data["obeEclResultSummaryTopExposure"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
            this.obeEclDataLoanBookCustomerName = data["obeEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetObeEclResultSummaryTopExposureForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclResultSummaryTopExposureForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclResultSummaryTopExposure"] = this.obeEclResultSummaryTopExposure ? this.obeEclResultSummaryTopExposure.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        data["obeEclDataLoanBookCustomerName"] = this.obeEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetObeEclResultSummaryTopExposureForEditOutput {
    obeEclResultSummaryTopExposure: CreateOrEditObeEclResultSummaryTopExposureDto | undefined;
    obeEclTenantId: string | undefined;
    obeEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditObeEclResultSummaryTopExposureDto implements ICreateOrEditObeEclResultSummaryTopExposureDto {
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    obeEclId!: string | undefined;
    obeEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclResultSummaryTopExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.obeEclId = data["obeEclId"];
            this.obeEclDataLoanBookId = data["obeEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclResultSummaryTopExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclResultSummaryTopExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["obeEclId"] = this.obeEclId;
        data["obeEclDataLoanBookId"] = this.obeEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclResultSummaryTopExposureDto {
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    obeEclId: string | undefined;
    obeEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto implements IPagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclResultSummaryTopExposureObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclResultSummaryTopExposureObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclResultSummaryTopExposureObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclResultSummaryTopExposureObeEclLookupTableDto[] | undefined;
}

export class ObeEclResultSummaryTopExposureObeEclLookupTableDto implements IObeEclResultSummaryTopExposureObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclResultSummaryTopExposureObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclResultSummaryTopExposureObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultSummaryTopExposureObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclResultSummaryTopExposureObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto implements IPagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto[] | undefined;
}

export class ObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto implements IObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclResultSummaryTopExposureObeEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclForViewDto implements IPagedResultDtoOfGetObeEclForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclForViewDto {
    totalCount: number | undefined;
    items: GetObeEclForViewDto[] | undefined;
}

export class GetObeEclForViewDto implements IGetObeEclForViewDto {
    obeEcl!: ObeEclDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEcl = data["obeEcl"] ? ObeEclDto.fromJS(data["obeEcl"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEcl"] = this.obeEcl ? this.obeEcl.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclForViewDto {
    obeEcl: ObeEclDto | undefined;
    userName: string | undefined;
}

export class ObeEclDto implements IObeEclDto {
    reportingDate!: moment.Moment | undefined;
    closedDate!: moment.Moment | undefined;
    isApproved!: boolean | undefined;
    status!: EclStatusEnum | undefined;
    closedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.closedDate = data["closedDate"] ? moment(data["closedDate"].toString()) : <any>undefined;
            this.isApproved = data["isApproved"];
            this.status = data["status"];
            this.closedByUserId = data["closedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["closedDate"] = this.closedDate ? this.closedDate.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["closedByUserId"] = this.closedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclDto {
    reportingDate: moment.Moment | undefined;
    closedDate: moment.Moment | undefined;
    isApproved: boolean | undefined;
    status: EclStatusEnum | undefined;
    closedByUserId: number | undefined;
    id: string | undefined;
}

export class GetObeEclForEditOutput implements IGetObeEclForEditOutput {
    obeEcl!: CreateOrEditObeEclDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEcl = data["obeEcl"] ? CreateOrEditObeEclDto.fromJS(data["obeEcl"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEcl"] = this.obeEcl ? this.obeEcl.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclForEditOutput {
    obeEcl: CreateOrEditObeEclDto | undefined;
    userName: string | undefined;
}

export class CreateOrEditObeEclDto implements ICreateOrEditObeEclDto {
    reportingDate!: moment.Moment;
    closedDate!: moment.Moment | undefined;
    isApproved!: boolean;
    status!: EclStatusEnum | undefined;
    closedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.closedDate = data["closedDate"] ? moment(data["closedDate"].toString()) : <any>undefined;
            this.isApproved = data["isApproved"];
            this.status = data["status"];
            this.closedByUserId = data["closedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["closedDate"] = this.closedDate ? this.closedDate.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["closedByUserId"] = this.closedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclDto {
    reportingDate: moment.Moment;
    closedDate: moment.Moment | undefined;
    isApproved: boolean;
    status: EclStatusEnum | undefined;
    closedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclUserLookupTableDto implements IPagedResultDtoOfObeEclUserLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclUserLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclUserLookupTableDto[] | undefined;
}

export class ObeEclUserLookupTableDto implements IObeEclUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclSicrApprovalForViewDto implements IPagedResultDtoOfGetObeEclSicrApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclSicrApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclSicrApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclSicrApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclSicrApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclSicrApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclSicrApprovalForViewDto {
    totalCount: number | undefined;
    items: GetObeEclSicrApprovalForViewDto[] | undefined;
}

export class GetObeEclSicrApprovalForViewDto implements IGetObeEclSicrApprovalForViewDto {
    obeEclSicrApproval!: ObeEclSicrApprovalDto | undefined;
    userName!: string | undefined;
    obeEclSicrTenantId!: string | undefined;

    constructor(data?: IGetObeEclSicrApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclSicrApproval = data["obeEclSicrApproval"] ? ObeEclSicrApprovalDto.fromJS(data["obeEclSicrApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.obeEclSicrTenantId = data["obeEclSicrTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclSicrApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclSicrApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclSicrApproval"] = this.obeEclSicrApproval ? this.obeEclSicrApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["obeEclSicrTenantId"] = this.obeEclSicrTenantId;
        return data; 
    }
}

export interface IGetObeEclSicrApprovalForViewDto {
    obeEclSicrApproval: ObeEclSicrApprovalDto | undefined;
    userName: string | undefined;
    obeEclSicrTenantId: string | undefined;
}

export class ObeEclSicrApprovalDto implements IObeEclSicrApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    obeEclSicrId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclSicrApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.obeEclSicrId = data["obeEclSicrId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclSicrApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclSicrApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["obeEclSicrId"] = this.obeEclSicrId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclSicrApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    obeEclSicrId: string | undefined;
    id: string | undefined;
}

export class GetObeEclSicrApprovalForEditOutput implements IGetObeEclSicrApprovalForEditOutput {
    obeEclSicrApproval!: CreateOrEditObeEclSicrApprovalDto | undefined;
    userName!: string | undefined;
    obeEclSicrTenantId!: string | undefined;

    constructor(data?: IGetObeEclSicrApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclSicrApproval = data["obeEclSicrApproval"] ? CreateOrEditObeEclSicrApprovalDto.fromJS(data["obeEclSicrApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.obeEclSicrTenantId = data["obeEclSicrTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclSicrApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclSicrApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclSicrApproval"] = this.obeEclSicrApproval ? this.obeEclSicrApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["obeEclSicrTenantId"] = this.obeEclSicrTenantId;
        return data; 
    }
}

export interface IGetObeEclSicrApprovalForEditOutput {
    obeEclSicrApproval: CreateOrEditObeEclSicrApprovalDto | undefined;
    userName: string | undefined;
    obeEclSicrTenantId: string | undefined;
}

export class CreateOrEditObeEclSicrApprovalDto implements ICreateOrEditObeEclSicrApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    obeEclSicrId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclSicrApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.obeEclSicrId = data["obeEclSicrId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclSicrApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclSicrApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["obeEclSicrId"] = this.obeEclSicrId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclSicrApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    obeEclSicrId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto implements IPagedResultDtoOfObeEclSicrApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclSicrApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclSicrApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclSicrApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclSicrApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclSicrApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclSicrApprovalUserLookupTableDto[] | undefined;
}

export class ObeEclSicrApprovalUserLookupTableDto implements IObeEclSicrApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclSicrApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclSicrApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclSicrApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclSicrApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto implements IPagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclSicrApprovalObeEclSicrLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclSicrApprovalObeEclSicrLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclSicrApprovalObeEclSicrLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclSicrApprovalObeEclSicrLookupTableDto[] | undefined;
}

export class ObeEclSicrApprovalObeEclSicrLookupTableDto implements IObeEclSicrApprovalObeEclSicrLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclSicrApprovalObeEclSicrLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclSicrApprovalObeEclSicrLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclSicrApprovalObeEclSicrLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclSicrApprovalObeEclSicrLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclSicrForViewDto implements IPagedResultDtoOfGetObeEclSicrForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclSicrForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclSicrForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclSicrForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclSicrForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclSicrForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclSicrForViewDto {
    totalCount: number | undefined;
    items: GetObeEclSicrForViewDto[] | undefined;
}

export class GetObeEclSicrForViewDto implements IGetObeEclSicrForViewDto {
    obeEclSicr!: ObeEclSicrDto | undefined;
    obeEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetObeEclSicrForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclSicr = data["obeEclSicr"] ? ObeEclSicrDto.fromJS(data["obeEclSicr"]) : <any>undefined;
            this.obeEclDataLoanBookCustomerName = data["obeEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetObeEclSicrForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclSicrForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclSicr"] = this.obeEclSicr ? this.obeEclSicr.toJSON() : <any>undefined;
        data["obeEclDataLoanBookCustomerName"] = this.obeEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetObeEclSicrForViewDto {
    obeEclSicr: ObeEclSicrDto | undefined;
    obeEclDataLoanBookCustomerName: string | undefined;
}

export class ObeEclSicrDto implements IObeEclSicrDto {
    computedSICR!: number | undefined;
    overrideSICR!: string | undefined;
    overrideComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclSicrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.computedSICR = data["computedSICR"];
            this.overrideSICR = data["overrideSICR"];
            this.overrideComment = data["overrideComment"];
            this.status = data["status"];
            this.obeEclDataLoanBookId = data["obeEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclSicrDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclSicrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["computedSICR"] = this.computedSICR;
        data["overrideSICR"] = this.overrideSICR;
        data["overrideComment"] = this.overrideComment;
        data["status"] = this.status;
        data["obeEclDataLoanBookId"] = this.obeEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclSicrDto {
    computedSICR: number | undefined;
    overrideSICR: string | undefined;
    overrideComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetObeEclSicrForEditOutput implements IGetObeEclSicrForEditOutput {
    obeEclSicr!: CreateOrEditObeEclSicrDto | undefined;
    obeEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetObeEclSicrForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclSicr = data["obeEclSicr"] ? CreateOrEditObeEclSicrDto.fromJS(data["obeEclSicr"]) : <any>undefined;
            this.obeEclDataLoanBookCustomerName = data["obeEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetObeEclSicrForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclSicrForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclSicr"] = this.obeEclSicr ? this.obeEclSicr.toJSON() : <any>undefined;
        data["obeEclDataLoanBookCustomerName"] = this.obeEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetObeEclSicrForEditOutput {
    obeEclSicr: CreateOrEditObeEclSicrDto | undefined;
    obeEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditObeEclSicrDto implements ICreateOrEditObeEclSicrDto {
    computedSICR!: number;
    overrideSICR!: string | undefined;
    overrideComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclSicrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.computedSICR = data["computedSICR"];
            this.overrideSICR = data["overrideSICR"];
            this.overrideComment = data["overrideComment"];
            this.status = data["status"];
            this.obeEclDataLoanBookId = data["obeEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclSicrDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclSicrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["computedSICR"] = this.computedSICR;
        data["overrideSICR"] = this.overrideSICR;
        data["overrideComment"] = this.overrideComment;
        data["status"] = this.status;
        data["obeEclDataLoanBookId"] = this.obeEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclSicrDto {
    computedSICR: number;
    overrideSICR: string | undefined;
    overrideComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto implements IPagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclSicrObeEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclSicrObeEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclSicrObeEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclSicrObeEclDataLoanBookLookupTableDto[] | undefined;
}

export class ObeEclSicrObeEclDataLoanBookLookupTableDto implements IObeEclSicrObeEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclSicrObeEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclSicrObeEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclSicrObeEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclSicrObeEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclUploadApprovalForViewDto implements IPagedResultDtoOfGetObeEclUploadApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclUploadApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclUploadApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclUploadApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclUploadApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclUploadApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclUploadApprovalForViewDto {
    totalCount: number | undefined;
    items: GetObeEclUploadApprovalForViewDto[] | undefined;
}

export class GetObeEclUploadApprovalForViewDto implements IGetObeEclUploadApprovalForViewDto {
    obeEclUploadApproval!: ObeEclUploadApprovalDto | undefined;
    obeEclUploadTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclUploadApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclUploadApproval = data["obeEclUploadApproval"] ? ObeEclUploadApprovalDto.fromJS(data["obeEclUploadApproval"]) : <any>undefined;
            this.obeEclUploadTenantId = data["obeEclUploadTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclUploadApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclUploadApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclUploadApproval"] = this.obeEclUploadApproval ? this.obeEclUploadApproval.toJSON() : <any>undefined;
        data["obeEclUploadTenantId"] = this.obeEclUploadTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclUploadApprovalForViewDto {
    obeEclUploadApproval: ObeEclUploadApprovalDto | undefined;
    obeEclUploadTenantId: string | undefined;
    userName: string | undefined;
}

export class ObeEclUploadApprovalDto implements IObeEclUploadApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclUploadId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclUploadApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.obeEclUploadId = data["obeEclUploadId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclUploadApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclUploadApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["obeEclUploadId"] = this.obeEclUploadId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclUploadApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclUploadId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class GetObeEclUploadApprovalForEditOutput implements IGetObeEclUploadApprovalForEditOutput {
    obeEclUploadApproval!: CreateOrEditObeEclUploadApprovalDto | undefined;
    obeEclUploadTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetObeEclUploadApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclUploadApproval = data["obeEclUploadApproval"] ? CreateOrEditObeEclUploadApprovalDto.fromJS(data["obeEclUploadApproval"]) : <any>undefined;
            this.obeEclUploadTenantId = data["obeEclUploadTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetObeEclUploadApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclUploadApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclUploadApproval"] = this.obeEclUploadApproval ? this.obeEclUploadApproval.toJSON() : <any>undefined;
        data["obeEclUploadTenantId"] = this.obeEclUploadTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetObeEclUploadApprovalForEditOutput {
    obeEclUploadApproval: CreateOrEditObeEclUploadApprovalDto | undefined;
    obeEclUploadTenantId: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditObeEclUploadApprovalDto implements ICreateOrEditObeEclUploadApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclUploadId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclUploadApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.obeEclUploadId = data["obeEclUploadId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclUploadApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclUploadApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["obeEclUploadId"] = this.obeEclUploadId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclUploadApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclUploadId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto implements IPagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclUploadApprovalObeEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclUploadApprovalObeEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclUploadApprovalObeEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclUploadApprovalObeEclUploadLookupTableDto[] | undefined;
}

export class ObeEclUploadApprovalObeEclUploadLookupTableDto implements IObeEclUploadApprovalObeEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclUploadApprovalObeEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclUploadApprovalObeEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclUploadApprovalObeEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclUploadApprovalObeEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto implements IPagedResultDtoOfObeEclUploadApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclUploadApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclUploadApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclUploadApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclUploadApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclUploadApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclUploadApprovalUserLookupTableDto[] | undefined;
}

export class ObeEclUploadApprovalUserLookupTableDto implements IObeEclUploadApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclUploadApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclUploadApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclUploadApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclUploadApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObeEclUploadForViewDto implements IPagedResultDtoOfGetObeEclUploadForViewDto {
    totalCount!: number | undefined;
    items!: GetObeEclUploadForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObeEclUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObeEclUploadForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObeEclUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObeEclUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObeEclUploadForViewDto {
    totalCount: number | undefined;
    items: GetObeEclUploadForViewDto[] | undefined;
}

export class GetObeEclUploadForViewDto implements IGetObeEclUploadForViewDto {
    obeEclUpload!: ObeEclUploadDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclUpload = data["obeEclUpload"] ? ObeEclUploadDto.fromJS(data["obeEclUpload"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclUpload"] = this.obeEclUpload ? this.obeEclUpload.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclUploadForViewDto {
    obeEclUpload: ObeEclUploadDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObeEclUploadDto implements IObeEclUploadDto {
    docType!: UploadDocTypeEnum | undefined;
    uploadComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObeEclUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docType = data["docType"];
            this.uploadComment = data["uploadComment"];
            this.status = data["status"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObeEclUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["uploadComment"] = this.uploadComment;
        data["status"] = this.status;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObeEclUploadDto {
    docType: UploadDocTypeEnum | undefined;
    uploadComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export enum UploadDocTypeEnum {
    General = 0, 
    LoanBook = 1, 
    PaymentSchedule = 2, 
}

export class GetObeEclUploadForEditOutput implements IGetObeEclUploadForEditOutput {
    obeEclUpload!: CreateOrEditObeEclUploadDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObeEclUploadForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obeEclUpload = data["obeEclUpload"] ? CreateOrEditObeEclUploadDto.fromJS(data["obeEclUpload"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObeEclUploadForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObeEclUploadForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obeEclUpload"] = this.obeEclUpload ? this.obeEclUpload.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObeEclUploadForEditOutput {
    obeEclUpload: CreateOrEditObeEclUploadDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObeEclUploadDto implements ICreateOrEditObeEclUploadDto {
    docType!: UploadDocTypeEnum | undefined;
    uploadComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObeEclUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docType = data["docType"];
            this.uploadComment = data["uploadComment"];
            this.status = data["status"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObeEclUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObeEclUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["uploadComment"] = this.uploadComment;
        data["status"] = this.status;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObeEclUploadDto {
    docType: UploadDocTypeEnum | undefined;
    uploadComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObeEclUploadObeEclLookupTableDto implements IPagedResultDtoOfObeEclUploadObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObeEclUploadObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObeEclUploadObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObeEclUploadObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObeEclUploadObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObeEclUploadObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObeEclUploadObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObeEclUploadObeEclLookupTableDto[] | undefined;
}

export class ObeEclUploadObeEclLookupTableDto implements IObeEclUploadObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObeEclUploadObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObeEclUploadObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObeEclUploadObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObeEclUploadObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetObesaleEclResultSummaryForViewDto implements IPagedResultDtoOfGetObesaleEclResultSummaryForViewDto {
    totalCount!: number | undefined;
    items!: GetObesaleEclResultSummaryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetObesaleEclResultSummaryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetObesaleEclResultSummaryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetObesaleEclResultSummaryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetObesaleEclResultSummaryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetObesaleEclResultSummaryForViewDto {
    totalCount: number | undefined;
    items: GetObesaleEclResultSummaryForViewDto[] | undefined;
}

export class GetObesaleEclResultSummaryForViewDto implements IGetObesaleEclResultSummaryForViewDto {
    obesaleEclResultSummary!: ObesaleEclResultSummaryDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObesaleEclResultSummaryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obesaleEclResultSummary = data["obesaleEclResultSummary"] ? ObesaleEclResultSummaryDto.fromJS(data["obesaleEclResultSummary"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObesaleEclResultSummaryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetObesaleEclResultSummaryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obesaleEclResultSummary"] = this.obesaleEclResultSummary ? this.obesaleEclResultSummary.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObesaleEclResultSummaryForViewDto {
    obesaleEclResultSummary: ObesaleEclResultSummaryDto | undefined;
    obeEclTenantId: string | undefined;
}

export class ObesaleEclResultSummaryDto implements IObesaleEclResultSummaryDto {
    summaryType!: ResultSummaryTypeEnum | undefined;
    title!: string | undefined;
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IObesaleEclResultSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.summaryType = data["summaryType"];
            this.title = data["title"];
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ObesaleEclResultSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObesaleEclResultSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summaryType"] = this.summaryType;
        data["title"] = this.title;
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IObesaleEclResultSummaryDto {
    summaryType: ResultSummaryTypeEnum | undefined;
    title: string | undefined;
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export enum ResultSummaryTypeEnum {
    ByScenario = 0, 
    ByStage = 1, 
    ByProductType = 2, 
    BySegementStage = 3, 
}

export class GetObesaleEclResultSummaryForEditOutput implements IGetObesaleEclResultSummaryForEditOutput {
    obesaleEclResultSummary!: CreateOrEditObesaleEclResultSummaryDto | undefined;
    obeEclTenantId!: string | undefined;

    constructor(data?: IGetObesaleEclResultSummaryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.obesaleEclResultSummary = data["obesaleEclResultSummary"] ? CreateOrEditObesaleEclResultSummaryDto.fromJS(data["obesaleEclResultSummary"]) : <any>undefined;
            this.obeEclTenantId = data["obeEclTenantId"];
        }
    }

    static fromJS(data: any): GetObesaleEclResultSummaryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetObesaleEclResultSummaryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obesaleEclResultSummary"] = this.obesaleEclResultSummary ? this.obesaleEclResultSummary.toJSON() : <any>undefined;
        data["obeEclTenantId"] = this.obeEclTenantId;
        return data; 
    }
}

export interface IGetObesaleEclResultSummaryForEditOutput {
    obesaleEclResultSummary: CreateOrEditObesaleEclResultSummaryDto | undefined;
    obeEclTenantId: string | undefined;
}

export class CreateOrEditObesaleEclResultSummaryDto implements ICreateOrEditObesaleEclResultSummaryDto {
    summaryType!: ResultSummaryTypeEnum | undefined;
    title!: string | undefined;
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    obeEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditObesaleEclResultSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.summaryType = data["summaryType"];
            this.title = data["title"];
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.obeEclId = data["obeEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditObesaleEclResultSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditObesaleEclResultSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summaryType"] = this.summaryType;
        data["title"] = this.title;
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["obeEclId"] = this.obeEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditObesaleEclResultSummaryDto {
    summaryType: ResultSummaryTypeEnum | undefined;
    title: string | undefined;
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    obeEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto implements IPagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto {
    totalCount!: number | undefined;
    items!: ObesaleEclResultSummaryObeEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ObesaleEclResultSummaryObeEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfObesaleEclResultSummaryObeEclLookupTableDto {
    totalCount: number | undefined;
    items: ObesaleEclResultSummaryObeEclLookupTableDto[] | undefined;
}

export class ObesaleEclResultSummaryObeEclLookupTableDto implements IObesaleEclResultSummaryObeEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IObesaleEclResultSummaryObeEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ObesaleEclResultSummaryObeEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObesaleEclResultSummaryObeEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IObesaleEclResultSummaryObeEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    roleCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto | undefined;
    additionalPrice!: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean | undefined;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number | undefined;
    editionPaymentType!: EditionPaymentType | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled!: boolean | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export enum PaymentPeriodType {
    Monthly = 30, 
    Annual = 365, 
}

export enum EditionPaymentType {
    NewRegistration = 0, 
    BuyNow = 1, 
    Upgrade = 2, 
    Extend = 3, 
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1, 
    Stripe = 2, 
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number | undefined;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number | undefined;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments!: boolean | undefined;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    tenantId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number | undefined;
    status!: SubscriptionPaymentStatus | undefined;
    isRecurring!: boolean | undefined;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1, 
    Paid = 2, 
    Failed = 3, 
    Cancelled = 4, 
    Completed = 5, 
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    environment!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.environment = data["environment"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["environment"] = this.environment;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    environment: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto implements IPagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto {
    totalCount!: number | undefined;
    items!: GetPdInputAssumptionMacroeconomicProjectionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPdInputAssumptionMacroeconomicProjectionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPdInputAssumptionMacroeconomicProjectionForViewDto {
    totalCount: number | undefined;
    items: GetPdInputAssumptionMacroeconomicProjectionForViewDto[] | undefined;
}

export class GetPdInputAssumptionMacroeconomicProjectionForViewDto implements IGetPdInputAssumptionMacroeconomicProjectionForViewDto {
    pdInputAssumptionMacroeconomicProjection!: PdInputAssumptionMacroeconomicProjectionDto | undefined;

    constructor(data?: IGetPdInputAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionMacroeconomicProjection = data["pdInputAssumptionMacroeconomicProjection"] ? PdInputAssumptionMacroeconomicProjectionDto.fromJS(data["pdInputAssumptionMacroeconomicProjection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionMacroeconomicProjection"] = this.pdInputAssumptionMacroeconomicProjection ? this.pdInputAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionMacroeconomicProjectionForViewDto {
    pdInputAssumptionMacroeconomicProjection: PdInputAssumptionMacroeconomicProjectionDto | undefined;
}

export class GetPdInputAssumptionMacroeconomicProjectionForEditOutput implements IGetPdInputAssumptionMacroeconomicProjectionForEditOutput {
    pdInputAssumptionMacroeconomicProjection!: CreateOrEditPdInputAssumptionMacroeconomicProjectionDto | undefined;

    constructor(data?: IGetPdInputAssumptionMacroeconomicProjectionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionMacroeconomicProjection = data["pdInputAssumptionMacroeconomicProjection"] ? CreateOrEditPdInputAssumptionMacroeconomicProjectionDto.fromJS(data["pdInputAssumptionMacroeconomicProjection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionMacroeconomicProjectionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionMacroeconomicProjectionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionMacroeconomicProjection"] = this.pdInputAssumptionMacroeconomicProjection ? this.pdInputAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionMacroeconomicProjectionForEditOutput {
    pdInputAssumptionMacroeconomicProjection: CreateOrEditPdInputAssumptionMacroeconomicProjectionDto | undefined;
}

export class CreateOrEditPdInputAssumptionMacroeconomicProjectionDto implements ICreateOrEditPdInputAssumptionMacroeconomicProjectionDto {
    id!: string | undefined;

    constructor(data?: ICreateOrEditPdInputAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPdInputAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPdInputAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditPdInputAssumptionMacroeconomicProjectionDto {
    id: string | undefined;
}

export class PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto implements IPagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto {
    totalCount!: number | undefined;
    items!: GetPdInputAssumptionNonInternalModelForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPdInputAssumptionNonInternalModelForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPdInputAssumptionNonInternalModelForViewDto {
    totalCount: number | undefined;
    items: GetPdInputAssumptionNonInternalModelForViewDto[] | undefined;
}

export class GetPdInputAssumptionNonInternalModelForViewDto implements IGetPdInputAssumptionNonInternalModelForViewDto {
    pdInputAssumptionNonInternalModel!: PdInputAssumptionNonInternalModelDto | undefined;

    constructor(data?: IGetPdInputAssumptionNonInternalModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionNonInternalModel = data["pdInputAssumptionNonInternalModel"] ? PdInputAssumptionNonInternalModelDto.fromJS(data["pdInputAssumptionNonInternalModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionNonInternalModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionNonInternalModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionNonInternalModel"] = this.pdInputAssumptionNonInternalModel ? this.pdInputAssumptionNonInternalModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionNonInternalModelForViewDto {
    pdInputAssumptionNonInternalModel: PdInputAssumptionNonInternalModelDto | undefined;
}

export class GetPdInputAssumptionNonInternalModelForEditOutput implements IGetPdInputAssumptionNonInternalModelForEditOutput {
    pdInputAssumptionNonInternalModel!: CreateOrEditPdInputAssumptionNonInternalModelDto | undefined;

    constructor(data?: IGetPdInputAssumptionNonInternalModelForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionNonInternalModel = data["pdInputAssumptionNonInternalModel"] ? CreateOrEditPdInputAssumptionNonInternalModelDto.fromJS(data["pdInputAssumptionNonInternalModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionNonInternalModelForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionNonInternalModelForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionNonInternalModel"] = this.pdInputAssumptionNonInternalModel ? this.pdInputAssumptionNonInternalModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionNonInternalModelForEditOutput {
    pdInputAssumptionNonInternalModel: CreateOrEditPdInputAssumptionNonInternalModelDto | undefined;
}

export class CreateOrEditPdInputAssumptionNonInternalModelDto implements ICreateOrEditPdInputAssumptionNonInternalModelDto {
    id!: string | undefined;

    constructor(data?: ICreateOrEditPdInputAssumptionNonInternalModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPdInputAssumptionNonInternalModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPdInputAssumptionNonInternalModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditPdInputAssumptionNonInternalModelDto {
    id: string | undefined;
}

export class PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto implements IPagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto {
    totalCount!: number | undefined;
    items!: GetPdInputAssumptionNplIndexForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPdInputAssumptionNplIndexForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPdInputAssumptionNplIndexForViewDto {
    totalCount: number | undefined;
    items: GetPdInputAssumptionNplIndexForViewDto[] | undefined;
}

export class GetPdInputAssumptionNplIndexForViewDto implements IGetPdInputAssumptionNplIndexForViewDto {
    pdInputAssumptionNplIndex!: PdInputAssumptionNplIndexDto | undefined;

    constructor(data?: IGetPdInputAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionNplIndex = data["pdInputAssumptionNplIndex"] ? PdInputAssumptionNplIndexDto.fromJS(data["pdInputAssumptionNplIndex"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionNplIndex"] = this.pdInputAssumptionNplIndex ? this.pdInputAssumptionNplIndex.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionNplIndexForViewDto {
    pdInputAssumptionNplIndex: PdInputAssumptionNplIndexDto | undefined;
}

export class GetPdInputAssumptionNplIndexForEditOutput implements IGetPdInputAssumptionNplIndexForEditOutput {
    pdInputAssumptionNplIndex!: CreateOrEditPdInputAssumptionNplIndexDto | undefined;

    constructor(data?: IGetPdInputAssumptionNplIndexForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionNplIndex = data["pdInputAssumptionNplIndex"] ? CreateOrEditPdInputAssumptionNplIndexDto.fromJS(data["pdInputAssumptionNplIndex"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionNplIndexForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionNplIndexForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionNplIndex"] = this.pdInputAssumptionNplIndex ? this.pdInputAssumptionNplIndex.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionNplIndexForEditOutput {
    pdInputAssumptionNplIndex: CreateOrEditPdInputAssumptionNplIndexDto | undefined;
}

export class CreateOrEditPdInputAssumptionNplIndexDto implements ICreateOrEditPdInputAssumptionNplIndexDto {
    id!: string | undefined;

    constructor(data?: ICreateOrEditPdInputAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPdInputAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPdInputAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditPdInputAssumptionNplIndexDto {
    id: string | undefined;
}

export class PagedResultDtoOfGetPdInputAssumptionForViewDto implements IPagedResultDtoOfGetPdInputAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetPdInputAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPdInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPdInputAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPdInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPdInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPdInputAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetPdInputAssumptionForViewDto[] | undefined;
}

export class GetPdInputAssumptionForViewDto implements IGetPdInputAssumptionForViewDto {
    pdInputAssumption!: PdInputAssumptionDto | undefined;

    constructor(data?: IGetPdInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumption = data["pdInputAssumption"] ? PdInputAssumptionDto.fromJS(data["pdInputAssumption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumption"] = this.pdInputAssumption ? this.pdInputAssumption.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionForViewDto {
    pdInputAssumption: PdInputAssumptionDto | undefined;
}

export class GetPdInputAssumptionForEditOutput implements IGetPdInputAssumptionForEditOutput {
    pdInputAssumption!: CreateOrEditPdInputAssumptionDto | undefined;

    constructor(data?: IGetPdInputAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumption = data["pdInputAssumption"] ? CreateOrEditPdInputAssumptionDto.fromJS(data["pdInputAssumption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumption"] = this.pdInputAssumption ? this.pdInputAssumption.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionForEditOutput {
    pdInputAssumption: CreateOrEditPdInputAssumptionDto | undefined;
}

export class CreateOrEditPdInputAssumptionDto implements ICreateOrEditPdInputAssumptionDto {
    id!: string | undefined;

    constructor(data?: ICreateOrEditPdInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPdInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPdInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditPdInputAssumptionDto {
    id: string | undefined;
}

export class PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto implements IPagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto {
    totalCount!: number | undefined;
    items!: GetPdInputAssumptionStatisticalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPdInputAssumptionStatisticalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPdInputAssumptionStatisticalForViewDto {
    totalCount: number | undefined;
    items: GetPdInputAssumptionStatisticalForViewDto[] | undefined;
}

export class GetPdInputAssumptionStatisticalForViewDto implements IGetPdInputAssumptionStatisticalForViewDto {
    pdInputAssumptionStatistical!: PdInputAssumptionStatisticalDto | undefined;

    constructor(data?: IGetPdInputAssumptionStatisticalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionStatistical = data["pdInputAssumptionStatistical"] ? PdInputAssumptionStatisticalDto.fromJS(data["pdInputAssumptionStatistical"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionStatisticalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionStatisticalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionStatistical"] = this.pdInputAssumptionStatistical ? this.pdInputAssumptionStatistical.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionStatisticalForViewDto {
    pdInputAssumptionStatistical: PdInputAssumptionStatisticalDto | undefined;
}

export class PdInputAssumptionStatisticalDto implements IPdInputAssumptionStatisticalDto {
    canAffiliateEdit!: boolean | undefined;
    id!: string | undefined;

    constructor(data?: IPdInputAssumptionStatisticalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PdInputAssumptionStatisticalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdInputAssumptionStatisticalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPdInputAssumptionStatisticalDto {
    canAffiliateEdit: boolean | undefined;
    id: string | undefined;
}

export class GetPdInputAssumptionStatisticalForEditOutput implements IGetPdInputAssumptionStatisticalForEditOutput {
    pdInputAssumptionStatistical!: CreateOrEditPdInputAssumptionStatisticalDto | undefined;

    constructor(data?: IGetPdInputAssumptionStatisticalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputAssumptionStatistical = data["pdInputAssumptionStatistical"] ? CreateOrEditPdInputAssumptionStatisticalDto.fromJS(data["pdInputAssumptionStatistical"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputAssumptionStatisticalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputAssumptionStatisticalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputAssumptionStatistical"] = this.pdInputAssumptionStatistical ? this.pdInputAssumptionStatistical.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputAssumptionStatisticalForEditOutput {
    pdInputAssumptionStatistical: CreateOrEditPdInputAssumptionStatisticalDto | undefined;
}

export class CreateOrEditPdInputAssumptionStatisticalDto implements ICreateOrEditPdInputAssumptionStatisticalDto {
    canAffiliateEdit!: boolean | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditPdInputAssumptionStatisticalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPdInputAssumptionStatisticalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPdInputAssumptionStatisticalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditPdInputAssumptionStatisticalDto {
    canAffiliateEdit: boolean | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto implements IPagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto {
    totalCount!: number | undefined;
    items!: GetPdInputSnPCummulativeDefaultRateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetPdInputSnPCummulativeDefaultRateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPdInputSnPCummulativeDefaultRateForViewDto {
    totalCount: number | undefined;
    items: GetPdInputSnPCummulativeDefaultRateForViewDto[] | undefined;
}

export class GetPdInputSnPCummulativeDefaultRateForViewDto implements IGetPdInputSnPCummulativeDefaultRateForViewDto {
    pdInputSnPCummulativeDefaultRate!: PdInputSnPCummulativeDefaultRateDto | undefined;

    constructor(data?: IGetPdInputSnPCummulativeDefaultRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputSnPCummulativeDefaultRate = data["pdInputSnPCummulativeDefaultRate"] ? PdInputSnPCummulativeDefaultRateDto.fromJS(data["pdInputSnPCummulativeDefaultRate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputSnPCummulativeDefaultRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputSnPCummulativeDefaultRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputSnPCummulativeDefaultRate"] = this.pdInputSnPCummulativeDefaultRate ? this.pdInputSnPCummulativeDefaultRate.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputSnPCummulativeDefaultRateForViewDto {
    pdInputSnPCummulativeDefaultRate: PdInputSnPCummulativeDefaultRateDto | undefined;
}

export class GetPdInputSnPCummulativeDefaultRateForEditOutput implements IGetPdInputSnPCummulativeDefaultRateForEditOutput {
    pdInputSnPCummulativeDefaultRate!: CreateOrEditPdInputSnPCummulativeDefaultRateDto | undefined;

    constructor(data?: IGetPdInputSnPCummulativeDefaultRateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdInputSnPCummulativeDefaultRate = data["pdInputSnPCummulativeDefaultRate"] ? CreateOrEditPdInputSnPCummulativeDefaultRateDto.fromJS(data["pdInputSnPCummulativeDefaultRate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPdInputSnPCummulativeDefaultRateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPdInputSnPCummulativeDefaultRateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdInputSnPCummulativeDefaultRate"] = this.pdInputSnPCummulativeDefaultRate ? this.pdInputSnPCummulativeDefaultRate.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPdInputSnPCummulativeDefaultRateForEditOutput {
    pdInputSnPCummulativeDefaultRate: CreateOrEditPdInputSnPCummulativeDefaultRateDto | undefined;
}

export class CreateOrEditPdInputSnPCummulativeDefaultRateDto implements ICreateOrEditPdInputSnPCummulativeDefaultRateDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditPdInputSnPCummulativeDefaultRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditPdInputSnPCummulativeDefaultRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditPdInputSnPCummulativeDefaultRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditPdInputSnPCummulativeDefaultRateDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number | undefined;
    y!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class PagedResultDtoOfGetRetailEclApprovalForViewDto implements IPagedResultDtoOfGetRetailEclApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclApprovalForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclApprovalForViewDto[] | undefined;
}

export class GetRetailEclApprovalForViewDto implements IGetRetailEclApprovalForViewDto {
    retailEclApproval!: RetailEclApprovalDto | undefined;
    userName!: string | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclApproval = data["retailEclApproval"] ? RetailEclApprovalDto.fromJS(data["retailEclApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclApproval"] = this.retailEclApproval ? this.retailEclApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclApprovalForViewDto {
    retailEclApproval: RetailEclApprovalDto | undefined;
    userName: string | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclApprovalDto implements IRetailEclApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclApprovalForEditOutput implements IGetRetailEclApprovalForEditOutput {
    retailEclApproval!: CreateOrEditRetailEclApprovalDto | undefined;
    userName!: string | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclApproval = data["retailEclApproval"] ? CreateOrEditRetailEclApprovalDto.fromJS(data["retailEclApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclApproval"] = this.retailEclApproval ? this.retailEclApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclApprovalForEditOutput {
    retailEclApproval: CreateOrEditRetailEclApprovalDto | undefined;
    userName: string | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclApprovalDto implements ICreateOrEditRetailEclApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclApprovalUserLookupTableDto implements IPagedResultDtoOfRetailEclApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclApprovalUserLookupTableDto[] | undefined;
}

export class RetailEclApprovalUserLookupTableDto implements IRetailEclApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclApprovalRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclApprovalRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclApprovalRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclApprovalRetailEclLookupTableDto[] | undefined;
}

export class RetailEclApprovalRetailEclLookupTableDto implements IRetailEclApprovalRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclApprovalRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclApprovalRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclApprovalRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclApprovalRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto implements IPagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclAssumptionApprovalsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclAssumptionApprovalsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclAssumptionApprovalsForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclAssumptionApprovalsForViewDto[] | undefined;
}

export class GetRetailEclAssumptionApprovalsForViewDto implements IGetRetailEclAssumptionApprovalsForViewDto {
    retailEclAssumptionApprovals!: RetailEclAssumptionApprovalsDto | undefined;
    userName!: string | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclAssumptionApprovalsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclAssumptionApprovals = data["retailEclAssumptionApprovals"] ? RetailEclAssumptionApprovalsDto.fromJS(data["retailEclAssumptionApprovals"]) : <any>undefined;
            this.userName = data["userName"];
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclAssumptionApprovalsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclAssumptionApprovalsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclAssumptionApprovals"] = this.retailEclAssumptionApprovals ? this.retailEclAssumptionApprovals.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclAssumptionApprovalsForViewDto {
    retailEclAssumptionApprovals: RetailEclAssumptionApprovalsDto | undefined;
    userName: string | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclAssumptionApprovalsDto implements IRetailEclAssumptionApprovalsDto {
    assumptionType!: AssumptionTypeEnum | undefined;
    oldValue!: string | undefined;
    newValue!: string | undefined;
    dateReviewed!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    reviewedByUserId!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclAssumptionApprovalsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumptionType = data["assumptionType"];
            this.oldValue = data["oldValue"];
            this.newValue = data["newValue"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclAssumptionApprovalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclAssumptionApprovalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumptionType"] = this.assumptionType;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclAssumptionApprovalsDto {
    assumptionType: AssumptionTypeEnum | undefined;
    oldValue: string | undefined;
    newValue: string | undefined;
    dateReviewed: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    reviewedByUserId: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclAssumptionApprovalsForEditOutput implements IGetRetailEclAssumptionApprovalsForEditOutput {
    retailEclAssumptionApprovals!: CreateOrEditRetailEclAssumptionApprovalsDto | undefined;
    userName!: string | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclAssumptionApprovalsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclAssumptionApprovals = data["retailEclAssumptionApprovals"] ? CreateOrEditRetailEclAssumptionApprovalsDto.fromJS(data["retailEclAssumptionApprovals"]) : <any>undefined;
            this.userName = data["userName"];
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclAssumptionApprovalsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclAssumptionApprovalsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclAssumptionApprovals"] = this.retailEclAssumptionApprovals ? this.retailEclAssumptionApprovals.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclAssumptionApprovalsForEditOutput {
    retailEclAssumptionApprovals: CreateOrEditRetailEclAssumptionApprovalsDto | undefined;
    userName: string | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclAssumptionApprovalsDto implements ICreateOrEditRetailEclAssumptionApprovalsDto {
    assumptionType!: AssumptionTypeEnum | undefined;
    oldValue!: string | undefined;
    newValue!: string | undefined;
    dateReviewed!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    requiresGroupApproval!: boolean;
    reviewedByUserId!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclAssumptionApprovalsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumptionType = data["assumptionType"];
            this.oldValue = data["oldValue"];
            this.newValue = data["newValue"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclAssumptionApprovalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclAssumptionApprovalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumptionType"] = this.assumptionType;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclAssumptionApprovalsDto {
    assumptionType: AssumptionTypeEnum | undefined;
    oldValue: string | undefined;
    newValue: string | undefined;
    dateReviewed: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    requiresGroupApproval: boolean;
    reviewedByUserId: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto implements IPagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclAssumptionApprovalsUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclAssumptionApprovalsUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclAssumptionApprovalsUserLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclAssumptionApprovalsUserLookupTableDto[] | undefined;
}

export class RetailEclAssumptionApprovalsUserLookupTableDto implements IRetailEclAssumptionApprovalsUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclAssumptionApprovalsUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclAssumptionApprovalsUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclAssumptionApprovalsUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclAssumptionApprovalsUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclAssumptionApprovalsRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclAssumptionApprovalsRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclAssumptionApprovalsRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclAssumptionApprovalsRetailEclLookupTableDto[] | undefined;
}

export class RetailEclAssumptionApprovalsRetailEclLookupTableDto implements IRetailEclAssumptionApprovalsRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclAssumptionApprovalsRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclAssumptionApprovalsRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclAssumptionApprovalsRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclAssumptionApprovalsRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclAssumptionForViewDto implements IPagedResultDtoOfGetRetailEclAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclAssumptionForViewDto[] | undefined;
}

export class GetRetailEclAssumptionForViewDto implements IGetRetailEclAssumptionForViewDto {
    retailEclAssumption!: RetailEclAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclAssumption = data["retailEclAssumption"] ? RetailEclAssumptionDto.fromJS(data["retailEclAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclAssumption"] = this.retailEclAssumption ? this.retailEclAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclAssumptionForViewDto {
    retailEclAssumption: RetailEclAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclAssumptionDto implements IRetailEclAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.assumptionGroup = data["assumptionGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["assumptionGroup"] = this.assumptionGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    assumptionGroup: AssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclAssumptionForEditOutput implements IGetRetailEclAssumptionForEditOutput {
    retailEclAssumption!: CreateOrEditRetailEclAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclAssumption = data["retailEclAssumption"] ? CreateOrEditRetailEclAssumptionDto.fromJS(data["retailEclAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclAssumption"] = this.retailEclAssumption ? this.retailEclAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclAssumptionForEditOutput {
    retailEclAssumption: CreateOrEditRetailEclAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclAssumptionDto implements ICreateOrEditRetailEclAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.assumptionGroup = data["assumptionGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["assumptionGroup"] = this.assumptionGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean;
    assumptionGroup: AssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclAssumptionRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclAssumptionRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclAssumptionRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclAssumptionRetailEclLookupTableDto[] | undefined;
}

export class RetailEclAssumptionRetailEclLookupTableDto implements IRetailEclAssumptionRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclAssumptionRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclDataLoanBookForViewDto implements IPagedResultDtoOfGetRetailEclDataLoanBookForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclDataLoanBookForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclDataLoanBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclDataLoanBookForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclDataLoanBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclDataLoanBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclDataLoanBookForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclDataLoanBookForViewDto[] | undefined;
}

export class GetRetailEclDataLoanBookForViewDto implements IGetRetailEclDataLoanBookForViewDto {
    retailEclDataLoanBook!: RetailEclDataLoanBookDto | undefined;
    retailEclUploadTenantId!: string | undefined;

    constructor(data?: IGetRetailEclDataLoanBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclDataLoanBook = data["retailEclDataLoanBook"] ? RetailEclDataLoanBookDto.fromJS(data["retailEclDataLoanBook"]) : <any>undefined;
            this.retailEclUploadTenantId = data["retailEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclDataLoanBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclDataLoanBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclDataLoanBook"] = this.retailEclDataLoanBook ? this.retailEclDataLoanBook.toJSON() : <any>undefined;
        data["retailEclUploadTenantId"] = this.retailEclUploadTenantId;
        return data; 
    }
}

export interface IGetRetailEclDataLoanBookForViewDto {
    retailEclDataLoanBook: RetailEclDataLoanBookDto | undefined;
    retailEclUploadTenantId: string | undefined;
}

export class RetailEclDataLoanBookDto implements IRetailEclDataLoanBookDto {
    customerNo!: string | undefined;
    accountNo!: string | undefined;
    contractNo!: string | undefined;
    customerName!: string | undefined;
    snapshotDate!: moment.Moment | undefined;
    segment!: string | undefined;
    sector!: string | undefined;
    currency!: string | undefined;
    productType!: string | undefined;
    productMapping!: string | undefined;
    specialisedLending!: string | undefined;
    ratingModel!: string | undefined;
    originalRating!: number | undefined;
    currentRating!: number | undefined;
    lifetimePD!: number | undefined;
    month12PD!: number | undefined;
    daysPastDue!: number | undefined;
    watchlistIndicator!: boolean | undefined;
    classification!: string | undefined;
    impairedDate!: moment.Moment | undefined;
    defaultDate!: moment.Moment | undefined;
    creditLimit!: number | undefined;
    originalBalanceLCY!: number | undefined;
    outstandingBalanceLCY!: number | undefined;
    outstandingBalanceACY!: number | undefined;
    contractStartDate!: moment.Moment | undefined;
    contractEndDate!: moment.Moment | undefined;
    restructureIndicator!: boolean | undefined;
    restructureRisk!: string | undefined;
    restructureType!: string | undefined;
    restructureStartDate!: moment.Moment | undefined;
    restructureEndDate!: moment.Moment | undefined;
    principalPaymentTermsOrigination!: string | undefined;
    pptoPeriod!: number | undefined;
    interestPaymentTermsOrigination!: string | undefined;
    iptoPeriod!: number | undefined;
    principalPaymentStructure!: string | undefined;
    interestPaymentStructure!: string | undefined;
    interestRateType!: string | undefined;
    baseRate!: string | undefined;
    originationContractualInterestRate!: string | undefined;
    introductoryPeriod!: number | undefined;
    postIPContractualInterestRate!: number | undefined;
    currentContractualInterestRate!: number | undefined;
    eir!: number | undefined;
    debentureOMV!: number | undefined;
    debentureFSV!: number | undefined;
    cashOMV!: number | undefined;
    cashFSV!: number | undefined;
    inventoryOMV!: number | undefined;
    inventoryFSV!: number | undefined;
    plantEquipmentOMV!: number | undefined;
    plantEquipmentFSV!: number | undefined;
    residentialPropertyOMV!: number | undefined;
    residentialPropertyFSV!: number | undefined;
    commercialPropertyOMV!: number | undefined;
    commercialProperty!: number | undefined;
    receivablesOMV!: number | undefined;
    receivablesFSV!: number | undefined;
    sharesOMV!: number | undefined;
    sharesFSV!: number | undefined;
    vehicleOMV!: number | undefined;
    vehicleFSV!: number | undefined;
    cureRate!: number | undefined;
    guaranteeIndicator!: boolean | undefined;
    guarantorPD!: string | undefined;
    guarantorLGD!: string | undefined;
    guaranteeValue!: number | undefined;
    guaranteeLevel!: number | undefined;
    contractId!: string | undefined;
    retailEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclDataLoanBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNo = data["customerNo"];
            this.accountNo = data["accountNo"];
            this.contractNo = data["contractNo"];
            this.customerName = data["customerName"];
            this.snapshotDate = data["snapshotDate"] ? moment(data["snapshotDate"].toString()) : <any>undefined;
            this.segment = data["segment"];
            this.sector = data["sector"];
            this.currency = data["currency"];
            this.productType = data["productType"];
            this.productMapping = data["productMapping"];
            this.specialisedLending = data["specialisedLending"];
            this.ratingModel = data["ratingModel"];
            this.originalRating = data["originalRating"];
            this.currentRating = data["currentRating"];
            this.lifetimePD = data["lifetimePD"];
            this.month12PD = data["month12PD"];
            this.daysPastDue = data["daysPastDue"];
            this.watchlistIndicator = data["watchlistIndicator"];
            this.classification = data["classification"];
            this.impairedDate = data["impairedDate"] ? moment(data["impairedDate"].toString()) : <any>undefined;
            this.defaultDate = data["defaultDate"] ? moment(data["defaultDate"].toString()) : <any>undefined;
            this.creditLimit = data["creditLimit"];
            this.originalBalanceLCY = data["originalBalanceLCY"];
            this.outstandingBalanceLCY = data["outstandingBalanceLCY"];
            this.outstandingBalanceACY = data["outstandingBalanceACY"];
            this.contractStartDate = data["contractStartDate"] ? moment(data["contractStartDate"].toString()) : <any>undefined;
            this.contractEndDate = data["contractEndDate"] ? moment(data["contractEndDate"].toString()) : <any>undefined;
            this.restructureIndicator = data["restructureIndicator"];
            this.restructureRisk = data["restructureRisk"];
            this.restructureType = data["restructureType"];
            this.restructureStartDate = data["restructureStartDate"] ? moment(data["restructureStartDate"].toString()) : <any>undefined;
            this.restructureEndDate = data["restructureEndDate"] ? moment(data["restructureEndDate"].toString()) : <any>undefined;
            this.principalPaymentTermsOrigination = data["principalPaymentTermsOrigination"];
            this.pptoPeriod = data["pptoPeriod"];
            this.interestPaymentTermsOrigination = data["interestPaymentTermsOrigination"];
            this.iptoPeriod = data["iptoPeriod"];
            this.principalPaymentStructure = data["principalPaymentStructure"];
            this.interestPaymentStructure = data["interestPaymentStructure"];
            this.interestRateType = data["interestRateType"];
            this.baseRate = data["baseRate"];
            this.originationContractualInterestRate = data["originationContractualInterestRate"];
            this.introductoryPeriod = data["introductoryPeriod"];
            this.postIPContractualInterestRate = data["postIPContractualInterestRate"];
            this.currentContractualInterestRate = data["currentContractualInterestRate"];
            this.eir = data["eir"];
            this.debentureOMV = data["debentureOMV"];
            this.debentureFSV = data["debentureFSV"];
            this.cashOMV = data["cashOMV"];
            this.cashFSV = data["cashFSV"];
            this.inventoryOMV = data["inventoryOMV"];
            this.inventoryFSV = data["inventoryFSV"];
            this.plantEquipmentOMV = data["plantEquipmentOMV"];
            this.plantEquipmentFSV = data["plantEquipmentFSV"];
            this.residentialPropertyOMV = data["residentialPropertyOMV"];
            this.residentialPropertyFSV = data["residentialPropertyFSV"];
            this.commercialPropertyOMV = data["commercialPropertyOMV"];
            this.commercialProperty = data["commercialProperty"];
            this.receivablesOMV = data["receivablesOMV"];
            this.receivablesFSV = data["receivablesFSV"];
            this.sharesOMV = data["sharesOMV"];
            this.sharesFSV = data["sharesFSV"];
            this.vehicleOMV = data["vehicleOMV"];
            this.vehicleFSV = data["vehicleFSV"];
            this.cureRate = data["cureRate"];
            this.guaranteeIndicator = data["guaranteeIndicator"];
            this.guarantorPD = data["guarantorPD"];
            this.guarantorLGD = data["guarantorLGD"];
            this.guaranteeValue = data["guaranteeValue"];
            this.guaranteeLevel = data["guaranteeLevel"];
            this.contractId = data["contractId"];
            this.retailEclUploadId = data["retailEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclDataLoanBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclDataLoanBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["contractNo"] = this.contractNo;
        data["customerName"] = this.customerName;
        data["snapshotDate"] = this.snapshotDate ? this.snapshotDate.toISOString() : <any>undefined;
        data["segment"] = this.segment;
        data["sector"] = this.sector;
        data["currency"] = this.currency;
        data["productType"] = this.productType;
        data["productMapping"] = this.productMapping;
        data["specialisedLending"] = this.specialisedLending;
        data["ratingModel"] = this.ratingModel;
        data["originalRating"] = this.originalRating;
        data["currentRating"] = this.currentRating;
        data["lifetimePD"] = this.lifetimePD;
        data["month12PD"] = this.month12PD;
        data["daysPastDue"] = this.daysPastDue;
        data["watchlistIndicator"] = this.watchlistIndicator;
        data["classification"] = this.classification;
        data["impairedDate"] = this.impairedDate ? this.impairedDate.toISOString() : <any>undefined;
        data["defaultDate"] = this.defaultDate ? this.defaultDate.toISOString() : <any>undefined;
        data["creditLimit"] = this.creditLimit;
        data["originalBalanceLCY"] = this.originalBalanceLCY;
        data["outstandingBalanceLCY"] = this.outstandingBalanceLCY;
        data["outstandingBalanceACY"] = this.outstandingBalanceACY;
        data["contractStartDate"] = this.contractStartDate ? this.contractStartDate.toISOString() : <any>undefined;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["restructureIndicator"] = this.restructureIndicator;
        data["restructureRisk"] = this.restructureRisk;
        data["restructureType"] = this.restructureType;
        data["restructureStartDate"] = this.restructureStartDate ? this.restructureStartDate.toISOString() : <any>undefined;
        data["restructureEndDate"] = this.restructureEndDate ? this.restructureEndDate.toISOString() : <any>undefined;
        data["principalPaymentTermsOrigination"] = this.principalPaymentTermsOrigination;
        data["pptoPeriod"] = this.pptoPeriod;
        data["interestPaymentTermsOrigination"] = this.interestPaymentTermsOrigination;
        data["iptoPeriod"] = this.iptoPeriod;
        data["principalPaymentStructure"] = this.principalPaymentStructure;
        data["interestPaymentStructure"] = this.interestPaymentStructure;
        data["interestRateType"] = this.interestRateType;
        data["baseRate"] = this.baseRate;
        data["originationContractualInterestRate"] = this.originationContractualInterestRate;
        data["introductoryPeriod"] = this.introductoryPeriod;
        data["postIPContractualInterestRate"] = this.postIPContractualInterestRate;
        data["currentContractualInterestRate"] = this.currentContractualInterestRate;
        data["eir"] = this.eir;
        data["debentureOMV"] = this.debentureOMV;
        data["debentureFSV"] = this.debentureFSV;
        data["cashOMV"] = this.cashOMV;
        data["cashFSV"] = this.cashFSV;
        data["inventoryOMV"] = this.inventoryOMV;
        data["inventoryFSV"] = this.inventoryFSV;
        data["plantEquipmentOMV"] = this.plantEquipmentOMV;
        data["plantEquipmentFSV"] = this.plantEquipmentFSV;
        data["residentialPropertyOMV"] = this.residentialPropertyOMV;
        data["residentialPropertyFSV"] = this.residentialPropertyFSV;
        data["commercialPropertyOMV"] = this.commercialPropertyOMV;
        data["commercialProperty"] = this.commercialProperty;
        data["receivablesOMV"] = this.receivablesOMV;
        data["receivablesFSV"] = this.receivablesFSV;
        data["sharesOMV"] = this.sharesOMV;
        data["sharesFSV"] = this.sharesFSV;
        data["vehicleOMV"] = this.vehicleOMV;
        data["vehicleFSV"] = this.vehicleFSV;
        data["cureRate"] = this.cureRate;
        data["guaranteeIndicator"] = this.guaranteeIndicator;
        data["guarantorPD"] = this.guarantorPD;
        data["guarantorLGD"] = this.guarantorLGD;
        data["guaranteeValue"] = this.guaranteeValue;
        data["guaranteeLevel"] = this.guaranteeLevel;
        data["contractId"] = this.contractId;
        data["retailEclUploadId"] = this.retailEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclDataLoanBookDto {
    customerNo: string | undefined;
    accountNo: string | undefined;
    contractNo: string | undefined;
    customerName: string | undefined;
    snapshotDate: moment.Moment | undefined;
    segment: string | undefined;
    sector: string | undefined;
    currency: string | undefined;
    productType: string | undefined;
    productMapping: string | undefined;
    specialisedLending: string | undefined;
    ratingModel: string | undefined;
    originalRating: number | undefined;
    currentRating: number | undefined;
    lifetimePD: number | undefined;
    month12PD: number | undefined;
    daysPastDue: number | undefined;
    watchlistIndicator: boolean | undefined;
    classification: string | undefined;
    impairedDate: moment.Moment | undefined;
    defaultDate: moment.Moment | undefined;
    creditLimit: number | undefined;
    originalBalanceLCY: number | undefined;
    outstandingBalanceLCY: number | undefined;
    outstandingBalanceACY: number | undefined;
    contractStartDate: moment.Moment | undefined;
    contractEndDate: moment.Moment | undefined;
    restructureIndicator: boolean | undefined;
    restructureRisk: string | undefined;
    restructureType: string | undefined;
    restructureStartDate: moment.Moment | undefined;
    restructureEndDate: moment.Moment | undefined;
    principalPaymentTermsOrigination: string | undefined;
    pptoPeriod: number | undefined;
    interestPaymentTermsOrigination: string | undefined;
    iptoPeriod: number | undefined;
    principalPaymentStructure: string | undefined;
    interestPaymentStructure: string | undefined;
    interestRateType: string | undefined;
    baseRate: string | undefined;
    originationContractualInterestRate: string | undefined;
    introductoryPeriod: number | undefined;
    postIPContractualInterestRate: number | undefined;
    currentContractualInterestRate: number | undefined;
    eir: number | undefined;
    debentureOMV: number | undefined;
    debentureFSV: number | undefined;
    cashOMV: number | undefined;
    cashFSV: number | undefined;
    inventoryOMV: number | undefined;
    inventoryFSV: number | undefined;
    plantEquipmentOMV: number | undefined;
    plantEquipmentFSV: number | undefined;
    residentialPropertyOMV: number | undefined;
    residentialPropertyFSV: number | undefined;
    commercialPropertyOMV: number | undefined;
    commercialProperty: number | undefined;
    receivablesOMV: number | undefined;
    receivablesFSV: number | undefined;
    sharesOMV: number | undefined;
    sharesFSV: number | undefined;
    vehicleOMV: number | undefined;
    vehicleFSV: number | undefined;
    cureRate: number | undefined;
    guaranteeIndicator: boolean | undefined;
    guarantorPD: string | undefined;
    guarantorLGD: string | undefined;
    guaranteeValue: number | undefined;
    guaranteeLevel: number | undefined;
    contractId: string | undefined;
    retailEclUploadId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclDataLoanBookForEditOutput implements IGetRetailEclDataLoanBookForEditOutput {
    retailEclDataLoanBook!: CreateOrEditRetailEclDataLoanBookDto | undefined;
    retailEclUploadTenantId!: string | undefined;

    constructor(data?: IGetRetailEclDataLoanBookForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclDataLoanBook = data["retailEclDataLoanBook"] ? CreateOrEditRetailEclDataLoanBookDto.fromJS(data["retailEclDataLoanBook"]) : <any>undefined;
            this.retailEclUploadTenantId = data["retailEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclDataLoanBookForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclDataLoanBookForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclDataLoanBook"] = this.retailEclDataLoanBook ? this.retailEclDataLoanBook.toJSON() : <any>undefined;
        data["retailEclUploadTenantId"] = this.retailEclUploadTenantId;
        return data; 
    }
}

export interface IGetRetailEclDataLoanBookForEditOutput {
    retailEclDataLoanBook: CreateOrEditRetailEclDataLoanBookDto | undefined;
    retailEclUploadTenantId: string | undefined;
}

export class CreateOrEditRetailEclDataLoanBookDto implements ICreateOrEditRetailEclDataLoanBookDto {
    customerNo!: string | undefined;
    accountNo!: string | undefined;
    contractNo!: string | undefined;
    customerName!: string | undefined;
    snapshotDate!: moment.Moment | undefined;
    segment!: string | undefined;
    sector!: string | undefined;
    currency!: string | undefined;
    productType!: string | undefined;
    productMapping!: string | undefined;
    specialisedLending!: string | undefined;
    ratingModel!: string | undefined;
    originalRating!: number | undefined;
    currentRating!: number | undefined;
    lifetimePD!: number | undefined;
    month12PD!: number | undefined;
    daysPastDue!: number | undefined;
    watchlistIndicator!: boolean;
    classification!: string | undefined;
    impairedDate!: moment.Moment | undefined;
    defaultDate!: moment.Moment | undefined;
    creditLimit!: number | undefined;
    originalBalanceLCY!: number | undefined;
    outstandingBalanceLCY!: number | undefined;
    outstandingBalanceACY!: number | undefined;
    contractStartDate!: moment.Moment | undefined;
    contractEndDate!: moment.Moment | undefined;
    restructureIndicator!: boolean;
    restructureRisk!: string | undefined;
    restructureType!: string | undefined;
    restructureStartDate!: moment.Moment | undefined;
    restructureEndDate!: moment.Moment | undefined;
    principalPaymentTermsOrigination!: string | undefined;
    pptoPeriod!: number | undefined;
    interestPaymentTermsOrigination!: string | undefined;
    iptoPeriod!: number | undefined;
    principalPaymentStructure!: string | undefined;
    interestPaymentStructure!: string | undefined;
    interestRateType!: string | undefined;
    baseRate!: string | undefined;
    originationContractualInterestRate!: string | undefined;
    introductoryPeriod!: number | undefined;
    postIPContractualInterestRate!: number | undefined;
    currentContractualInterestRate!: number | undefined;
    eir!: number | undefined;
    debentureOMV!: number | undefined;
    debentureFSV!: number | undefined;
    cashOMV!: number | undefined;
    cashFSV!: number | undefined;
    inventoryOMV!: number | undefined;
    inventoryFSV!: number | undefined;
    plantEquipmentOMV!: number | undefined;
    plantEquipmentFSV!: number | undefined;
    residentialPropertyOMV!: number | undefined;
    residentialPropertyFSV!: number | undefined;
    commercialPropertyOMV!: number | undefined;
    commercialProperty!: number | undefined;
    receivablesOMV!: number | undefined;
    receivablesFSV!: number | undefined;
    sharesOMV!: number | undefined;
    sharesFSV!: number | undefined;
    vehicleOMV!: number | undefined;
    vehicleFSV!: number | undefined;
    cureRate!: number | undefined;
    guaranteeIndicator!: boolean;
    guarantorPD!: string | undefined;
    guarantorLGD!: string | undefined;
    guaranteeValue!: number | undefined;
    guaranteeLevel!: number | undefined;
    contractId!: string | undefined;
    retailEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclDataLoanBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNo = data["customerNo"];
            this.accountNo = data["accountNo"];
            this.contractNo = data["contractNo"];
            this.customerName = data["customerName"];
            this.snapshotDate = data["snapshotDate"] ? moment(data["snapshotDate"].toString()) : <any>undefined;
            this.segment = data["segment"];
            this.sector = data["sector"];
            this.currency = data["currency"];
            this.productType = data["productType"];
            this.productMapping = data["productMapping"];
            this.specialisedLending = data["specialisedLending"];
            this.ratingModel = data["ratingModel"];
            this.originalRating = data["originalRating"];
            this.currentRating = data["currentRating"];
            this.lifetimePD = data["lifetimePD"];
            this.month12PD = data["month12PD"];
            this.daysPastDue = data["daysPastDue"];
            this.watchlistIndicator = data["watchlistIndicator"];
            this.classification = data["classification"];
            this.impairedDate = data["impairedDate"] ? moment(data["impairedDate"].toString()) : <any>undefined;
            this.defaultDate = data["defaultDate"] ? moment(data["defaultDate"].toString()) : <any>undefined;
            this.creditLimit = data["creditLimit"];
            this.originalBalanceLCY = data["originalBalanceLCY"];
            this.outstandingBalanceLCY = data["outstandingBalanceLCY"];
            this.outstandingBalanceACY = data["outstandingBalanceACY"];
            this.contractStartDate = data["contractStartDate"] ? moment(data["contractStartDate"].toString()) : <any>undefined;
            this.contractEndDate = data["contractEndDate"] ? moment(data["contractEndDate"].toString()) : <any>undefined;
            this.restructureIndicator = data["restructureIndicator"];
            this.restructureRisk = data["restructureRisk"];
            this.restructureType = data["restructureType"];
            this.restructureStartDate = data["restructureStartDate"] ? moment(data["restructureStartDate"].toString()) : <any>undefined;
            this.restructureEndDate = data["restructureEndDate"] ? moment(data["restructureEndDate"].toString()) : <any>undefined;
            this.principalPaymentTermsOrigination = data["principalPaymentTermsOrigination"];
            this.pptoPeriod = data["pptoPeriod"];
            this.interestPaymentTermsOrigination = data["interestPaymentTermsOrigination"];
            this.iptoPeriod = data["iptoPeriod"];
            this.principalPaymentStructure = data["principalPaymentStructure"];
            this.interestPaymentStructure = data["interestPaymentStructure"];
            this.interestRateType = data["interestRateType"];
            this.baseRate = data["baseRate"];
            this.originationContractualInterestRate = data["originationContractualInterestRate"];
            this.introductoryPeriod = data["introductoryPeriod"];
            this.postIPContractualInterestRate = data["postIPContractualInterestRate"];
            this.currentContractualInterestRate = data["currentContractualInterestRate"];
            this.eir = data["eir"];
            this.debentureOMV = data["debentureOMV"];
            this.debentureFSV = data["debentureFSV"];
            this.cashOMV = data["cashOMV"];
            this.cashFSV = data["cashFSV"];
            this.inventoryOMV = data["inventoryOMV"];
            this.inventoryFSV = data["inventoryFSV"];
            this.plantEquipmentOMV = data["plantEquipmentOMV"];
            this.plantEquipmentFSV = data["plantEquipmentFSV"];
            this.residentialPropertyOMV = data["residentialPropertyOMV"];
            this.residentialPropertyFSV = data["residentialPropertyFSV"];
            this.commercialPropertyOMV = data["commercialPropertyOMV"];
            this.commercialProperty = data["commercialProperty"];
            this.receivablesOMV = data["receivablesOMV"];
            this.receivablesFSV = data["receivablesFSV"];
            this.sharesOMV = data["sharesOMV"];
            this.sharesFSV = data["sharesFSV"];
            this.vehicleOMV = data["vehicleOMV"];
            this.vehicleFSV = data["vehicleFSV"];
            this.cureRate = data["cureRate"];
            this.guaranteeIndicator = data["guaranteeIndicator"];
            this.guarantorPD = data["guarantorPD"];
            this.guarantorLGD = data["guarantorLGD"];
            this.guaranteeValue = data["guaranteeValue"];
            this.guaranteeLevel = data["guaranteeLevel"];
            this.contractId = data["contractId"];
            this.retailEclUploadId = data["retailEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclDataLoanBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclDataLoanBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["contractNo"] = this.contractNo;
        data["customerName"] = this.customerName;
        data["snapshotDate"] = this.snapshotDate ? this.snapshotDate.toISOString() : <any>undefined;
        data["segment"] = this.segment;
        data["sector"] = this.sector;
        data["currency"] = this.currency;
        data["productType"] = this.productType;
        data["productMapping"] = this.productMapping;
        data["specialisedLending"] = this.specialisedLending;
        data["ratingModel"] = this.ratingModel;
        data["originalRating"] = this.originalRating;
        data["currentRating"] = this.currentRating;
        data["lifetimePD"] = this.lifetimePD;
        data["month12PD"] = this.month12PD;
        data["daysPastDue"] = this.daysPastDue;
        data["watchlistIndicator"] = this.watchlistIndicator;
        data["classification"] = this.classification;
        data["impairedDate"] = this.impairedDate ? this.impairedDate.toISOString() : <any>undefined;
        data["defaultDate"] = this.defaultDate ? this.defaultDate.toISOString() : <any>undefined;
        data["creditLimit"] = this.creditLimit;
        data["originalBalanceLCY"] = this.originalBalanceLCY;
        data["outstandingBalanceLCY"] = this.outstandingBalanceLCY;
        data["outstandingBalanceACY"] = this.outstandingBalanceACY;
        data["contractStartDate"] = this.contractStartDate ? this.contractStartDate.toISOString() : <any>undefined;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["restructureIndicator"] = this.restructureIndicator;
        data["restructureRisk"] = this.restructureRisk;
        data["restructureType"] = this.restructureType;
        data["restructureStartDate"] = this.restructureStartDate ? this.restructureStartDate.toISOString() : <any>undefined;
        data["restructureEndDate"] = this.restructureEndDate ? this.restructureEndDate.toISOString() : <any>undefined;
        data["principalPaymentTermsOrigination"] = this.principalPaymentTermsOrigination;
        data["pptoPeriod"] = this.pptoPeriod;
        data["interestPaymentTermsOrigination"] = this.interestPaymentTermsOrigination;
        data["iptoPeriod"] = this.iptoPeriod;
        data["principalPaymentStructure"] = this.principalPaymentStructure;
        data["interestPaymentStructure"] = this.interestPaymentStructure;
        data["interestRateType"] = this.interestRateType;
        data["baseRate"] = this.baseRate;
        data["originationContractualInterestRate"] = this.originationContractualInterestRate;
        data["introductoryPeriod"] = this.introductoryPeriod;
        data["postIPContractualInterestRate"] = this.postIPContractualInterestRate;
        data["currentContractualInterestRate"] = this.currentContractualInterestRate;
        data["eir"] = this.eir;
        data["debentureOMV"] = this.debentureOMV;
        data["debentureFSV"] = this.debentureFSV;
        data["cashOMV"] = this.cashOMV;
        data["cashFSV"] = this.cashFSV;
        data["inventoryOMV"] = this.inventoryOMV;
        data["inventoryFSV"] = this.inventoryFSV;
        data["plantEquipmentOMV"] = this.plantEquipmentOMV;
        data["plantEquipmentFSV"] = this.plantEquipmentFSV;
        data["residentialPropertyOMV"] = this.residentialPropertyOMV;
        data["residentialPropertyFSV"] = this.residentialPropertyFSV;
        data["commercialPropertyOMV"] = this.commercialPropertyOMV;
        data["commercialProperty"] = this.commercialProperty;
        data["receivablesOMV"] = this.receivablesOMV;
        data["receivablesFSV"] = this.receivablesFSV;
        data["sharesOMV"] = this.sharesOMV;
        data["sharesFSV"] = this.sharesFSV;
        data["vehicleOMV"] = this.vehicleOMV;
        data["vehicleFSV"] = this.vehicleFSV;
        data["cureRate"] = this.cureRate;
        data["guaranteeIndicator"] = this.guaranteeIndicator;
        data["guarantorPD"] = this.guarantorPD;
        data["guarantorLGD"] = this.guarantorLGD;
        data["guaranteeValue"] = this.guaranteeValue;
        data["guaranteeLevel"] = this.guaranteeLevel;
        data["contractId"] = this.contractId;
        data["retailEclUploadId"] = this.retailEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclDataLoanBookDto {
    customerNo: string | undefined;
    accountNo: string | undefined;
    contractNo: string | undefined;
    customerName: string | undefined;
    snapshotDate: moment.Moment | undefined;
    segment: string | undefined;
    sector: string | undefined;
    currency: string | undefined;
    productType: string | undefined;
    productMapping: string | undefined;
    specialisedLending: string | undefined;
    ratingModel: string | undefined;
    originalRating: number | undefined;
    currentRating: number | undefined;
    lifetimePD: number | undefined;
    month12PD: number | undefined;
    daysPastDue: number | undefined;
    watchlistIndicator: boolean;
    classification: string | undefined;
    impairedDate: moment.Moment | undefined;
    defaultDate: moment.Moment | undefined;
    creditLimit: number | undefined;
    originalBalanceLCY: number | undefined;
    outstandingBalanceLCY: number | undefined;
    outstandingBalanceACY: number | undefined;
    contractStartDate: moment.Moment | undefined;
    contractEndDate: moment.Moment | undefined;
    restructureIndicator: boolean;
    restructureRisk: string | undefined;
    restructureType: string | undefined;
    restructureStartDate: moment.Moment | undefined;
    restructureEndDate: moment.Moment | undefined;
    principalPaymentTermsOrigination: string | undefined;
    pptoPeriod: number | undefined;
    interestPaymentTermsOrigination: string | undefined;
    iptoPeriod: number | undefined;
    principalPaymentStructure: string | undefined;
    interestPaymentStructure: string | undefined;
    interestRateType: string | undefined;
    baseRate: string | undefined;
    originationContractualInterestRate: string | undefined;
    introductoryPeriod: number | undefined;
    postIPContractualInterestRate: number | undefined;
    currentContractualInterestRate: number | undefined;
    eir: number | undefined;
    debentureOMV: number | undefined;
    debentureFSV: number | undefined;
    cashOMV: number | undefined;
    cashFSV: number | undefined;
    inventoryOMV: number | undefined;
    inventoryFSV: number | undefined;
    plantEquipmentOMV: number | undefined;
    plantEquipmentFSV: number | undefined;
    residentialPropertyOMV: number | undefined;
    residentialPropertyFSV: number | undefined;
    commercialPropertyOMV: number | undefined;
    commercialProperty: number | undefined;
    receivablesOMV: number | undefined;
    receivablesFSV: number | undefined;
    sharesOMV: number | undefined;
    sharesFSV: number | undefined;
    vehicleOMV: number | undefined;
    vehicleFSV: number | undefined;
    cureRate: number | undefined;
    guaranteeIndicator: boolean;
    guarantorPD: string | undefined;
    guarantorLGD: string | undefined;
    guaranteeValue: number | undefined;
    guaranteeLevel: number | undefined;
    contractId: string | undefined;
    retailEclUploadId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto implements IPagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclDataLoanBookRetailEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclDataLoanBookRetailEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclDataLoanBookRetailEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclDataLoanBookRetailEclUploadLookupTableDto[] | undefined;
}

export class RetailEclDataLoanBookRetailEclUploadLookupTableDto implements IRetailEclDataLoanBookRetailEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclDataLoanBookRetailEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclDataLoanBookRetailEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclDataLoanBookRetailEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclDataLoanBookRetailEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto implements IPagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclDataPaymentScheduleForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclDataPaymentScheduleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclDataPaymentScheduleForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclDataPaymentScheduleForViewDto[] | undefined;
}

export class GetRetailEclDataPaymentScheduleForViewDto implements IGetRetailEclDataPaymentScheduleForViewDto {
    retailEclDataPaymentSchedule!: RetailEclDataPaymentScheduleDto | undefined;
    retailEclUploadTenantId!: string | undefined;

    constructor(data?: IGetRetailEclDataPaymentScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclDataPaymentSchedule = data["retailEclDataPaymentSchedule"] ? RetailEclDataPaymentScheduleDto.fromJS(data["retailEclDataPaymentSchedule"]) : <any>undefined;
            this.retailEclUploadTenantId = data["retailEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclDataPaymentScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclDataPaymentScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclDataPaymentSchedule"] = this.retailEclDataPaymentSchedule ? this.retailEclDataPaymentSchedule.toJSON() : <any>undefined;
        data["retailEclUploadTenantId"] = this.retailEclUploadTenantId;
        return data; 
    }
}

export interface IGetRetailEclDataPaymentScheduleForViewDto {
    retailEclDataPaymentSchedule: RetailEclDataPaymentScheduleDto | undefined;
    retailEclUploadTenantId: string | undefined;
}

export class RetailEclDataPaymentScheduleDto implements IRetailEclDataPaymentScheduleDto {
    contractRefNo!: string | undefined;
    startDate!: moment.Moment | undefined;
    component!: string | undefined;
    noOfSchedules!: number | undefined;
    frequency!: string | undefined;
    amount!: number | undefined;
    retailEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclDataPaymentScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractRefNo = data["contractRefNo"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.component = data["component"];
            this.noOfSchedules = data["noOfSchedules"];
            this.frequency = data["frequency"];
            this.amount = data["amount"];
            this.retailEclUploadId = data["retailEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclDataPaymentScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclDataPaymentScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractRefNo"] = this.contractRefNo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["component"] = this.component;
        data["noOfSchedules"] = this.noOfSchedules;
        data["frequency"] = this.frequency;
        data["amount"] = this.amount;
        data["retailEclUploadId"] = this.retailEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclDataPaymentScheduleDto {
    contractRefNo: string | undefined;
    startDate: moment.Moment | undefined;
    component: string | undefined;
    noOfSchedules: number | undefined;
    frequency: string | undefined;
    amount: number | undefined;
    retailEclUploadId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclDataPaymentScheduleForEditOutput implements IGetRetailEclDataPaymentScheduleForEditOutput {
    retailEclDataPaymentSchedule!: CreateOrEditRetailEclDataPaymentScheduleDto | undefined;
    retailEclUploadTenantId!: string | undefined;

    constructor(data?: IGetRetailEclDataPaymentScheduleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclDataPaymentSchedule = data["retailEclDataPaymentSchedule"] ? CreateOrEditRetailEclDataPaymentScheduleDto.fromJS(data["retailEclDataPaymentSchedule"]) : <any>undefined;
            this.retailEclUploadTenantId = data["retailEclUploadTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclDataPaymentScheduleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclDataPaymentScheduleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclDataPaymentSchedule"] = this.retailEclDataPaymentSchedule ? this.retailEclDataPaymentSchedule.toJSON() : <any>undefined;
        data["retailEclUploadTenantId"] = this.retailEclUploadTenantId;
        return data; 
    }
}

export interface IGetRetailEclDataPaymentScheduleForEditOutput {
    retailEclDataPaymentSchedule: CreateOrEditRetailEclDataPaymentScheduleDto | undefined;
    retailEclUploadTenantId: string | undefined;
}

export class CreateOrEditRetailEclDataPaymentScheduleDto implements ICreateOrEditRetailEclDataPaymentScheduleDto {
    contractRefNo!: string | undefined;
    startDate!: moment.Moment | undefined;
    component!: string | undefined;
    noOfSchedules!: number | undefined;
    frequency!: string | undefined;
    amount!: number | undefined;
    retailEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclDataPaymentScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractRefNo = data["contractRefNo"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.component = data["component"];
            this.noOfSchedules = data["noOfSchedules"];
            this.frequency = data["frequency"];
            this.amount = data["amount"];
            this.retailEclUploadId = data["retailEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclDataPaymentScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclDataPaymentScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractRefNo"] = this.contractRefNo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["component"] = this.component;
        data["noOfSchedules"] = this.noOfSchedules;
        data["frequency"] = this.frequency;
        data["amount"] = this.amount;
        data["retailEclUploadId"] = this.retailEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclDataPaymentScheduleDto {
    contractRefNo: string | undefined;
    startDate: moment.Moment | undefined;
    component: string | undefined;
    noOfSchedules: number | undefined;
    frequency: string | undefined;
    amount: number | undefined;
    retailEclUploadId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto implements IPagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclDataPaymentScheduleRetailEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclDataPaymentScheduleRetailEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclDataPaymentScheduleRetailEclUploadLookupTableDto[] | undefined;
}

export class RetailEclDataPaymentScheduleRetailEclUploadLookupTableDto implements IRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclDataPaymentScheduleRetailEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclDataPaymentScheduleRetailEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclDataPaymentScheduleRetailEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto implements IPagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclEadInputAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclEadInputAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclEadInputAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclEadInputAssumptionForViewDto[] | undefined;
}

export class GetRetailEclEadInputAssumptionForViewDto implements IGetRetailEclEadInputAssumptionForViewDto {
    retailEclEadInputAssumption!: RetailEclEadInputAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclEadInputAssumption = data["retailEclEadInputAssumption"] ? RetailEclEadInputAssumptionDto.fromJS(data["retailEclEadInputAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclEadInputAssumption"] = this.retailEclEadInputAssumption ? this.retailEclEadInputAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclEadInputAssumptionForViewDto {
    retailEclEadInputAssumption: RetailEclEadInputAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclEadInputAssumptionDto implements IRetailEclEadInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    eadGroup!: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.eadGroup = data["eadGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["eadGroup"] = this.eadGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclEadInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    eadGroup: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclEadInputAssumptionForEditOutput implements IGetRetailEclEadInputAssumptionForEditOutput {
    retailEclEadInputAssumption!: CreateOrEditRetailEclEadInputAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclEadInputAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclEadInputAssumption = data["retailEclEadInputAssumption"] ? CreateOrEditRetailEclEadInputAssumptionDto.fromJS(data["retailEclEadInputAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclEadInputAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclEadInputAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclEadInputAssumption"] = this.retailEclEadInputAssumption ? this.retailEclEadInputAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclEadInputAssumptionForEditOutput {
    retailEclEadInputAssumption: CreateOrEditRetailEclEadInputAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclEadInputAssumptionDto implements ICreateOrEditRetailEclEadInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean;
    eadGroup!: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.eadGroup = data["eadGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["eadGroup"] = this.eadGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclEadInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean;
    eadGroup: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclEadInputAssumptionRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclEadInputAssumptionRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclEadInputAssumptionRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclEadInputAssumptionRetailEclLookupTableDto[] | undefined;
}

export class RetailEclEadInputAssumptionRetailEclLookupTableDto implements IRetailEclEadInputAssumptionRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclEadInputAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclEadInputAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclEadInputAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclEadInputAssumptionRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto implements IPagedResultDtoOfGetRetailEclLgdAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclLgdAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclLgdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclLgdAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclLgdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclLgdAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclLgdAssumptionForViewDto[] | undefined;
}

export class GetRetailEclLgdAssumptionForViewDto implements IGetRetailEclLgdAssumptionForViewDto {
    retailEclLgdAssumption!: RetailEclLgdAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclLgdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclLgdAssumption = data["retailEclLgdAssumption"] ? RetailEclLgdAssumptionDto.fromJS(data["retailEclLgdAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclLgdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclLgdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclLgdAssumption"] = this.retailEclLgdAssumption ? this.retailEclLgdAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclLgdAssumptionForViewDto {
    retailEclLgdAssumption: RetailEclLgdAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclLgdAssumptionDto implements IRetailEclLgdAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    lgdGroup!: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclLgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.isComputed = data["isComputed"];
            this.lgdGroup = data["lgdGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclLgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclLgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["isComputed"] = this.isComputed;
        data["lgdGroup"] = this.lgdGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclLgdAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    lgdGroup: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclLgdAssumptionForEditOutput implements IGetRetailEclLgdAssumptionForEditOutput {
    retailEclLgdAssumption!: CreateOrEditRetailEclLgdAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclLgdAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclLgdAssumption = data["retailEclLgdAssumption"] ? CreateOrEditRetailEclLgdAssumptionDto.fromJS(data["retailEclLgdAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclLgdAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclLgdAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclLgdAssumption"] = this.retailEclLgdAssumption ? this.retailEclLgdAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclLgdAssumptionForEditOutput {
    retailEclLgdAssumption: CreateOrEditRetailEclLgdAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclLgdAssumptionDto implements ICreateOrEditRetailEclLgdAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    isComputed!: boolean;
    lgdGroup!: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclLgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.isComputed = data["isComputed"];
            this.lgdGroup = data["lgdGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclLgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclLgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["isComputed"] = this.isComputed;
        data["lgdGroup"] = this.lgdGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclLgdAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    isComputed: boolean;
    lgdGroup: LdgInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclLgdAssumptionRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclLgdAssumptionRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclLgdAssumptionRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclLgdAssumptionRetailEclLookupTableDto[] | undefined;
}

export class RetailEclLgdAssumptionRetailEclLookupTableDto implements IRetailEclLgdAssumptionRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclLgdAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclLgdAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclLgdAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclLgdAssumptionRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto implements IPagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdAssumption12MonthForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdAssumption12MonthForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdAssumption12MonthForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdAssumption12MonthForViewDto[] | undefined;
}

export class GetRetailEclPdAssumption12MonthForViewDto implements IGetRetailEclPdAssumption12MonthForViewDto {
    retailEclPdAssumption12Month!: RetailEclPdAssumption12MonthDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumption12MonthForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumption12Month = data["retailEclPdAssumption12Month"] ? RetailEclPdAssumption12MonthDto.fromJS(data["retailEclPdAssumption12Month"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumption12MonthForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumption12MonthForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumption12Month"] = this.retailEclPdAssumption12Month ? this.retailEclPdAssumption12Month.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumption12MonthForViewDto {
    retailEclPdAssumption12Month: RetailEclPdAssumption12MonthDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdAssumption12MonthDto implements IRetailEclPdAssumption12MonthDto {
    credit!: number | undefined;
    pd!: number | undefined;
    snPMappingEtiCreditPolicy!: string | undefined;
    snPMappingBestFit!: string | undefined;
    requiresGroupApproval!: boolean | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdAssumption12MonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.credit = data["credit"];
            this.pd = data["pd"];
            this.snPMappingEtiCreditPolicy = data["snPMappingEtiCreditPolicy"];
            this.snPMappingBestFit = data["snPMappingBestFit"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumption12MonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumption12MonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["credit"] = this.credit;
        data["pd"] = this.pd;
        data["snPMappingEtiCreditPolicy"] = this.snPMappingEtiCreditPolicy;
        data["snPMappingBestFit"] = this.snPMappingBestFit;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdAssumption12MonthDto {
    credit: number | undefined;
    pd: number | undefined;
    snPMappingEtiCreditPolicy: string | undefined;
    snPMappingBestFit: string | undefined;
    requiresGroupApproval: boolean | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdAssumption12MonthForEditOutput implements IGetRetailEclPdAssumption12MonthForEditOutput {
    retailEclPdAssumption12Month!: CreateOrEditRetailEclPdAssumption12MonthDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumption12MonthForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumption12Month = data["retailEclPdAssumption12Month"] ? CreateOrEditRetailEclPdAssumption12MonthDto.fromJS(data["retailEclPdAssumption12Month"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumption12MonthForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumption12MonthForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumption12Month"] = this.retailEclPdAssumption12Month ? this.retailEclPdAssumption12Month.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumption12MonthForEditOutput {
    retailEclPdAssumption12Month: CreateOrEditRetailEclPdAssumption12MonthDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdAssumption12MonthDto implements ICreateOrEditRetailEclPdAssumption12MonthDto {
    credit!: number;
    pd!: number | undefined;
    snPMappingEtiCreditPolicy!: string | undefined;
    snPMappingBestFit!: string | undefined;
    requiresGroupApproval!: boolean;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdAssumption12MonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.credit = data["credit"];
            this.pd = data["pd"];
            this.snPMappingEtiCreditPolicy = data["snPMappingEtiCreditPolicy"];
            this.snPMappingBestFit = data["snPMappingBestFit"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdAssumption12MonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdAssumption12MonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["credit"] = this.credit;
        data["pd"] = this.pd;
        data["snPMappingEtiCreditPolicy"] = this.snPMappingEtiCreditPolicy;
        data["snPMappingBestFit"] = this.snPMappingBestFit;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdAssumption12MonthDto {
    credit: number;
    pd: number | undefined;
    snPMappingEtiCreditPolicy: string | undefined;
    snPMappingBestFit: string | undefined;
    requiresGroupApproval: boolean;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdAssumption12MonthRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdAssumption12MonthRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdAssumption12MonthRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdAssumption12MonthRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdAssumption12MonthRetailEclLookupTableDto implements IRetailEclPdAssumption12MonthRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdAssumption12MonthRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumption12MonthRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumption12MonthRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdAssumption12MonthRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto implements IPagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdAssumptionMacroeconomicInputForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdAssumptionMacroeconomicInputForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicInputForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdAssumptionMacroeconomicInputForViewDto[] | undefined;
}

export class GetRetailEclPdAssumptionMacroeconomicInputForViewDto implements IGetRetailEclPdAssumptionMacroeconomicInputForViewDto {
    retailEclPdAssumptionMacroeconomicInput!: RetailEclPdAssumptionMacroeconomicInputDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionMacroeconomicInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionMacroeconomicInput = data["retailEclPdAssumptionMacroeconomicInput"] ? RetailEclPdAssumptionMacroeconomicInputDto.fromJS(data["retailEclPdAssumptionMacroeconomicInput"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionMacroeconomicInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionMacroeconomicInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionMacroeconomicInput"] = this.retailEclPdAssumptionMacroeconomicInput ? this.retailEclPdAssumptionMacroeconomicInput.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionMacroeconomicInputForViewDto {
    retailEclPdAssumptionMacroeconomicInput: RetailEclPdAssumptionMacroeconomicInputDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdAssumptionMacroeconomicInputDto implements IRetailEclPdAssumptionMacroeconomicInputDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionMacroeconomicInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionMacroeconomicInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionMacroeconomicInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdAssumptionMacroeconomicInputDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdAssumptionMacroeconomicInputForEditOutput implements IGetRetailEclPdAssumptionMacroeconomicInputForEditOutput {
    retailEclPdAssumptionMacroeconomicInput!: CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionMacroeconomicInputForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionMacroeconomicInput = data["retailEclPdAssumptionMacroeconomicInput"] ? CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto.fromJS(data["retailEclPdAssumptionMacroeconomicInput"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionMacroeconomicInputForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionMacroeconomicInputForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionMacroeconomicInput"] = this.retailEclPdAssumptionMacroeconomicInput ? this.retailEclPdAssumptionMacroeconomicInput.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionMacroeconomicInputForEditOutput {
    retailEclPdAssumptionMacroeconomicInput: CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto implements ICreateOrEditRetailEclPdAssumptionMacroeconomicInputDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdAssumptionMacroeconomicInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdAssumptionMacroeconomicInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdAssumptionMacroeconomicInputDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto implements IRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdAssumptionMacroeconomicInputRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto implements IPagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdAssumptionMacroeconomicProjectionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdAssumptionMacroeconomicProjectionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdAssumptionMacroeconomicProjectionForViewDto[] | undefined;
}

export class GetRetailEclPdAssumptionMacroeconomicProjectionForViewDto implements IGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto {
    retailEclPdAssumptionMacroeconomicProjection!: RetailEclPdAssumptionMacroeconomicProjectionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionMacroeconomicProjection = data["retailEclPdAssumptionMacroeconomicProjection"] ? RetailEclPdAssumptionMacroeconomicProjectionDto.fromJS(data["retailEclPdAssumptionMacroeconomicProjection"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionMacroeconomicProjection"] = this.retailEclPdAssumptionMacroeconomicProjection ? this.retailEclPdAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionMacroeconomicProjectionForViewDto {
    retailEclPdAssumptionMacroeconomicProjection: RetailEclPdAssumptionMacroeconomicProjectionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdAssumptionMacroeconomicProjectionDto implements IRetailEclPdAssumptionMacroeconomicProjectionDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdAssumptionMacroeconomicProjectionDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput implements IGetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput {
    retailEclPdAssumptionMacroeconomicProjection!: CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionMacroeconomicProjection = data["retailEclPdAssumptionMacroeconomicProjection"] ? CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto.fromJS(data["retailEclPdAssumptionMacroeconomicProjection"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionMacroeconomicProjection"] = this.retailEclPdAssumptionMacroeconomicProjection ? this.retailEclPdAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionMacroeconomicProjectionForEditOutput {
    retailEclPdAssumptionMacroeconomicProjection: CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto implements ICreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdAssumptionMacroeconomicProjectionDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto implements IRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdAssumptionMacroeconomicProjectionRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto implements IPagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdAssumptionNonInteralModelForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdAssumptionNonInteralModelForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdAssumptionNonInteralModelForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdAssumptionNonInteralModelForViewDto[] | undefined;
}

export class GetRetailEclPdAssumptionNonInteralModelForViewDto implements IGetRetailEclPdAssumptionNonInteralModelForViewDto {
    retailEclPdAssumptionNonInteralModel!: RetailEclPdAssumptionNonInteralModelDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionNonInteralModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionNonInteralModel = data["retailEclPdAssumptionNonInteralModel"] ? RetailEclPdAssumptionNonInteralModelDto.fromJS(data["retailEclPdAssumptionNonInteralModel"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionNonInteralModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionNonInteralModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionNonInteralModel"] = this.retailEclPdAssumptionNonInteralModel ? this.retailEclPdAssumptionNonInteralModel.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionNonInteralModelForViewDto {
    retailEclPdAssumptionNonInteralModel: RetailEclPdAssumptionNonInteralModelDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdAssumptionNonInteralModelDto implements IRetailEclPdAssumptionNonInteralModelDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionNonInteralModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionNonInteralModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionNonInteralModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdAssumptionNonInteralModelDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdAssumptionNonInteralModelForEditOutput implements IGetRetailEclPdAssumptionNonInteralModelForEditOutput {
    retailEclPdAssumptionNonInteralModel!: CreateOrEditRetailEclPdAssumptionNonInteralModelDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionNonInteralModelForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionNonInteralModel = data["retailEclPdAssumptionNonInteralModel"] ? CreateOrEditRetailEclPdAssumptionNonInteralModelDto.fromJS(data["retailEclPdAssumptionNonInteralModel"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionNonInteralModelForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionNonInteralModelForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionNonInteralModel"] = this.retailEclPdAssumptionNonInteralModel ? this.retailEclPdAssumptionNonInteralModel.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionNonInteralModelForEditOutput {
    retailEclPdAssumptionNonInteralModel: CreateOrEditRetailEclPdAssumptionNonInteralModelDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdAssumptionNonInteralModelDto implements ICreateOrEditRetailEclPdAssumptionNonInteralModelDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdAssumptionNonInteralModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdAssumptionNonInteralModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdAssumptionNonInteralModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdAssumptionNonInteralModelDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto implements IRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdAssumptionNonInteralModelRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto implements IPagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdAssumptionNplIndexForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdAssumptionNplIndexForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdAssumptionNplIndexForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdAssumptionNplIndexForViewDto[] | undefined;
}

export class GetRetailEclPdAssumptionNplIndexForViewDto implements IGetRetailEclPdAssumptionNplIndexForViewDto {
    retailEclPdAssumptionNplIndex!: RetailEclPdAssumptionNplIndexDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionNplIndex = data["retailEclPdAssumptionNplIndex"] ? RetailEclPdAssumptionNplIndexDto.fromJS(data["retailEclPdAssumptionNplIndex"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionNplIndex"] = this.retailEclPdAssumptionNplIndex ? this.retailEclPdAssumptionNplIndex.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionNplIndexForViewDto {
    retailEclPdAssumptionNplIndex: RetailEclPdAssumptionNplIndexDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdAssumptionNplIndexDto implements IRetailEclPdAssumptionNplIndexDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdAssumptionNplIndexDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdAssumptionNplIndexForEditOutput implements IGetRetailEclPdAssumptionNplIndexForEditOutput {
    retailEclPdAssumptionNplIndex!: CreateOrEditRetailEclPdAssumptionNplIndexDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionNplIndexForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumptionNplIndex = data["retailEclPdAssumptionNplIndex"] ? CreateOrEditRetailEclPdAssumptionNplIndexDto.fromJS(data["retailEclPdAssumptionNplIndex"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionNplIndexForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionNplIndexForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumptionNplIndex"] = this.retailEclPdAssumptionNplIndex ? this.retailEclPdAssumptionNplIndex.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionNplIndexForEditOutput {
    retailEclPdAssumptionNplIndex: CreateOrEditRetailEclPdAssumptionNplIndexDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdAssumptionNplIndexDto implements ICreateOrEditRetailEclPdAssumptionNplIndexDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdAssumptionNplIndexDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdAssumptionNplIndexRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdAssumptionNplIndexRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdAssumptionNplIndexRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdAssumptionNplIndexRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdAssumptionNplIndexRetailEclLookupTableDto implements IRetailEclPdAssumptionNplIndexRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionNplIndexRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionNplIndexRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionNplIndexRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdAssumptionNplIndexRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdAssumptionForViewDto implements IPagedResultDtoOfGetRetailEclPdAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdAssumptionForViewDto[] | undefined;
}

export class GetRetailEclPdAssumptionForViewDto implements IGetRetailEclPdAssumptionForViewDto {
    retailEclPdAssumption!: RetailEclPdAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumption = data["retailEclPdAssumption"] ? RetailEclPdAssumptionDto.fromJS(data["retailEclPdAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumption"] = this.retailEclPdAssumption ? this.retailEclPdAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionForViewDto {
    retailEclPdAssumption: RetailEclPdAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdAssumptionDto implements IRetailEclPdAssumptionDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdAssumptionDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdAssumptionForEditOutput implements IGetRetailEclPdAssumptionForEditOutput {
    retailEclPdAssumption!: CreateOrEditRetailEclPdAssumptionDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdAssumption = data["retailEclPdAssumption"] ? CreateOrEditRetailEclPdAssumptionDto.fromJS(data["retailEclPdAssumption"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdAssumption"] = this.retailEclPdAssumption ? this.retailEclPdAssumption.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdAssumptionForEditOutput {
    retailEclPdAssumption: CreateOrEditRetailEclPdAssumptionDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdAssumptionDto implements ICreateOrEditRetailEclPdAssumptionDto {
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdAssumptionDto {
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdAssumptionRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdAssumptionRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdAssumptionRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdAssumptionRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdAssumptionRetailEclLookupTableDto implements IRetailEclPdAssumptionRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdAssumptionRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdAssumptionRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdAssumptionRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdAssumptionRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto implements IPagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclPdSnPCummulativeDefaultRateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclPdSnPCummulativeDefaultRateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclPdSnPCummulativeDefaultRateForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclPdSnPCummulativeDefaultRateForViewDto[] | undefined;
}

export class GetRetailEclPdSnPCummulativeDefaultRateForViewDto implements IGetRetailEclPdSnPCummulativeDefaultRateForViewDto {
    retailEclPdSnPCummulativeDefaultRate!: RetailEclPdSnPCummulativeDefaultRateDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdSnPCummulativeDefaultRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdSnPCummulativeDefaultRate = data["retailEclPdSnPCummulativeDefaultRate"] ? RetailEclPdSnPCummulativeDefaultRateDto.fromJS(data["retailEclPdSnPCummulativeDefaultRate"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdSnPCummulativeDefaultRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdSnPCummulativeDefaultRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdSnPCummulativeDefaultRate"] = this.retailEclPdSnPCummulativeDefaultRate ? this.retailEclPdSnPCummulativeDefaultRate.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdSnPCummulativeDefaultRateForViewDto {
    retailEclPdSnPCummulativeDefaultRate: RetailEclPdSnPCummulativeDefaultRateDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclPdSnPCummulativeDefaultRateDto implements IRetailEclPdSnPCummulativeDefaultRateDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    requiresGroupApproval!: boolean | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclPdSnPCummulativeDefaultRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclPdSnPCummulativeDefaultRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdSnPCummulativeDefaultRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclPdSnPCummulativeDefaultRateDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    requiresGroupApproval: boolean | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclPdSnPCummulativeDefaultRateForEditOutput implements IGetRetailEclPdSnPCummulativeDefaultRateForEditOutput {
    retailEclPdSnPCummulativeDefaultRate!: CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclPdSnPCummulativeDefaultRateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclPdSnPCummulativeDefaultRate = data["retailEclPdSnPCummulativeDefaultRate"] ? CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto.fromJS(data["retailEclPdSnPCummulativeDefaultRate"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclPdSnPCummulativeDefaultRateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclPdSnPCummulativeDefaultRateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclPdSnPCummulativeDefaultRate"] = this.retailEclPdSnPCummulativeDefaultRate ? this.retailEclPdSnPCummulativeDefaultRate.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclPdSnPCummulativeDefaultRateForEditOutput {
    retailEclPdSnPCummulativeDefaultRate: CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto implements ICreateOrEditRetailEclPdSnPCummulativeDefaultRateDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    requiresGroupApproval!: boolean;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclPdSnPCummulativeDefaultRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclPdSnPCummulativeDefaultRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclPdSnPCummulativeDefaultRateDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    requiresGroupApproval: boolean;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto[] | undefined;
}

export class RetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto implements IRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclPdSnPCummulativeDefaultRateRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclResultDetailForViewDto implements IPagedResultDtoOfGetRetailEclResultDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclResultDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclResultDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclResultDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclResultDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclResultDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclResultDetailForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclResultDetailForViewDto[] | undefined;
}

export class GetRetailEclResultDetailForViewDto implements IGetRetailEclResultDetailForViewDto {
    retailEclResultDetail!: RetailEclResultDetailDto | undefined;
    retailEclTenantId!: string | undefined;
    retailEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetRetailEclResultDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultDetail = data["retailEclResultDetail"] ? RetailEclResultDetailDto.fromJS(data["retailEclResultDetail"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
            this.retailEclDataLoanBookCustomerName = data["retailEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetRetailEclResultDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultDetail"] = this.retailEclResultDetail ? this.retailEclResultDetail.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        data["retailEclDataLoanBookCustomerName"] = this.retailEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetRetailEclResultDetailForViewDto {
    retailEclResultDetail: RetailEclResultDetailDto | undefined;
    retailEclTenantId: string | undefined;
    retailEclDataLoanBookCustomerName: string | undefined;
}

export class RetailEclResultDetailDto implements IRetailEclResultDetailDto {
    contractID!: string | undefined;
    accountNo!: string | undefined;
    customerNo!: string | undefined;
    segment!: string | undefined;
    productType!: string | undefined;
    sector!: string | undefined;
    stage!: number | undefined;
    outstandingBalance!: number | undefined;
    preOverrideEclBest!: number | undefined;
    preOverrideEclOptimistic!: number | undefined;
    preOverrideEclDownturn!: number | undefined;
    overrideStage!: number | undefined;
    overrideTTRYears!: number | undefined;
    overrideFSV!: number | undefined;
    overrideOverlay!: number | undefined;
    postOverrideEclBest!: number | undefined;
    postOverrideEclOptimistic!: number | undefined;
    postOverrideEclDownturn!: number | undefined;
    preOverrideImpairment!: number | undefined;
    postOverrideImpairment!: number | undefined;
    retailEclId!: string | undefined;
    retailEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractID = data["contractID"];
            this.accountNo = data["accountNo"];
            this.customerNo = data["customerNo"];
            this.segment = data["segment"];
            this.productType = data["productType"];
            this.sector = data["sector"];
            this.stage = data["stage"];
            this.outstandingBalance = data["outstandingBalance"];
            this.preOverrideEclBest = data["preOverrideEclBest"];
            this.preOverrideEclOptimistic = data["preOverrideEclOptimistic"];
            this.preOverrideEclDownturn = data["preOverrideEclDownturn"];
            this.overrideStage = data["overrideStage"];
            this.overrideTTRYears = data["overrideTTRYears"];
            this.overrideFSV = data["overrideFSV"];
            this.overrideOverlay = data["overrideOverlay"];
            this.postOverrideEclBest = data["postOverrideEclBest"];
            this.postOverrideEclOptimistic = data["postOverrideEclOptimistic"];
            this.postOverrideEclDownturn = data["postOverrideEclDownturn"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.retailEclId = data["retailEclId"];
            this.retailEclDataLoanBookId = data["retailEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractID"] = this.contractID;
        data["accountNo"] = this.accountNo;
        data["customerNo"] = this.customerNo;
        data["segment"] = this.segment;
        data["productType"] = this.productType;
        data["sector"] = this.sector;
        data["stage"] = this.stage;
        data["outstandingBalance"] = this.outstandingBalance;
        data["preOverrideEclBest"] = this.preOverrideEclBest;
        data["preOverrideEclOptimistic"] = this.preOverrideEclOptimistic;
        data["preOverrideEclDownturn"] = this.preOverrideEclDownturn;
        data["overrideStage"] = this.overrideStage;
        data["overrideTTRYears"] = this.overrideTTRYears;
        data["overrideFSV"] = this.overrideFSV;
        data["overrideOverlay"] = this.overrideOverlay;
        data["postOverrideEclBest"] = this.postOverrideEclBest;
        data["postOverrideEclOptimistic"] = this.postOverrideEclOptimistic;
        data["postOverrideEclDownturn"] = this.postOverrideEclDownturn;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["retailEclId"] = this.retailEclId;
        data["retailEclDataLoanBookId"] = this.retailEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclResultDetailDto {
    contractID: string | undefined;
    accountNo: string | undefined;
    customerNo: string | undefined;
    segment: string | undefined;
    productType: string | undefined;
    sector: string | undefined;
    stage: number | undefined;
    outstandingBalance: number | undefined;
    preOverrideEclBest: number | undefined;
    preOverrideEclOptimistic: number | undefined;
    preOverrideEclDownturn: number | undefined;
    overrideStage: number | undefined;
    overrideTTRYears: number | undefined;
    overrideFSV: number | undefined;
    overrideOverlay: number | undefined;
    postOverrideEclBest: number | undefined;
    postOverrideEclOptimistic: number | undefined;
    postOverrideEclDownturn: number | undefined;
    preOverrideImpairment: number | undefined;
    postOverrideImpairment: number | undefined;
    retailEclId: string | undefined;
    retailEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclResultDetailForEditOutput implements IGetRetailEclResultDetailForEditOutput {
    retailEclResultDetail!: CreateOrEditRetailEclResultDetailDto | undefined;
    retailEclTenantId!: string | undefined;
    retailEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetRetailEclResultDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultDetail = data["retailEclResultDetail"] ? CreateOrEditRetailEclResultDetailDto.fromJS(data["retailEclResultDetail"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
            this.retailEclDataLoanBookCustomerName = data["retailEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetRetailEclResultDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultDetail"] = this.retailEclResultDetail ? this.retailEclResultDetail.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        data["retailEclDataLoanBookCustomerName"] = this.retailEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetRetailEclResultDetailForEditOutput {
    retailEclResultDetail: CreateOrEditRetailEclResultDetailDto | undefined;
    retailEclTenantId: string | undefined;
    retailEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditRetailEclResultDetailDto implements ICreateOrEditRetailEclResultDetailDto {
    contractID!: string | undefined;
    accountNo!: string | undefined;
    customerNo!: string | undefined;
    segment!: string | undefined;
    productType!: string | undefined;
    sector!: string | undefined;
    stage!: number | undefined;
    outstandingBalance!: number | undefined;
    preOverrideEclBest!: number | undefined;
    preOverrideEclOptimistic!: number | undefined;
    preOverrideEclDownturn!: number | undefined;
    overrideStage!: number | undefined;
    overrideTTRYears!: number | undefined;
    overrideFSV!: number | undefined;
    overrideOverlay!: number | undefined;
    postOverrideEclBest!: number | undefined;
    postOverrideEclOptimistic!: number | undefined;
    postOverrideEclDownturn!: number | undefined;
    preOverrideImpairment!: number | undefined;
    postOverrideImpairment!: number | undefined;
    retailEclId!: string | undefined;
    retailEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractID = data["contractID"];
            this.accountNo = data["accountNo"];
            this.customerNo = data["customerNo"];
            this.segment = data["segment"];
            this.productType = data["productType"];
            this.sector = data["sector"];
            this.stage = data["stage"];
            this.outstandingBalance = data["outstandingBalance"];
            this.preOverrideEclBest = data["preOverrideEclBest"];
            this.preOverrideEclOptimistic = data["preOverrideEclOptimistic"];
            this.preOverrideEclDownturn = data["preOverrideEclDownturn"];
            this.overrideStage = data["overrideStage"];
            this.overrideTTRYears = data["overrideTTRYears"];
            this.overrideFSV = data["overrideFSV"];
            this.overrideOverlay = data["overrideOverlay"];
            this.postOverrideEclBest = data["postOverrideEclBest"];
            this.postOverrideEclOptimistic = data["postOverrideEclOptimistic"];
            this.postOverrideEclDownturn = data["postOverrideEclDownturn"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.retailEclId = data["retailEclId"];
            this.retailEclDataLoanBookId = data["retailEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractID"] = this.contractID;
        data["accountNo"] = this.accountNo;
        data["customerNo"] = this.customerNo;
        data["segment"] = this.segment;
        data["productType"] = this.productType;
        data["sector"] = this.sector;
        data["stage"] = this.stage;
        data["outstandingBalance"] = this.outstandingBalance;
        data["preOverrideEclBest"] = this.preOverrideEclBest;
        data["preOverrideEclOptimistic"] = this.preOverrideEclOptimistic;
        data["preOverrideEclDownturn"] = this.preOverrideEclDownturn;
        data["overrideStage"] = this.overrideStage;
        data["overrideTTRYears"] = this.overrideTTRYears;
        data["overrideFSV"] = this.overrideFSV;
        data["overrideOverlay"] = this.overrideOverlay;
        data["postOverrideEclBest"] = this.postOverrideEclBest;
        data["postOverrideEclOptimistic"] = this.postOverrideEclOptimistic;
        data["postOverrideEclDownturn"] = this.postOverrideEclDownturn;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["retailEclId"] = this.retailEclId;
        data["retailEclDataLoanBookId"] = this.retailEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclResultDetailDto {
    contractID: string | undefined;
    accountNo: string | undefined;
    customerNo: string | undefined;
    segment: string | undefined;
    productType: string | undefined;
    sector: string | undefined;
    stage: number | undefined;
    outstandingBalance: number | undefined;
    preOverrideEclBest: number | undefined;
    preOverrideEclOptimistic: number | undefined;
    preOverrideEclDownturn: number | undefined;
    overrideStage: number | undefined;
    overrideTTRYears: number | undefined;
    overrideFSV: number | undefined;
    overrideOverlay: number | undefined;
    postOverrideEclBest: number | undefined;
    postOverrideEclOptimistic: number | undefined;
    postOverrideEclDownturn: number | undefined;
    preOverrideImpairment: number | undefined;
    postOverrideImpairment: number | undefined;
    retailEclId: string | undefined;
    retailEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclResultDetailRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclResultDetailRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclResultDetailRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclResultDetailRetailEclLookupTableDto[] | undefined;
}

export class RetailEclResultDetailRetailEclLookupTableDto implements IRetailEclResultDetailRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclResultDetailRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclResultDetailRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultDetailRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclResultDetailRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto implements IPagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclResultDetailRetailEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclResultDetailRetailEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclResultDetailRetailEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclResultDetailRetailEclDataLoanBookLookupTableDto[] | undefined;
}

export class RetailEclResultDetailRetailEclDataLoanBookLookupTableDto implements IRetailEclResultDetailRetailEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclResultDetailRetailEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclResultDetailRetailEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultDetailRetailEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclResultDetailRetailEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclResultSummaryForViewDto implements IPagedResultDtoOfGetRetailEclResultSummaryForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclResultSummaryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclResultSummaryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclResultSummaryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclResultSummaryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclResultSummaryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclResultSummaryForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclResultSummaryForViewDto[] | undefined;
}

export class GetRetailEclResultSummaryForViewDto implements IGetRetailEclResultSummaryForViewDto {
    retailEclResultSummary!: RetailEclResultSummaryDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclResultSummaryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultSummary = data["retailEclResultSummary"] ? RetailEclResultSummaryDto.fromJS(data["retailEclResultSummary"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclResultSummaryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultSummaryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultSummary"] = this.retailEclResultSummary ? this.retailEclResultSummary.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclResultSummaryForViewDto {
    retailEclResultSummary: RetailEclResultSummaryDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclResultSummaryDto implements IRetailEclResultSummaryDto {
    summaryType!: ResultSummaryTypeEnum | undefined;
    title!: string | undefined;
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclResultSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.summaryType = data["summaryType"];
            this.title = data["title"];
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summaryType"] = this.summaryType;
        data["title"] = this.title;
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclResultSummaryDto {
    summaryType: ResultSummaryTypeEnum | undefined;
    title: string | undefined;
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclResultSummaryForEditOutput implements IGetRetailEclResultSummaryForEditOutput {
    retailEclResultSummary!: CreateOrEditRetailEclResultSummaryDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclResultSummaryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultSummary = data["retailEclResultSummary"] ? CreateOrEditRetailEclResultSummaryDto.fromJS(data["retailEclResultSummary"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclResultSummaryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultSummaryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultSummary"] = this.retailEclResultSummary ? this.retailEclResultSummary.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclResultSummaryForEditOutput {
    retailEclResultSummary: CreateOrEditRetailEclResultSummaryDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclResultSummaryDto implements ICreateOrEditRetailEclResultSummaryDto {
    summaryType!: ResultSummaryTypeEnum | undefined;
    title!: string | undefined;
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclResultSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.summaryType = data["summaryType"];
            this.title = data["title"];
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclResultSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclResultSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summaryType"] = this.summaryType;
        data["title"] = this.title;
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclResultSummaryDto {
    summaryType: ResultSummaryTypeEnum | undefined;
    title: string | undefined;
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclResultSummaryRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclResultSummaryRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclResultSummaryRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclResultSummaryRetailEclLookupTableDto[] | undefined;
}

export class RetailEclResultSummaryRetailEclLookupTableDto implements IRetailEclResultSummaryRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclResultSummaryRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclResultSummaryRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto implements IPagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclResultSummaryKeyInputForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclResultSummaryKeyInputForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclResultSummaryKeyInputForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclResultSummaryKeyInputForViewDto[] | undefined;
}

export class GetRetailEclResultSummaryKeyInputForViewDto implements IGetRetailEclResultSummaryKeyInputForViewDto {
    retailEclResultSummaryKeyInput!: RetailEclResultSummaryKeyInputDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclResultSummaryKeyInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultSummaryKeyInput = data["retailEclResultSummaryKeyInput"] ? RetailEclResultSummaryKeyInputDto.fromJS(data["retailEclResultSummaryKeyInput"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclResultSummaryKeyInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultSummaryKeyInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultSummaryKeyInput"] = this.retailEclResultSummaryKeyInput ? this.retailEclResultSummaryKeyInput.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclResultSummaryKeyInputForViewDto {
    retailEclResultSummaryKeyInput: RetailEclResultSummaryKeyInputDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclResultSummaryKeyInputDto implements IRetailEclResultSummaryKeyInputDto {
    pdGrouping!: string | undefined;
    exposure!: number | undefined;
    collateral!: number | undefined;
    unsecuredPercentage!: number | undefined;
    percentageOfBook!: number | undefined;
    months6CummulativeBestPDs!: number | undefined;
    months12CummulativeBestPDs!: number | undefined;
    months24CummulativeBestPDs!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclResultSummaryKeyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdGrouping = data["pdGrouping"];
            this.exposure = data["exposure"];
            this.collateral = data["collateral"];
            this.unsecuredPercentage = data["unsecuredPercentage"];
            this.percentageOfBook = data["percentageOfBook"];
            this.months6CummulativeBestPDs = data["months6CummulativeBestPDs"];
            this.months12CummulativeBestPDs = data["months12CummulativeBestPDs"];
            this.months24CummulativeBestPDs = data["months24CummulativeBestPDs"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryKeyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryKeyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdGrouping"] = this.pdGrouping;
        data["exposure"] = this.exposure;
        data["collateral"] = this.collateral;
        data["unsecuredPercentage"] = this.unsecuredPercentage;
        data["percentageOfBook"] = this.percentageOfBook;
        data["months6CummulativeBestPDs"] = this.months6CummulativeBestPDs;
        data["months12CummulativeBestPDs"] = this.months12CummulativeBestPDs;
        data["months24CummulativeBestPDs"] = this.months24CummulativeBestPDs;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclResultSummaryKeyInputDto {
    pdGrouping: string | undefined;
    exposure: number | undefined;
    collateral: number | undefined;
    unsecuredPercentage: number | undefined;
    percentageOfBook: number | undefined;
    months6CummulativeBestPDs: number | undefined;
    months12CummulativeBestPDs: number | undefined;
    months24CummulativeBestPDs: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclResultSummaryKeyInputForEditOutput implements IGetRetailEclResultSummaryKeyInputForEditOutput {
    retailEclResultSummaryKeyInput!: CreateOrEditRetailEclResultSummaryKeyInputDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclResultSummaryKeyInputForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultSummaryKeyInput = data["retailEclResultSummaryKeyInput"] ? CreateOrEditRetailEclResultSummaryKeyInputDto.fromJS(data["retailEclResultSummaryKeyInput"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclResultSummaryKeyInputForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultSummaryKeyInputForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultSummaryKeyInput"] = this.retailEclResultSummaryKeyInput ? this.retailEclResultSummaryKeyInput.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclResultSummaryKeyInputForEditOutput {
    retailEclResultSummaryKeyInput: CreateOrEditRetailEclResultSummaryKeyInputDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclResultSummaryKeyInputDto implements ICreateOrEditRetailEclResultSummaryKeyInputDto {
    pdGrouping!: string | undefined;
    exposure!: number | undefined;
    collateral!: number | undefined;
    unsecuredPercentage!: number | undefined;
    percentageOfBook!: number | undefined;
    months6CummulativeBestPDs!: number | undefined;
    months12CummulativeBestPDs!: number | undefined;
    months24CummulativeBestPDs!: number | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclResultSummaryKeyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdGrouping = data["pdGrouping"];
            this.exposure = data["exposure"];
            this.collateral = data["collateral"];
            this.unsecuredPercentage = data["unsecuredPercentage"];
            this.percentageOfBook = data["percentageOfBook"];
            this.months6CummulativeBestPDs = data["months6CummulativeBestPDs"];
            this.months12CummulativeBestPDs = data["months12CummulativeBestPDs"];
            this.months24CummulativeBestPDs = data["months24CummulativeBestPDs"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclResultSummaryKeyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclResultSummaryKeyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdGrouping"] = this.pdGrouping;
        data["exposure"] = this.exposure;
        data["collateral"] = this.collateral;
        data["unsecuredPercentage"] = this.unsecuredPercentage;
        data["percentageOfBook"] = this.percentageOfBook;
        data["months6CummulativeBestPDs"] = this.months6CummulativeBestPDs;
        data["months12CummulativeBestPDs"] = this.months12CummulativeBestPDs;
        data["months24CummulativeBestPDs"] = this.months24CummulativeBestPDs;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclResultSummaryKeyInputDto {
    pdGrouping: string | undefined;
    exposure: number | undefined;
    collateral: number | undefined;
    unsecuredPercentage: number | undefined;
    percentageOfBook: number | undefined;
    months6CummulativeBestPDs: number | undefined;
    months12CummulativeBestPDs: number | undefined;
    months24CummulativeBestPDs: number | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclResultSummaryKeyInputRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclResultSummaryKeyInputRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclResultSummaryKeyInputRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclResultSummaryKeyInputRetailEclLookupTableDto[] | undefined;
}

export class RetailEclResultSummaryKeyInputRetailEclLookupTableDto implements IRetailEclResultSummaryKeyInputRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclResultSummaryKeyInputRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryKeyInputRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryKeyInputRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclResultSummaryKeyInputRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto implements IPagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclResultSummaryTopExposureForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclResultSummaryTopExposureForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclResultSummaryTopExposureForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclResultSummaryTopExposureForViewDto[] | undefined;
}

export class GetRetailEclResultSummaryTopExposureForViewDto implements IGetRetailEclResultSummaryTopExposureForViewDto {
    retailEclResultSummaryTopExposure!: RetailEclResultSummaryTopExposureDto | undefined;
    retailEclTenantId!: string | undefined;
    retailEclDataLoanBookContractNo!: string | undefined;

    constructor(data?: IGetRetailEclResultSummaryTopExposureForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultSummaryTopExposure = data["retailEclResultSummaryTopExposure"] ? RetailEclResultSummaryTopExposureDto.fromJS(data["retailEclResultSummaryTopExposure"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
            this.retailEclDataLoanBookContractNo = data["retailEclDataLoanBookContractNo"];
        }
    }

    static fromJS(data: any): GetRetailEclResultSummaryTopExposureForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultSummaryTopExposureForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultSummaryTopExposure"] = this.retailEclResultSummaryTopExposure ? this.retailEclResultSummaryTopExposure.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        data["retailEclDataLoanBookContractNo"] = this.retailEclDataLoanBookContractNo;
        return data; 
    }
}

export interface IGetRetailEclResultSummaryTopExposureForViewDto {
    retailEclResultSummaryTopExposure: RetailEclResultSummaryTopExposureDto | undefined;
    retailEclTenantId: string | undefined;
    retailEclDataLoanBookContractNo: string | undefined;
}

export class RetailEclResultSummaryTopExposureDto implements IRetailEclResultSummaryTopExposureDto {
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    retailEclId!: string | undefined;
    retailEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclResultSummaryTopExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.retailEclId = data["retailEclId"];
            this.retailEclDataLoanBookId = data["retailEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryTopExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryTopExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["retailEclId"] = this.retailEclId;
        data["retailEclDataLoanBookId"] = this.retailEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclResultSummaryTopExposureDto {
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    retailEclId: string | undefined;
    retailEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclResultSummaryTopExposureForEditOutput implements IGetRetailEclResultSummaryTopExposureForEditOutput {
    retailEclResultSummaryTopExposure!: CreateOrEditRetailEclResultSummaryTopExposureDto | undefined;
    retailEclTenantId!: string | undefined;
    retailEclDataLoanBookContractNo!: string | undefined;

    constructor(data?: IGetRetailEclResultSummaryTopExposureForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclResultSummaryTopExposure = data["retailEclResultSummaryTopExposure"] ? CreateOrEditRetailEclResultSummaryTopExposureDto.fromJS(data["retailEclResultSummaryTopExposure"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
            this.retailEclDataLoanBookContractNo = data["retailEclDataLoanBookContractNo"];
        }
    }

    static fromJS(data: any): GetRetailEclResultSummaryTopExposureForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclResultSummaryTopExposureForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclResultSummaryTopExposure"] = this.retailEclResultSummaryTopExposure ? this.retailEclResultSummaryTopExposure.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        data["retailEclDataLoanBookContractNo"] = this.retailEclDataLoanBookContractNo;
        return data; 
    }
}

export interface IGetRetailEclResultSummaryTopExposureForEditOutput {
    retailEclResultSummaryTopExposure: CreateOrEditRetailEclResultSummaryTopExposureDto | undefined;
    retailEclTenantId: string | undefined;
    retailEclDataLoanBookContractNo: string | undefined;
}

export class CreateOrEditRetailEclResultSummaryTopExposureDto implements ICreateOrEditRetailEclResultSummaryTopExposureDto {
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    retailEclId!: string | undefined;
    retailEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclResultSummaryTopExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.retailEclId = data["retailEclId"];
            this.retailEclDataLoanBookId = data["retailEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclResultSummaryTopExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclResultSummaryTopExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["retailEclId"] = this.retailEclId;
        data["retailEclDataLoanBookId"] = this.retailEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclResultSummaryTopExposureDto {
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    retailEclId: string | undefined;
    retailEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclResultSummaryTopExposureRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclResultSummaryTopExposureRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclResultSummaryTopExposureRetailEclLookupTableDto[] | undefined;
}

export class RetailEclResultSummaryTopExposureRetailEclLookupTableDto implements IRetailEclResultSummaryTopExposureRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclResultSummaryTopExposureRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryTopExposureRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryTopExposureRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclResultSummaryTopExposureRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto implements IPagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto[] | undefined;
}

export class RetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto implements IRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclResultSummaryTopExposureRetailEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclForViewDto implements IPagedResultDtoOfGetRetailEclForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclForViewDto[] | undefined;
}

export class GetRetailEclForViewDto implements IGetRetailEclForViewDto {
    retailEcl!: RetailEclDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRetailEclForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEcl = data["retailEcl"] ? RetailEclDto.fromJS(data["retailEcl"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRetailEclForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEcl"] = this.retailEcl ? this.retailEcl.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRetailEclForViewDto {
    retailEcl: RetailEclDto | undefined;
    userName: string | undefined;
}

export class RetailEclDto implements IRetailEclDto {
    reportingDate!: moment.Moment | undefined;
    closedDate!: moment.Moment | undefined;
    isApproved!: boolean | undefined;
    status!: EclStatusEnum | undefined;
    closedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.closedDate = data["closedDate"] ? moment(data["closedDate"].toString()) : <any>undefined;
            this.isApproved = data["isApproved"];
            this.status = data["status"];
            this.closedByUserId = data["closedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["closedDate"] = this.closedDate ? this.closedDate.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["closedByUserId"] = this.closedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclDto {
    reportingDate: moment.Moment | undefined;
    closedDate: moment.Moment | undefined;
    isApproved: boolean | undefined;
    status: EclStatusEnum | undefined;
    closedByUserId: number | undefined;
    id: string | undefined;
}

export class GetRetailEclForEditOutput implements IGetRetailEclForEditOutput {
    retailEcl!: CreateOrEditRetailEclDto | undefined;
    country!: string | undefined;
    createdByUserName!: string | undefined;
    closedByUserName!: string | undefined;
    frameworkAssumption!: CreateOrEditRetailEclAssumptionDto[] | undefined;
    eadInputAssumptions!: CreateOrEditRetailEclEadInputAssumptionDto[] | undefined;
    lgdInputAssumptions!: CreateOrEditRetailEclLgdAssumptionDto[] | undefined;

    constructor(data?: IGetRetailEclForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEcl = data["retailEcl"] ? CreateOrEditRetailEclDto.fromJS(data["retailEcl"]) : <any>undefined;
            this.country = data["country"];
            this.createdByUserName = data["createdByUserName"];
            this.closedByUserName = data["closedByUserName"];
            if (data["frameworkAssumption"] && data["frameworkAssumption"].constructor === Array) {
                this.frameworkAssumption = [] as any;
                for (let item of data["frameworkAssumption"])
                    this.frameworkAssumption!.push(CreateOrEditRetailEclAssumptionDto.fromJS(item));
            }
            if (data["eadInputAssumptions"] && data["eadInputAssumptions"].constructor === Array) {
                this.eadInputAssumptions = [] as any;
                for (let item of data["eadInputAssumptions"])
                    this.eadInputAssumptions!.push(CreateOrEditRetailEclEadInputAssumptionDto.fromJS(item));
            }
            if (data["lgdInputAssumptions"] && data["lgdInputAssumptions"].constructor === Array) {
                this.lgdInputAssumptions = [] as any;
                for (let item of data["lgdInputAssumptions"])
                    this.lgdInputAssumptions!.push(CreateOrEditRetailEclLgdAssumptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRetailEclForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEcl"] = this.retailEcl ? this.retailEcl.toJSON() : <any>undefined;
        data["country"] = this.country;
        data["createdByUserName"] = this.createdByUserName;
        data["closedByUserName"] = this.closedByUserName;
        if (this.frameworkAssumption && this.frameworkAssumption.constructor === Array) {
            data["frameworkAssumption"] = [];
            for (let item of this.frameworkAssumption)
                data["frameworkAssumption"].push(item.toJSON());
        }
        if (this.eadInputAssumptions && this.eadInputAssumptions.constructor === Array) {
            data["eadInputAssumptions"] = [];
            for (let item of this.eadInputAssumptions)
                data["eadInputAssumptions"].push(item.toJSON());
        }
        if (this.lgdInputAssumptions && this.lgdInputAssumptions.constructor === Array) {
            data["lgdInputAssumptions"] = [];
            for (let item of this.lgdInputAssumptions)
                data["lgdInputAssumptions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRetailEclForEditOutput {
    retailEcl: CreateOrEditRetailEclDto | undefined;
    country: string | undefined;
    createdByUserName: string | undefined;
    closedByUserName: string | undefined;
    frameworkAssumption: CreateOrEditRetailEclAssumptionDto[] | undefined;
    eadInputAssumptions: CreateOrEditRetailEclEadInputAssumptionDto[] | undefined;
    lgdInputAssumptions: CreateOrEditRetailEclLgdAssumptionDto[] | undefined;
}

export class CreateOrEditRetailEclDto implements ICreateOrEditRetailEclDto {
    reportingDate!: moment.Moment;
    closedDate!: moment.Moment | undefined;
    isApproved!: boolean;
    status!: EclStatusEnum | undefined;
    closedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.closedDate = data["closedDate"] ? moment(data["closedDate"].toString()) : <any>undefined;
            this.isApproved = data["isApproved"];
            this.status = data["status"];
            this.closedByUserId = data["closedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["closedDate"] = this.closedDate ? this.closedDate.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["closedByUserId"] = this.closedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclDto {
    reportingDate: moment.Moment;
    closedDate: moment.Moment | undefined;
    isApproved: boolean;
    status: EclStatusEnum | undefined;
    closedByUserId: number | undefined;
    id: string | undefined;
}

export class CreateRetailEclAndAssumptions implements ICreateRetailEclAndAssumptions {
    retailEcl!: CreateOrEditRetailEclDto | undefined;
    frameworkAssumptions!: AssumptionDto[] | undefined;
    eadInputAssumptionDtos!: EadInputAssumptionDto[] | undefined;
    lgdInputAssumptionDtos!: LgdAssumptionDto[] | undefined;

    constructor(data?: ICreateRetailEclAndAssumptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEcl = data["retailEcl"] ? CreateOrEditRetailEclDto.fromJS(data["retailEcl"]) : <any>undefined;
            if (data["frameworkAssumptions"] && data["frameworkAssumptions"].constructor === Array) {
                this.frameworkAssumptions = [] as any;
                for (let item of data["frameworkAssumptions"])
                    this.frameworkAssumptions!.push(AssumptionDto.fromJS(item));
            }
            if (data["eadInputAssumptionDtos"] && data["eadInputAssumptionDtos"].constructor === Array) {
                this.eadInputAssumptionDtos = [] as any;
                for (let item of data["eadInputAssumptionDtos"])
                    this.eadInputAssumptionDtos!.push(EadInputAssumptionDto.fromJS(item));
            }
            if (data["lgdInputAssumptionDtos"] && data["lgdInputAssumptionDtos"].constructor === Array) {
                this.lgdInputAssumptionDtos = [] as any;
                for (let item of data["lgdInputAssumptionDtos"])
                    this.lgdInputAssumptionDtos!.push(LgdAssumptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRetailEclAndAssumptions {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRetailEclAndAssumptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEcl"] = this.retailEcl ? this.retailEcl.toJSON() : <any>undefined;
        if (this.frameworkAssumptions && this.frameworkAssumptions.constructor === Array) {
            data["frameworkAssumptions"] = [];
            for (let item of this.frameworkAssumptions)
                data["frameworkAssumptions"].push(item.toJSON());
        }
        if (this.eadInputAssumptionDtos && this.eadInputAssumptionDtos.constructor === Array) {
            data["eadInputAssumptionDtos"] = [];
            for (let item of this.eadInputAssumptionDtos)
                data["eadInputAssumptionDtos"].push(item.toJSON());
        }
        if (this.lgdInputAssumptionDtos && this.lgdInputAssumptionDtos.constructor === Array) {
            data["lgdInputAssumptionDtos"] = [];
            for (let item of this.lgdInputAssumptionDtos)
                data["lgdInputAssumptionDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateRetailEclAndAssumptions {
    retailEcl: CreateOrEditRetailEclDto | undefined;
    frameworkAssumptions: AssumptionDto[] | undefined;
    eadInputAssumptionDtos: EadInputAssumptionDto[] | undefined;
    lgdInputAssumptionDtos: LgdAssumptionDto[] | undefined;
}

export class PagedResultDtoOfGetRetailEclSicrApprovalForViewDto implements IPagedResultDtoOfGetRetailEclSicrApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclSicrApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclSicrApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclSicrApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclSicrApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclSicrApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclSicrApprovalForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclSicrApprovalForViewDto[] | undefined;
}

export class GetRetailEclSicrApprovalForViewDto implements IGetRetailEclSicrApprovalForViewDto {
    retailEclSicrApproval!: RetailEclSicrApprovalDto | undefined;
    retailEclSicrTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRetailEclSicrApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclSicrApproval = data["retailEclSicrApproval"] ? RetailEclSicrApprovalDto.fromJS(data["retailEclSicrApproval"]) : <any>undefined;
            this.retailEclSicrTenantId = data["retailEclSicrTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRetailEclSicrApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclSicrApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclSicrApproval"] = this.retailEclSicrApproval ? this.retailEclSicrApproval.toJSON() : <any>undefined;
        data["retailEclSicrTenantId"] = this.retailEclSicrTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRetailEclSicrApprovalForViewDto {
    retailEclSicrApproval: RetailEclSicrApprovalDto | undefined;
    retailEclSicrTenantId: string | undefined;
    userName: string | undefined;
}

export class RetailEclSicrApprovalDto implements IRetailEclSicrApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclSicrId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclSicrApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.retailEclSicrId = data["retailEclSicrId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclSicrApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclSicrApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["retailEclSicrId"] = this.retailEclSicrId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclSicrApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclSicrId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class GetRetailEclSicrApprovalForEditOutput implements IGetRetailEclSicrApprovalForEditOutput {
    retailEclSicrApproval!: CreateOrEditRetailEclSicrApprovalDto | undefined;
    retailEclSicrTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRetailEclSicrApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclSicrApproval = data["retailEclSicrApproval"] ? CreateOrEditRetailEclSicrApprovalDto.fromJS(data["retailEclSicrApproval"]) : <any>undefined;
            this.retailEclSicrTenantId = data["retailEclSicrTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRetailEclSicrApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclSicrApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclSicrApproval"] = this.retailEclSicrApproval ? this.retailEclSicrApproval.toJSON() : <any>undefined;
        data["retailEclSicrTenantId"] = this.retailEclSicrTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRetailEclSicrApprovalForEditOutput {
    retailEclSicrApproval: CreateOrEditRetailEclSicrApprovalDto | undefined;
    retailEclSicrTenantId: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditRetailEclSicrApprovalDto implements ICreateOrEditRetailEclSicrApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclSicrId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclSicrApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.retailEclSicrId = data["retailEclSicrId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclSicrApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclSicrApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["retailEclSicrId"] = this.retailEclSicrId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclSicrApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclSicrId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto implements IPagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclSicrApprovalRetailEclSicrLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclSicrApprovalRetailEclSicrLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclSicrApprovalRetailEclSicrLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclSicrApprovalRetailEclSicrLookupTableDto[] | undefined;
}

export class RetailEclSicrApprovalRetailEclSicrLookupTableDto implements IRetailEclSicrApprovalRetailEclSicrLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclSicrApprovalRetailEclSicrLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclSicrApprovalRetailEclSicrLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclSicrApprovalRetailEclSicrLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclSicrApprovalRetailEclSicrLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto implements IPagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclSicrApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclSicrApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclSicrApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclSicrApprovalUserLookupTableDto[] | undefined;
}

export class RetailEclSicrApprovalUserLookupTableDto implements IRetailEclSicrApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclSicrApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclSicrApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclSicrApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclSicrApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclSicrForViewDto implements IPagedResultDtoOfGetRetailEclSicrForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclSicrForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclSicrForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclSicrForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclSicrForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclSicrForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclSicrForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclSicrForViewDto[] | undefined;
}

export class GetRetailEclSicrForViewDto implements IGetRetailEclSicrForViewDto {
    retailEclSicr!: RetailEclSicrDto | undefined;
    retailEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetRetailEclSicrForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclSicr = data["retailEclSicr"] ? RetailEclSicrDto.fromJS(data["retailEclSicr"]) : <any>undefined;
            this.retailEclDataLoanBookCustomerName = data["retailEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetRetailEclSicrForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclSicrForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclSicr"] = this.retailEclSicr ? this.retailEclSicr.toJSON() : <any>undefined;
        data["retailEclDataLoanBookCustomerName"] = this.retailEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetRetailEclSicrForViewDto {
    retailEclSicr: RetailEclSicrDto | undefined;
    retailEclDataLoanBookCustomerName: string | undefined;
}

export class RetailEclSicrDto implements IRetailEclSicrDto {
    computedSICR!: number | undefined;
    overrideSICR!: string | undefined;
    overrideComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclSicrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.computedSICR = data["computedSICR"];
            this.overrideSICR = data["overrideSICR"];
            this.overrideComment = data["overrideComment"];
            this.status = data["status"];
            this.retailEclDataLoanBookId = data["retailEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclSicrDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclSicrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["computedSICR"] = this.computedSICR;
        data["overrideSICR"] = this.overrideSICR;
        data["overrideComment"] = this.overrideComment;
        data["status"] = this.status;
        data["retailEclDataLoanBookId"] = this.retailEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclSicrDto {
    computedSICR: number | undefined;
    overrideSICR: string | undefined;
    overrideComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclSicrForEditOutput implements IGetRetailEclSicrForEditOutput {
    retailEclSicr!: CreateOrEditRetailEclSicrDto | undefined;
    retailEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetRetailEclSicrForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclSicr = data["retailEclSicr"] ? CreateOrEditRetailEclSicrDto.fromJS(data["retailEclSicr"]) : <any>undefined;
            this.retailEclDataLoanBookCustomerName = data["retailEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetRetailEclSicrForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclSicrForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclSicr"] = this.retailEclSicr ? this.retailEclSicr.toJSON() : <any>undefined;
        data["retailEclDataLoanBookCustomerName"] = this.retailEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetRetailEclSicrForEditOutput {
    retailEclSicr: CreateOrEditRetailEclSicrDto | undefined;
    retailEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditRetailEclSicrDto implements ICreateOrEditRetailEclSicrDto {
    computedSICR!: number;
    overrideSICR!: string | undefined;
    overrideComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclSicrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.computedSICR = data["computedSICR"];
            this.overrideSICR = data["overrideSICR"];
            this.overrideComment = data["overrideComment"];
            this.status = data["status"];
            this.retailEclDataLoanBookId = data["retailEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclSicrDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclSicrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["computedSICR"] = this.computedSICR;
        data["overrideSICR"] = this.overrideSICR;
        data["overrideComment"] = this.overrideComment;
        data["status"] = this.status;
        data["retailEclDataLoanBookId"] = this.retailEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclSicrDto {
    computedSICR: number;
    overrideSICR: string | undefined;
    overrideComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto implements IPagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclSicrRetailEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclSicrRetailEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclSicrRetailEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclSicrRetailEclDataLoanBookLookupTableDto[] | undefined;
}

export class RetailEclSicrRetailEclDataLoanBookLookupTableDto implements IRetailEclSicrRetailEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclSicrRetailEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclSicrRetailEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclSicrRetailEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclSicrRetailEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclUploadApprovalForViewDto implements IPagedResultDtoOfGetRetailEclUploadApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclUploadApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclUploadApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclUploadApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclUploadApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclUploadApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclUploadApprovalForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclUploadApprovalForViewDto[] | undefined;
}

export class GetRetailEclUploadApprovalForViewDto implements IGetRetailEclUploadApprovalForViewDto {
    retailEclUploadApproval!: RetailEclUploadApprovalDto | undefined;
    retailEclUploadTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRetailEclUploadApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclUploadApproval = data["retailEclUploadApproval"] ? RetailEclUploadApprovalDto.fromJS(data["retailEclUploadApproval"]) : <any>undefined;
            this.retailEclUploadTenantId = data["retailEclUploadTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRetailEclUploadApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclUploadApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclUploadApproval"] = this.retailEclUploadApproval ? this.retailEclUploadApproval.toJSON() : <any>undefined;
        data["retailEclUploadTenantId"] = this.retailEclUploadTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRetailEclUploadApprovalForViewDto {
    retailEclUploadApproval: RetailEclUploadApprovalDto | undefined;
    retailEclUploadTenantId: string | undefined;
    userName: string | undefined;
}

export class RetailEclUploadApprovalDto implements IRetailEclUploadApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclUploadId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclUploadApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.retailEclUploadId = data["retailEclUploadId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclUploadApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclUploadApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["retailEclUploadId"] = this.retailEclUploadId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclUploadApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclUploadId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class GetRetailEclUploadApprovalForEditOutput implements IGetRetailEclUploadApprovalForEditOutput {
    retailEclUploadApproval!: CreateOrEditRetailEclUploadApprovalDto | undefined;
    retailEclUploadTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRetailEclUploadApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclUploadApproval = data["retailEclUploadApproval"] ? CreateOrEditRetailEclUploadApprovalDto.fromJS(data["retailEclUploadApproval"]) : <any>undefined;
            this.retailEclUploadTenantId = data["retailEclUploadTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRetailEclUploadApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclUploadApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclUploadApproval"] = this.retailEclUploadApproval ? this.retailEclUploadApproval.toJSON() : <any>undefined;
        data["retailEclUploadTenantId"] = this.retailEclUploadTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRetailEclUploadApprovalForEditOutput {
    retailEclUploadApproval: CreateOrEditRetailEclUploadApprovalDto | undefined;
    retailEclUploadTenantId: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditRetailEclUploadApprovalDto implements ICreateOrEditRetailEclUploadApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclUploadId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclUploadApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.retailEclUploadId = data["retailEclUploadId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclUploadApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclUploadApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["retailEclUploadId"] = this.retailEclUploadId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclUploadApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclUploadId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto implements IPagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclUploadApprovalRetailEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclUploadApprovalRetailEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclUploadApprovalRetailEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclUploadApprovalRetailEclUploadLookupTableDto[] | undefined;
}

export class RetailEclUploadApprovalRetailEclUploadLookupTableDto implements IRetailEclUploadApprovalRetailEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclUploadApprovalRetailEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclUploadApprovalRetailEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclUploadApprovalRetailEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclUploadApprovalRetailEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto implements IPagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclUploadApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclUploadApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclUploadApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclUploadApprovalUserLookupTableDto[] | undefined;
}

export class RetailEclUploadApprovalUserLookupTableDto implements IRetailEclUploadApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclUploadApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclUploadApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclUploadApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclUploadApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRetailEclUploadForViewDto implements IPagedResultDtoOfGetRetailEclUploadForViewDto {
    totalCount!: number | undefined;
    items!: GetRetailEclUploadForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRetailEclUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRetailEclUploadForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRetailEclUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRetailEclUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRetailEclUploadForViewDto {
    totalCount: number | undefined;
    items: GetRetailEclUploadForViewDto[] | undefined;
}

export class GetRetailEclUploadForViewDto implements IGetRetailEclUploadForViewDto {
    retailEclUpload!: RetailEclUploadDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclUpload = data["retailEclUpload"] ? RetailEclUploadDto.fromJS(data["retailEclUpload"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclUpload"] = this.retailEclUpload ? this.retailEclUpload.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclUploadForViewDto {
    retailEclUpload: RetailEclUploadDto | undefined;
    retailEclTenantId: string | undefined;
}

export class RetailEclUploadDto implements IRetailEclUploadDto {
    docType!: UploadDocTypeEnum | undefined;
    uploadComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IRetailEclUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docType = data["docType"];
            this.uploadComment = data["uploadComment"];
            this.status = data["status"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RetailEclUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["uploadComment"] = this.uploadComment;
        data["status"] = this.status;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRetailEclUploadDto {
    docType: UploadDocTypeEnum | undefined;
    uploadComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class GetRetailEclUploadForEditOutput implements IGetRetailEclUploadForEditOutput {
    retailEclUpload!: CreateOrEditRetailEclUploadDto | undefined;
    retailEclTenantId!: string | undefined;

    constructor(data?: IGetRetailEclUploadForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.retailEclUpload = data["retailEclUpload"] ? CreateOrEditRetailEclUploadDto.fromJS(data["retailEclUpload"]) : <any>undefined;
            this.retailEclTenantId = data["retailEclTenantId"];
        }
    }

    static fromJS(data: any): GetRetailEclUploadForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailEclUploadForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailEclUpload"] = this.retailEclUpload ? this.retailEclUpload.toJSON() : <any>undefined;
        data["retailEclTenantId"] = this.retailEclTenantId;
        return data; 
    }
}

export interface IGetRetailEclUploadForEditOutput {
    retailEclUpload: CreateOrEditRetailEclUploadDto | undefined;
    retailEclTenantId: string | undefined;
}

export class CreateOrEditRetailEclUploadDto implements ICreateOrEditRetailEclUploadDto {
    docType!: UploadDocTypeEnum | undefined;
    uploadComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    retailEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRetailEclUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docType = data["docType"];
            this.uploadComment = data["uploadComment"];
            this.status = data["status"];
            this.retailEclId = data["retailEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRetailEclUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRetailEclUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["uploadComment"] = this.uploadComment;
        data["status"] = this.status;
        data["retailEclId"] = this.retailEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRetailEclUploadDto {
    docType: UploadDocTypeEnum | undefined;
    uploadComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    retailEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto implements IPagedResultDtoOfRetailEclUploadRetailEclLookupTableDto {
    totalCount!: number | undefined;
    items!: RetailEclUploadRetailEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetailEclUploadRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RetailEclUploadRetailEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetailEclUploadRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRetailEclUploadRetailEclLookupTableDto {
    totalCount: number | undefined;
    items: RetailEclUploadRetailEclLookupTableDto[] | undefined;
}

export class RetailEclUploadRetailEclLookupTableDto implements IRetailEclUploadRetailEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IRetailEclUploadRetailEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RetailEclUploadRetailEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailEclUploadRetailEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRetailEclUploadRetailEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;
    theme!: UiCustomizationSettingsDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    subscriptionPaymentType!: SubscriptionPaymentType | undefined;
    edition!: EditionInfoDto | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean | undefined;
    features!: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features![key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto | undefined;
    isLeftMenuUsed!: boolean | undefined;
    isTopMenuUsed!: boolean | undefined;
    isTabMenuUsed!: boolean | undefined;
    allowMenuScroll!: boolean | undefined;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;
}

export enum SubscriptionPaymentType {
    Manual = 0, 
    RecurringAutomatic = 1, 
    RecurringManual = 2, 
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean | undefined;
    isFree!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto | undefined;
    header!: ThemeHeaderSettingsDto | undefined;
    subHeader!: ThemeSubHeaderSettingsDto | undefined;
    menu!: ThemeMenuSettingsDto | undefined;
    footer!: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.subHeader = data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(data["subHeader"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    subHeader: ThemeSubHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;
    headerMenuArrows!: boolean | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.minimizeDesktopHeaderType = data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean | undefined;
    subheaderStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedSubHeader = data["fixedSubHeader"];
            this.subheaderStyle = data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data; 
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean | undefined;
    subheaderStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    submenuToggle!: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    submenuToggle: string | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId!: number | undefined;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [] as any;
                for (let item of data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number | undefined;
    closed!: number | undefined;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number | undefined;
    newFeedbacks!: number | undefined;
    newOrders!: number | undefined;
    newUsers!: number | undefined;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number | undefined;
    revenue!: number | undefined;
    expenses!: number | undefined;
    growth!: number | undefined;
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [] as any;
                for (let item of data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [] as any;
                for (let item of data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number | undefined;
    profit!: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [] as any;
                for (let item of data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number | undefined;
    change!: number[] | undefined;
    averagePrice!: number | undefined;
    totalPrice!: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [] as any;
                for (let item of data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType | undefined;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;
}

export enum SubscriptionStartType {
    Free = 1, 
    Trial = 2, 
    Paid = 3, 
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean | undefined;
    isActive!: boolean | undefined;
    isEmailConfirmationRequired!: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;
    tenantEditionId!: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [] as any;
                for (let item of data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [] as any;
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType | undefined;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto | undefined;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;
    otherSettings!: TenantOtherSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export enum SettingScopes {
    Application = 1, 
    Tenant = 2, 
    User = 4, 
    All = 7, 
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    waitingForActivation!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto implements IPagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEadInputAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEadInputAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEadInputAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEadInputAssumptionForViewDto[] | undefined;
}

export class GetWholesaleEadInputAssumptionForViewDto implements IGetWholesaleEadInputAssumptionForViewDto {
    wholesaleEadInputAssumption!: WholesaleEadInputAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEadInputAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEadInputAssumption = data["wholesaleEadInputAssumption"] ? WholesaleEadInputAssumptionDto.fromJS(data["wholesaleEadInputAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEadInputAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEadInputAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEadInputAssumption"] = this.wholesaleEadInputAssumption ? this.wholesaleEadInputAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEadInputAssumptionForViewDto {
    wholesaleEadInputAssumption: WholesaleEadInputAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEadInputAssumptionDto implements IWholesaleEadInputAssumptionDto {
    inputName!: string | undefined;
    value!: string | undefined;
    eadGroup!: EadInputAssumptionGroupEnum | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.eadGroup = data["eadGroup"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["eadGroup"] = this.eadGroup;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEadInputAssumptionDto {
    inputName: string | undefined;
    value: string | undefined;
    eadGroup: EadInputAssumptionGroupEnum | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEadInputAssumptionForEditOutput implements IGetWholesaleEadInputAssumptionForEditOutput {
    wholesaleEadInputAssumption!: CreateOrEditWholesaleEadInputAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEadInputAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEadInputAssumption = data["wholesaleEadInputAssumption"] ? CreateOrEditWholesaleEadInputAssumptionDto.fromJS(data["wholesaleEadInputAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEadInputAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEadInputAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEadInputAssumption"] = this.wholesaleEadInputAssumption ? this.wholesaleEadInputAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEadInputAssumptionForEditOutput {
    wholesaleEadInputAssumption: CreateOrEditWholesaleEadInputAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEadInputAssumptionDto implements ICreateOrEditWholesaleEadInputAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    eadGroup!: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval!: boolean | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEadInputAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.eadGroup = data["eadGroup"];
            this.requiresGroupApproval = data["requiresGroupApproval"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEadInputAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEadInputAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["eadGroup"] = this.eadGroup;
        data["requiresGroupApproval"] = this.requiresGroupApproval;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEadInputAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    eadGroup: EadInputAssumptionGroupEnum | undefined;
    requiresGroupApproval: boolean | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEadInputAssumptionWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEadInputAssumptionWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEadInputAssumptionWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEadInputAssumptionWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEadInputAssumptionWholesaleEclLookupTableDto implements IWholesaleEadInputAssumptionWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEadInputAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEadInputAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEadInputAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEadInputAssumptionWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclApprovalForViewDto implements IPagedResultDtoOfGetWholesaleEclApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclApprovalForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclApprovalForViewDto[] | undefined;
}

export class GetWholesaleEclApprovalForViewDto implements IGetWholesaleEclApprovalForViewDto {
    wholesaleEclApproval!: WholesaleEclApprovalDto | undefined;
    userName!: string | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclApproval = data["wholesaleEclApproval"] ? WholesaleEclApprovalDto.fromJS(data["wholesaleEclApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclApproval"] = this.wholesaleEclApproval ? this.wholesaleEclApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclApprovalForViewDto {
    wholesaleEclApproval: WholesaleEclApprovalDto | undefined;
    userName: string | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclApprovalDto implements IWholesaleEclApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclApprovalDto {
    reviewedDate: moment.Moment | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclApprovalForEditOutput implements IGetWholesaleEclApprovalForEditOutput {
    wholesaleEclApproval!: CreateOrEditWholesaleEclApprovalDto | undefined;
    userName!: string | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclApproval = data["wholesaleEclApproval"] ? CreateOrEditWholesaleEclApprovalDto.fromJS(data["wholesaleEclApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclApproval"] = this.wholesaleEclApproval ? this.wholesaleEclApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclApprovalForEditOutput {
    wholesaleEclApproval: CreateOrEditWholesaleEclApprovalDto | undefined;
    userName: string | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclApprovalDto implements ICreateOrEditWholesaleEclApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto implements IPagedResultDtoOfWholesaleEclApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclApprovalUserLookupTableDto[] | undefined;
}

export class WholesaleEclApprovalUserLookupTableDto implements IWholesaleEclApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclApprovalWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclApprovalWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclApprovalWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclApprovalWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclApprovalWholesaleEclLookupTableDto implements IWholesaleEclApprovalWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclApprovalWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclApprovalWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclApprovalWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclApprovalWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto implements IPagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclAssumptionApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclAssumptionApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclAssumptionApprovalForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclAssumptionApprovalForViewDto[] | undefined;
}

export class GetWholesaleEclAssumptionApprovalForViewDto implements IGetWholesaleEclAssumptionApprovalForViewDto {
    wholesaleEclAssumptionApproval!: WholesaleEclAssumptionApprovalDto | undefined;
    wholesaleEclTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetWholesaleEclAssumptionApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclAssumptionApproval = data["wholesaleEclAssumptionApproval"] ? WholesaleEclAssumptionApprovalDto.fromJS(data["wholesaleEclAssumptionApproval"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclAssumptionApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclAssumptionApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclAssumptionApproval"] = this.wholesaleEclAssumptionApproval ? this.wholesaleEclAssumptionApproval.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetWholesaleEclAssumptionApprovalForViewDto {
    wholesaleEclAssumptionApproval: WholesaleEclAssumptionApprovalDto | undefined;
    wholesaleEclTenantId: string | undefined;
    userName: string | undefined;
}

export class WholesaleEclAssumptionApprovalDto implements IWholesaleEclAssumptionApprovalDto {
    assumptionType!: AssumptionTypeEnum | undefined;
    oldValue!: string | undefined;
    dateReviewed!: moment.Moment | undefined;
    wholesaleEclId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclAssumptionApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumptionType = data["assumptionType"];
            this.oldValue = data["oldValue"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.wholesaleEclId = data["wholesaleEclId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclAssumptionApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclAssumptionApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumptionType"] = this.assumptionType;
        data["oldValue"] = this.oldValue;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclAssumptionApprovalDto {
    assumptionType: AssumptionTypeEnum | undefined;
    oldValue: string | undefined;
    dateReviewed: moment.Moment | undefined;
    wholesaleEclId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class GetWholesaleEclAssumptionApprovalForEditOutput implements IGetWholesaleEclAssumptionApprovalForEditOutput {
    wholesaleEclAssumptionApproval!: CreateOrEditWholesaleEclAssumptionApprovalDto | undefined;
    wholesaleEclTenantId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetWholesaleEclAssumptionApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclAssumptionApproval = data["wholesaleEclAssumptionApproval"] ? CreateOrEditWholesaleEclAssumptionApprovalDto.fromJS(data["wholesaleEclAssumptionApproval"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclAssumptionApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclAssumptionApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclAssumptionApproval"] = this.wholesaleEclAssumptionApproval ? this.wholesaleEclAssumptionApproval.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetWholesaleEclAssumptionApprovalForEditOutput {
    wholesaleEclAssumptionApproval: CreateOrEditWholesaleEclAssumptionApprovalDto | undefined;
    wholesaleEclTenantId: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditWholesaleEclAssumptionApprovalDto implements ICreateOrEditWholesaleEclAssumptionApprovalDto {
    assumptionType!: AssumptionTypeEnum | undefined;
    assumptionId!: string | undefined;
    oldValue!: string | undefined;
    newValue!: string | undefined;
    dateReviewed!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclAssumptionApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assumptionType = data["assumptionType"];
            this.assumptionId = data["assumptionId"];
            this.oldValue = data["oldValue"];
            this.newValue = data["newValue"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclAssumptionApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclAssumptionApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assumptionType"] = this.assumptionType;
        data["assumptionId"] = this.assumptionId;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclAssumptionApprovalDto {
    assumptionType: AssumptionTypeEnum | undefined;
    assumptionId: string | undefined;
    oldValue: string | undefined;
    newValue: string | undefined;
    dateReviewed: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclAssumptionApprovalWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclAssumptionApprovalWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclAssumptionApprovalWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclAssumptionApprovalWholesaleEclLookupTableDto implements IWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclAssumptionApprovalWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclAssumptionApprovalWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclAssumptionApprovalWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto implements IPagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclAssumptionApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclAssumptionApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclAssumptionApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclAssumptionApprovalUserLookupTableDto[] | undefined;
}

export class WholesaleEclAssumptionApprovalUserLookupTableDto implements IWholesaleEclAssumptionApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclAssumptionApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclAssumptionApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclAssumptionApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclAssumptionApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclAssumptionForViewDto implements IPagedResultDtoOfGetWholesaleEclAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclAssumptionForViewDto[] | undefined;
}

export class GetWholesaleEclAssumptionForViewDto implements IGetWholesaleEclAssumptionForViewDto {
    wholesaleEclAssumption!: WholesaleEclAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclAssumption = data["wholesaleEclAssumption"] ? WholesaleEclAssumptionDto.fromJS(data["wholesaleEclAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclAssumption"] = this.wholesaleEclAssumption ? this.wholesaleEclAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclAssumptionForViewDto {
    wholesaleEclAssumption: WholesaleEclAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclAssumptionDto implements IWholesaleEclAssumptionDto {
    inputName!: string | undefined;
    value!: string | undefined;
    isComputed!: boolean | undefined;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.isComputed = data["isComputed"];
            this.assumptionGroup = data["assumptionGroup"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["isComputed"] = this.isComputed;
        data["assumptionGroup"] = this.assumptionGroup;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclAssumptionDto {
    inputName: string | undefined;
    value: string | undefined;
    isComputed: boolean | undefined;
    assumptionGroup: AssumptionGroupEnum | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclAssumptionForEditOutput implements IGetWholesaleEclAssumptionForEditOutput {
    wholesaleEclAssumption!: CreateOrEditWholesaleEclAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclAssumption = data["wholesaleEclAssumption"] ? CreateOrEditWholesaleEclAssumptionDto.fromJS(data["wholesaleEclAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclAssumption"] = this.wholesaleEclAssumption ? this.wholesaleEclAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclAssumptionForEditOutput {
    wholesaleEclAssumption: CreateOrEditWholesaleEclAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclAssumptionDto implements ICreateOrEditWholesaleEclAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    datatype!: DataTypeEnum | undefined;
    isComputed!: boolean;
    assumptionGroup!: AssumptionGroupEnum | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.datatype = data["datatype"];
            this.isComputed = data["isComputed"];
            this.assumptionGroup = data["assumptionGroup"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["datatype"] = this.datatype;
        data["isComputed"] = this.isComputed;
        data["assumptionGroup"] = this.assumptionGroup;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    datatype: DataTypeEnum | undefined;
    isComputed: boolean;
    assumptionGroup: AssumptionGroupEnum | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclAssumptionWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclAssumptionWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclAssumptionWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclAssumptionWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclAssumptionWholesaleEclLookupTableDto implements IWholesaleEclAssumptionWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclAssumptionWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto implements IPagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclDataLoanBookForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclDataLoanBookForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclDataLoanBookForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclDataLoanBookForViewDto[] | undefined;
}

export class GetWholesaleEclDataLoanBookForViewDto implements IGetWholesaleEclDataLoanBookForViewDto {
    wholesaleEclDataLoanBook!: WholesaleEclDataLoanBookDto | undefined;
    wholesaleEclUploadUploadComment!: string | undefined;

    constructor(data?: IGetWholesaleEclDataLoanBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclDataLoanBook = data["wholesaleEclDataLoanBook"] ? WholesaleEclDataLoanBookDto.fromJS(data["wholesaleEclDataLoanBook"]) : <any>undefined;
            this.wholesaleEclUploadUploadComment = data["wholesaleEclUploadUploadComment"];
        }
    }

    static fromJS(data: any): GetWholesaleEclDataLoanBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclDataLoanBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclDataLoanBook"] = this.wholesaleEclDataLoanBook ? this.wholesaleEclDataLoanBook.toJSON() : <any>undefined;
        data["wholesaleEclUploadUploadComment"] = this.wholesaleEclUploadUploadComment;
        return data; 
    }
}

export interface IGetWholesaleEclDataLoanBookForViewDto {
    wholesaleEclDataLoanBook: WholesaleEclDataLoanBookDto | undefined;
    wholesaleEclUploadUploadComment: string | undefined;
}

export class WholesaleEclDataLoanBookDto implements IWholesaleEclDataLoanBookDto {
    customerNo!: string | undefined;
    accountNo!: string | undefined;
    contractNo!: string | undefined;
    customerName!: string | undefined;
    currency!: string | undefined;
    productType!: string | undefined;
    productMapping!: string | undefined;
    specialisedLending!: string | undefined;
    ratingModel!: string | undefined;
    originalRating!: number | undefined;
    currentRating!: number | undefined;
    lifetimePD!: number | undefined;
    month12PD!: number | undefined;
    daysPastDue!: number | undefined;
    watchlistIndicator!: boolean | undefined;
    classification!: string | undefined;
    impairedDate!: moment.Moment | undefined;
    defaultDate!: moment.Moment | undefined;
    creditLimit!: number | undefined;
    originalBalanceLCY!: number | undefined;
    outstandingBalanceLCY!: number | undefined;
    outstandingBalanceACY!: number | undefined;
    contractStartDate!: moment.Moment | undefined;
    contractEndDate!: moment.Moment | undefined;
    restructureIndicator!: boolean | undefined;
    restructureRisk!: string | undefined;
    restructureType!: string | undefined;
    restructureStartDate!: moment.Moment | undefined;
    restructureEndDate!: moment.Moment | undefined;
    principalPaymentTermsOrigination!: string | undefined;
    pptoPeriod!: number | undefined;
    interestPaymentTermsOrigination!: string | undefined;
    iptoPeriod!: number | undefined;
    principalPaymentStructure!: string | undefined;
    interestPaymentStructure!: string | undefined;
    interestRateType!: string | undefined;
    baseRate!: string | undefined;
    originationContractualInterestRate!: string | undefined;
    introductoryPeriod!: number | undefined;
    postIPContractualInterestRate!: number | undefined;
    currentContractualInterestRate!: number | undefined;
    eir!: number | undefined;
    debentureOMV!: number | undefined;
    debentureFSV!: number | undefined;
    cashOMV!: number | undefined;
    cashFSV!: number | undefined;
    inventoryOMV!: number | undefined;
    inventoryFSV!: number | undefined;
    plantEquipmentOMV!: number | undefined;
    plantEquipmentFSV!: number | undefined;
    residentialPropertyOMV!: number | undefined;
    residentialPropertyFSV!: number | undefined;
    commercialPropertyOMV!: number | undefined;
    commercialProperty!: number | undefined;
    receivablesOMV!: number | undefined;
    receivablesFSV!: number | undefined;
    sharesOMV!: number | undefined;
    sharesFSV!: number | undefined;
    vehicleOMV!: number | undefined;
    vehicleFSV!: number | undefined;
    cureRate!: number | undefined;
    guaranteeIndicator!: boolean | undefined;
    guarantorPD!: string | undefined;
    guarantorLGD!: string | undefined;
    guaranteeValue!: number | undefined;
    guaranteeLevel!: number | undefined;
    contractId!: string | undefined;
    wholesaleEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclDataLoanBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNo = data["customerNo"];
            this.accountNo = data["accountNo"];
            this.contractNo = data["contractNo"];
            this.customerName = data["customerName"];
            this.currency = data["currency"];
            this.productType = data["productType"];
            this.productMapping = data["productMapping"];
            this.specialisedLending = data["specialisedLending"];
            this.ratingModel = data["ratingModel"];
            this.originalRating = data["originalRating"];
            this.currentRating = data["currentRating"];
            this.lifetimePD = data["lifetimePD"];
            this.month12PD = data["month12PD"];
            this.daysPastDue = data["daysPastDue"];
            this.watchlistIndicator = data["watchlistIndicator"];
            this.classification = data["classification"];
            this.impairedDate = data["impairedDate"] ? moment(data["impairedDate"].toString()) : <any>undefined;
            this.defaultDate = data["defaultDate"] ? moment(data["defaultDate"].toString()) : <any>undefined;
            this.creditLimit = data["creditLimit"];
            this.originalBalanceLCY = data["originalBalanceLCY"];
            this.outstandingBalanceLCY = data["outstandingBalanceLCY"];
            this.outstandingBalanceACY = data["outstandingBalanceACY"];
            this.contractStartDate = data["contractStartDate"] ? moment(data["contractStartDate"].toString()) : <any>undefined;
            this.contractEndDate = data["contractEndDate"] ? moment(data["contractEndDate"].toString()) : <any>undefined;
            this.restructureIndicator = data["restructureIndicator"];
            this.restructureRisk = data["restructureRisk"];
            this.restructureType = data["restructureType"];
            this.restructureStartDate = data["restructureStartDate"] ? moment(data["restructureStartDate"].toString()) : <any>undefined;
            this.restructureEndDate = data["restructureEndDate"] ? moment(data["restructureEndDate"].toString()) : <any>undefined;
            this.principalPaymentTermsOrigination = data["principalPaymentTermsOrigination"];
            this.pptoPeriod = data["pptoPeriod"];
            this.interestPaymentTermsOrigination = data["interestPaymentTermsOrigination"];
            this.iptoPeriod = data["iptoPeriod"];
            this.principalPaymentStructure = data["principalPaymentStructure"];
            this.interestPaymentStructure = data["interestPaymentStructure"];
            this.interestRateType = data["interestRateType"];
            this.baseRate = data["baseRate"];
            this.originationContractualInterestRate = data["originationContractualInterestRate"];
            this.introductoryPeriod = data["introductoryPeriod"];
            this.postIPContractualInterestRate = data["postIPContractualInterestRate"];
            this.currentContractualInterestRate = data["currentContractualInterestRate"];
            this.eir = data["eir"];
            this.debentureOMV = data["debentureOMV"];
            this.debentureFSV = data["debentureFSV"];
            this.cashOMV = data["cashOMV"];
            this.cashFSV = data["cashFSV"];
            this.inventoryOMV = data["inventoryOMV"];
            this.inventoryFSV = data["inventoryFSV"];
            this.plantEquipmentOMV = data["plantEquipmentOMV"];
            this.plantEquipmentFSV = data["plantEquipmentFSV"];
            this.residentialPropertyOMV = data["residentialPropertyOMV"];
            this.residentialPropertyFSV = data["residentialPropertyFSV"];
            this.commercialPropertyOMV = data["commercialPropertyOMV"];
            this.commercialProperty = data["commercialProperty"];
            this.receivablesOMV = data["receivablesOMV"];
            this.receivablesFSV = data["receivablesFSV"];
            this.sharesOMV = data["sharesOMV"];
            this.sharesFSV = data["sharesFSV"];
            this.vehicleOMV = data["vehicleOMV"];
            this.vehicleFSV = data["vehicleFSV"];
            this.cureRate = data["cureRate"];
            this.guaranteeIndicator = data["guaranteeIndicator"];
            this.guarantorPD = data["guarantorPD"];
            this.guarantorLGD = data["guarantorLGD"];
            this.guaranteeValue = data["guaranteeValue"];
            this.guaranteeLevel = data["guaranteeLevel"];
            this.contractId = data["contractId"];
            this.wholesaleEclUploadId = data["wholesaleEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclDataLoanBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclDataLoanBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["contractNo"] = this.contractNo;
        data["customerName"] = this.customerName;
        data["currency"] = this.currency;
        data["productType"] = this.productType;
        data["productMapping"] = this.productMapping;
        data["specialisedLending"] = this.specialisedLending;
        data["ratingModel"] = this.ratingModel;
        data["originalRating"] = this.originalRating;
        data["currentRating"] = this.currentRating;
        data["lifetimePD"] = this.lifetimePD;
        data["month12PD"] = this.month12PD;
        data["daysPastDue"] = this.daysPastDue;
        data["watchlistIndicator"] = this.watchlistIndicator;
        data["classification"] = this.classification;
        data["impairedDate"] = this.impairedDate ? this.impairedDate.toISOString() : <any>undefined;
        data["defaultDate"] = this.defaultDate ? this.defaultDate.toISOString() : <any>undefined;
        data["creditLimit"] = this.creditLimit;
        data["originalBalanceLCY"] = this.originalBalanceLCY;
        data["outstandingBalanceLCY"] = this.outstandingBalanceLCY;
        data["outstandingBalanceACY"] = this.outstandingBalanceACY;
        data["contractStartDate"] = this.contractStartDate ? this.contractStartDate.toISOString() : <any>undefined;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["restructureIndicator"] = this.restructureIndicator;
        data["restructureRisk"] = this.restructureRisk;
        data["restructureType"] = this.restructureType;
        data["restructureStartDate"] = this.restructureStartDate ? this.restructureStartDate.toISOString() : <any>undefined;
        data["restructureEndDate"] = this.restructureEndDate ? this.restructureEndDate.toISOString() : <any>undefined;
        data["principalPaymentTermsOrigination"] = this.principalPaymentTermsOrigination;
        data["pptoPeriod"] = this.pptoPeriod;
        data["interestPaymentTermsOrigination"] = this.interestPaymentTermsOrigination;
        data["iptoPeriod"] = this.iptoPeriod;
        data["principalPaymentStructure"] = this.principalPaymentStructure;
        data["interestPaymentStructure"] = this.interestPaymentStructure;
        data["interestRateType"] = this.interestRateType;
        data["baseRate"] = this.baseRate;
        data["originationContractualInterestRate"] = this.originationContractualInterestRate;
        data["introductoryPeriod"] = this.introductoryPeriod;
        data["postIPContractualInterestRate"] = this.postIPContractualInterestRate;
        data["currentContractualInterestRate"] = this.currentContractualInterestRate;
        data["eir"] = this.eir;
        data["debentureOMV"] = this.debentureOMV;
        data["debentureFSV"] = this.debentureFSV;
        data["cashOMV"] = this.cashOMV;
        data["cashFSV"] = this.cashFSV;
        data["inventoryOMV"] = this.inventoryOMV;
        data["inventoryFSV"] = this.inventoryFSV;
        data["plantEquipmentOMV"] = this.plantEquipmentOMV;
        data["plantEquipmentFSV"] = this.plantEquipmentFSV;
        data["residentialPropertyOMV"] = this.residentialPropertyOMV;
        data["residentialPropertyFSV"] = this.residentialPropertyFSV;
        data["commercialPropertyOMV"] = this.commercialPropertyOMV;
        data["commercialProperty"] = this.commercialProperty;
        data["receivablesOMV"] = this.receivablesOMV;
        data["receivablesFSV"] = this.receivablesFSV;
        data["sharesOMV"] = this.sharesOMV;
        data["sharesFSV"] = this.sharesFSV;
        data["vehicleOMV"] = this.vehicleOMV;
        data["vehicleFSV"] = this.vehicleFSV;
        data["cureRate"] = this.cureRate;
        data["guaranteeIndicator"] = this.guaranteeIndicator;
        data["guarantorPD"] = this.guarantorPD;
        data["guarantorLGD"] = this.guarantorLGD;
        data["guaranteeValue"] = this.guaranteeValue;
        data["guaranteeLevel"] = this.guaranteeLevel;
        data["contractId"] = this.contractId;
        data["wholesaleEclUploadId"] = this.wholesaleEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclDataLoanBookDto {
    customerNo: string | undefined;
    accountNo: string | undefined;
    contractNo: string | undefined;
    customerName: string | undefined;
    currency: string | undefined;
    productType: string | undefined;
    productMapping: string | undefined;
    specialisedLending: string | undefined;
    ratingModel: string | undefined;
    originalRating: number | undefined;
    currentRating: number | undefined;
    lifetimePD: number | undefined;
    month12PD: number | undefined;
    daysPastDue: number | undefined;
    watchlistIndicator: boolean | undefined;
    classification: string | undefined;
    impairedDate: moment.Moment | undefined;
    defaultDate: moment.Moment | undefined;
    creditLimit: number | undefined;
    originalBalanceLCY: number | undefined;
    outstandingBalanceLCY: number | undefined;
    outstandingBalanceACY: number | undefined;
    contractStartDate: moment.Moment | undefined;
    contractEndDate: moment.Moment | undefined;
    restructureIndicator: boolean | undefined;
    restructureRisk: string | undefined;
    restructureType: string | undefined;
    restructureStartDate: moment.Moment | undefined;
    restructureEndDate: moment.Moment | undefined;
    principalPaymentTermsOrigination: string | undefined;
    pptoPeriod: number | undefined;
    interestPaymentTermsOrigination: string | undefined;
    iptoPeriod: number | undefined;
    principalPaymentStructure: string | undefined;
    interestPaymentStructure: string | undefined;
    interestRateType: string | undefined;
    baseRate: string | undefined;
    originationContractualInterestRate: string | undefined;
    introductoryPeriod: number | undefined;
    postIPContractualInterestRate: number | undefined;
    currentContractualInterestRate: number | undefined;
    eir: number | undefined;
    debentureOMV: number | undefined;
    debentureFSV: number | undefined;
    cashOMV: number | undefined;
    cashFSV: number | undefined;
    inventoryOMV: number | undefined;
    inventoryFSV: number | undefined;
    plantEquipmentOMV: number | undefined;
    plantEquipmentFSV: number | undefined;
    residentialPropertyOMV: number | undefined;
    residentialPropertyFSV: number | undefined;
    commercialPropertyOMV: number | undefined;
    commercialProperty: number | undefined;
    receivablesOMV: number | undefined;
    receivablesFSV: number | undefined;
    sharesOMV: number | undefined;
    sharesFSV: number | undefined;
    vehicleOMV: number | undefined;
    vehicleFSV: number | undefined;
    cureRate: number | undefined;
    guaranteeIndicator: boolean | undefined;
    guarantorPD: string | undefined;
    guarantorLGD: string | undefined;
    guaranteeValue: number | undefined;
    guaranteeLevel: number | undefined;
    contractId: string | undefined;
    wholesaleEclUploadId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclDataLoanBookForEditOutput implements IGetWholesaleEclDataLoanBookForEditOutput {
    wholesaleEclDataLoanBook!: CreateOrEditWholesaleEclDataLoanBookDto | undefined;
    wholesaleEclUploadUploadComment!: string | undefined;

    constructor(data?: IGetWholesaleEclDataLoanBookForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclDataLoanBook = data["wholesaleEclDataLoanBook"] ? CreateOrEditWholesaleEclDataLoanBookDto.fromJS(data["wholesaleEclDataLoanBook"]) : <any>undefined;
            this.wholesaleEclUploadUploadComment = data["wholesaleEclUploadUploadComment"];
        }
    }

    static fromJS(data: any): GetWholesaleEclDataLoanBookForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclDataLoanBookForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclDataLoanBook"] = this.wholesaleEclDataLoanBook ? this.wholesaleEclDataLoanBook.toJSON() : <any>undefined;
        data["wholesaleEclUploadUploadComment"] = this.wholesaleEclUploadUploadComment;
        return data; 
    }
}

export interface IGetWholesaleEclDataLoanBookForEditOutput {
    wholesaleEclDataLoanBook: CreateOrEditWholesaleEclDataLoanBookDto | undefined;
    wholesaleEclUploadUploadComment: string | undefined;
}

export class CreateOrEditWholesaleEclDataLoanBookDto implements ICreateOrEditWholesaleEclDataLoanBookDto {
    customerNo!: string | undefined;
    accountNo!: string | undefined;
    contractNo!: string | undefined;
    customerName!: string | undefined;
    snapshotDate!: moment.Moment | undefined;
    segment!: string | undefined;
    sector!: string | undefined;
    currency!: string | undefined;
    productType!: string | undefined;
    productMapping!: string | undefined;
    specialisedLending!: string | undefined;
    ratingModel!: string | undefined;
    originalRating!: number | undefined;
    currentRating!: number | undefined;
    lifetimePD!: number | undefined;
    month12PD!: number | undefined;
    daysPastDue!: number | undefined;
    watchlistIndicator!: boolean;
    classification!: string | undefined;
    impairedDate!: moment.Moment | undefined;
    defaultDate!: moment.Moment | undefined;
    creditLimit!: number | undefined;
    originalBalanceLCY!: number | undefined;
    outstandingBalanceLCY!: number | undefined;
    outstandingBalanceACY!: number | undefined;
    contractStartDate!: moment.Moment | undefined;
    contractEndDate!: moment.Moment | undefined;
    restructureIndicator!: boolean;
    restructureRisk!: string | undefined;
    restructureType!: string | undefined;
    restructureStartDate!: moment.Moment | undefined;
    restructureEndDate!: moment.Moment | undefined;
    principalPaymentTermsOrigination!: string | undefined;
    pptoPeriod!: number | undefined;
    interestPaymentTermsOrigination!: string | undefined;
    iptoPeriod!: number | undefined;
    principalPaymentStructure!: string | undefined;
    interestPaymentStructure!: string | undefined;
    interestRateType!: string | undefined;
    baseRate!: string | undefined;
    originationContractualInterestRate!: string | undefined;
    introductoryPeriod!: number | undefined;
    postIPContractualInterestRate!: number | undefined;
    currentContractualInterestRate!: number | undefined;
    eir!: number | undefined;
    debentureOMV!: number | undefined;
    debentureFSV!: number | undefined;
    cashOMV!: number | undefined;
    cashFSV!: number | undefined;
    inventoryOMV!: number | undefined;
    inventoryFSV!: number | undefined;
    plantEquipmentOMV!: number | undefined;
    plantEquipmentFSV!: number | undefined;
    residentialPropertyOMV!: number | undefined;
    residentialPropertyFSV!: number | undefined;
    commercialPropertyOMV!: number | undefined;
    commercialProperty!: number | undefined;
    receivablesOMV!: number | undefined;
    receivablesFSV!: number | undefined;
    sharesOMV!: number | undefined;
    sharesFSV!: number | undefined;
    vehicleOMV!: number | undefined;
    vehicleFSV!: number | undefined;
    cureRate!: number | undefined;
    guaranteeIndicator!: boolean;
    guarantorPD!: string | undefined;
    guarantorLGD!: string | undefined;
    guaranteeValue!: number | undefined;
    guaranteeLevel!: number | undefined;
    contractId!: string | undefined;
    wholesaleEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclDataLoanBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNo = data["customerNo"];
            this.accountNo = data["accountNo"];
            this.contractNo = data["contractNo"];
            this.customerName = data["customerName"];
            this.snapshotDate = data["snapshotDate"] ? moment(data["snapshotDate"].toString()) : <any>undefined;
            this.segment = data["segment"];
            this.sector = data["sector"];
            this.currency = data["currency"];
            this.productType = data["productType"];
            this.productMapping = data["productMapping"];
            this.specialisedLending = data["specialisedLending"];
            this.ratingModel = data["ratingModel"];
            this.originalRating = data["originalRating"];
            this.currentRating = data["currentRating"];
            this.lifetimePD = data["lifetimePD"];
            this.month12PD = data["month12PD"];
            this.daysPastDue = data["daysPastDue"];
            this.watchlistIndicator = data["watchlistIndicator"];
            this.classification = data["classification"];
            this.impairedDate = data["impairedDate"] ? moment(data["impairedDate"].toString()) : <any>undefined;
            this.defaultDate = data["defaultDate"] ? moment(data["defaultDate"].toString()) : <any>undefined;
            this.creditLimit = data["creditLimit"];
            this.originalBalanceLCY = data["originalBalanceLCY"];
            this.outstandingBalanceLCY = data["outstandingBalanceLCY"];
            this.outstandingBalanceACY = data["outstandingBalanceACY"];
            this.contractStartDate = data["contractStartDate"] ? moment(data["contractStartDate"].toString()) : <any>undefined;
            this.contractEndDate = data["contractEndDate"] ? moment(data["contractEndDate"].toString()) : <any>undefined;
            this.restructureIndicator = data["restructureIndicator"];
            this.restructureRisk = data["restructureRisk"];
            this.restructureType = data["restructureType"];
            this.restructureStartDate = data["restructureStartDate"] ? moment(data["restructureStartDate"].toString()) : <any>undefined;
            this.restructureEndDate = data["restructureEndDate"] ? moment(data["restructureEndDate"].toString()) : <any>undefined;
            this.principalPaymentTermsOrigination = data["principalPaymentTermsOrigination"];
            this.pptoPeriod = data["pptoPeriod"];
            this.interestPaymentTermsOrigination = data["interestPaymentTermsOrigination"];
            this.iptoPeriod = data["iptoPeriod"];
            this.principalPaymentStructure = data["principalPaymentStructure"];
            this.interestPaymentStructure = data["interestPaymentStructure"];
            this.interestRateType = data["interestRateType"];
            this.baseRate = data["baseRate"];
            this.originationContractualInterestRate = data["originationContractualInterestRate"];
            this.introductoryPeriod = data["introductoryPeriod"];
            this.postIPContractualInterestRate = data["postIPContractualInterestRate"];
            this.currentContractualInterestRate = data["currentContractualInterestRate"];
            this.eir = data["eir"];
            this.debentureOMV = data["debentureOMV"];
            this.debentureFSV = data["debentureFSV"];
            this.cashOMV = data["cashOMV"];
            this.cashFSV = data["cashFSV"];
            this.inventoryOMV = data["inventoryOMV"];
            this.inventoryFSV = data["inventoryFSV"];
            this.plantEquipmentOMV = data["plantEquipmentOMV"];
            this.plantEquipmentFSV = data["plantEquipmentFSV"];
            this.residentialPropertyOMV = data["residentialPropertyOMV"];
            this.residentialPropertyFSV = data["residentialPropertyFSV"];
            this.commercialPropertyOMV = data["commercialPropertyOMV"];
            this.commercialProperty = data["commercialProperty"];
            this.receivablesOMV = data["receivablesOMV"];
            this.receivablesFSV = data["receivablesFSV"];
            this.sharesOMV = data["sharesOMV"];
            this.sharesFSV = data["sharesFSV"];
            this.vehicleOMV = data["vehicleOMV"];
            this.vehicleFSV = data["vehicleFSV"];
            this.cureRate = data["cureRate"];
            this.guaranteeIndicator = data["guaranteeIndicator"];
            this.guarantorPD = data["guarantorPD"];
            this.guarantorLGD = data["guarantorLGD"];
            this.guaranteeValue = data["guaranteeValue"];
            this.guaranteeLevel = data["guaranteeLevel"];
            this.contractId = data["contractId"];
            this.wholesaleEclUploadId = data["wholesaleEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclDataLoanBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclDataLoanBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNo"] = this.customerNo;
        data["accountNo"] = this.accountNo;
        data["contractNo"] = this.contractNo;
        data["customerName"] = this.customerName;
        data["snapshotDate"] = this.snapshotDate ? this.snapshotDate.toISOString() : <any>undefined;
        data["segment"] = this.segment;
        data["sector"] = this.sector;
        data["currency"] = this.currency;
        data["productType"] = this.productType;
        data["productMapping"] = this.productMapping;
        data["specialisedLending"] = this.specialisedLending;
        data["ratingModel"] = this.ratingModel;
        data["originalRating"] = this.originalRating;
        data["currentRating"] = this.currentRating;
        data["lifetimePD"] = this.lifetimePD;
        data["month12PD"] = this.month12PD;
        data["daysPastDue"] = this.daysPastDue;
        data["watchlistIndicator"] = this.watchlistIndicator;
        data["classification"] = this.classification;
        data["impairedDate"] = this.impairedDate ? this.impairedDate.toISOString() : <any>undefined;
        data["defaultDate"] = this.defaultDate ? this.defaultDate.toISOString() : <any>undefined;
        data["creditLimit"] = this.creditLimit;
        data["originalBalanceLCY"] = this.originalBalanceLCY;
        data["outstandingBalanceLCY"] = this.outstandingBalanceLCY;
        data["outstandingBalanceACY"] = this.outstandingBalanceACY;
        data["contractStartDate"] = this.contractStartDate ? this.contractStartDate.toISOString() : <any>undefined;
        data["contractEndDate"] = this.contractEndDate ? this.contractEndDate.toISOString() : <any>undefined;
        data["restructureIndicator"] = this.restructureIndicator;
        data["restructureRisk"] = this.restructureRisk;
        data["restructureType"] = this.restructureType;
        data["restructureStartDate"] = this.restructureStartDate ? this.restructureStartDate.toISOString() : <any>undefined;
        data["restructureEndDate"] = this.restructureEndDate ? this.restructureEndDate.toISOString() : <any>undefined;
        data["principalPaymentTermsOrigination"] = this.principalPaymentTermsOrigination;
        data["pptoPeriod"] = this.pptoPeriod;
        data["interestPaymentTermsOrigination"] = this.interestPaymentTermsOrigination;
        data["iptoPeriod"] = this.iptoPeriod;
        data["principalPaymentStructure"] = this.principalPaymentStructure;
        data["interestPaymentStructure"] = this.interestPaymentStructure;
        data["interestRateType"] = this.interestRateType;
        data["baseRate"] = this.baseRate;
        data["originationContractualInterestRate"] = this.originationContractualInterestRate;
        data["introductoryPeriod"] = this.introductoryPeriod;
        data["postIPContractualInterestRate"] = this.postIPContractualInterestRate;
        data["currentContractualInterestRate"] = this.currentContractualInterestRate;
        data["eir"] = this.eir;
        data["debentureOMV"] = this.debentureOMV;
        data["debentureFSV"] = this.debentureFSV;
        data["cashOMV"] = this.cashOMV;
        data["cashFSV"] = this.cashFSV;
        data["inventoryOMV"] = this.inventoryOMV;
        data["inventoryFSV"] = this.inventoryFSV;
        data["plantEquipmentOMV"] = this.plantEquipmentOMV;
        data["plantEquipmentFSV"] = this.plantEquipmentFSV;
        data["residentialPropertyOMV"] = this.residentialPropertyOMV;
        data["residentialPropertyFSV"] = this.residentialPropertyFSV;
        data["commercialPropertyOMV"] = this.commercialPropertyOMV;
        data["commercialProperty"] = this.commercialProperty;
        data["receivablesOMV"] = this.receivablesOMV;
        data["receivablesFSV"] = this.receivablesFSV;
        data["sharesOMV"] = this.sharesOMV;
        data["sharesFSV"] = this.sharesFSV;
        data["vehicleOMV"] = this.vehicleOMV;
        data["vehicleFSV"] = this.vehicleFSV;
        data["cureRate"] = this.cureRate;
        data["guaranteeIndicator"] = this.guaranteeIndicator;
        data["guarantorPD"] = this.guarantorPD;
        data["guarantorLGD"] = this.guarantorLGD;
        data["guaranteeValue"] = this.guaranteeValue;
        data["guaranteeLevel"] = this.guaranteeLevel;
        data["contractId"] = this.contractId;
        data["wholesaleEclUploadId"] = this.wholesaleEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclDataLoanBookDto {
    customerNo: string | undefined;
    accountNo: string | undefined;
    contractNo: string | undefined;
    customerName: string | undefined;
    snapshotDate: moment.Moment | undefined;
    segment: string | undefined;
    sector: string | undefined;
    currency: string | undefined;
    productType: string | undefined;
    productMapping: string | undefined;
    specialisedLending: string | undefined;
    ratingModel: string | undefined;
    originalRating: number | undefined;
    currentRating: number | undefined;
    lifetimePD: number | undefined;
    month12PD: number | undefined;
    daysPastDue: number | undefined;
    watchlistIndicator: boolean;
    classification: string | undefined;
    impairedDate: moment.Moment | undefined;
    defaultDate: moment.Moment | undefined;
    creditLimit: number | undefined;
    originalBalanceLCY: number | undefined;
    outstandingBalanceLCY: number | undefined;
    outstandingBalanceACY: number | undefined;
    contractStartDate: moment.Moment | undefined;
    contractEndDate: moment.Moment | undefined;
    restructureIndicator: boolean;
    restructureRisk: string | undefined;
    restructureType: string | undefined;
    restructureStartDate: moment.Moment | undefined;
    restructureEndDate: moment.Moment | undefined;
    principalPaymentTermsOrigination: string | undefined;
    pptoPeriod: number | undefined;
    interestPaymentTermsOrigination: string | undefined;
    iptoPeriod: number | undefined;
    principalPaymentStructure: string | undefined;
    interestPaymentStructure: string | undefined;
    interestRateType: string | undefined;
    baseRate: string | undefined;
    originationContractualInterestRate: string | undefined;
    introductoryPeriod: number | undefined;
    postIPContractualInterestRate: number | undefined;
    currentContractualInterestRate: number | undefined;
    eir: number | undefined;
    debentureOMV: number | undefined;
    debentureFSV: number | undefined;
    cashOMV: number | undefined;
    cashFSV: number | undefined;
    inventoryOMV: number | undefined;
    inventoryFSV: number | undefined;
    plantEquipmentOMV: number | undefined;
    plantEquipmentFSV: number | undefined;
    residentialPropertyOMV: number | undefined;
    residentialPropertyFSV: number | undefined;
    commercialPropertyOMV: number | undefined;
    commercialProperty: number | undefined;
    receivablesOMV: number | undefined;
    receivablesFSV: number | undefined;
    sharesOMV: number | undefined;
    sharesFSV: number | undefined;
    vehicleOMV: number | undefined;
    vehicleFSV: number | undefined;
    cureRate: number | undefined;
    guaranteeIndicator: boolean;
    guarantorPD: string | undefined;
    guarantorLGD: string | undefined;
    guaranteeValue: number | undefined;
    guaranteeLevel: number | undefined;
    contractId: string | undefined;
    wholesaleEclUploadId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto implements IPagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto[] | undefined;
}

export class WholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto implements IWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclDataLoanBookWholesaleEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto implements IPagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclDataPaymentScheduleForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclDataPaymentScheduleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclDataPaymentScheduleForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclDataPaymentScheduleForViewDto[] | undefined;
}

export class GetWholesaleEclDataPaymentScheduleForViewDto implements IGetWholesaleEclDataPaymentScheduleForViewDto {
    wholesaleEclDataPaymentSchedule!: WholesaleEclDataPaymentScheduleDto | undefined;
    wholesaleEclUploadUploadComment!: string | undefined;

    constructor(data?: IGetWholesaleEclDataPaymentScheduleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclDataPaymentSchedule = data["wholesaleEclDataPaymentSchedule"] ? WholesaleEclDataPaymentScheduleDto.fromJS(data["wholesaleEclDataPaymentSchedule"]) : <any>undefined;
            this.wholesaleEclUploadUploadComment = data["wholesaleEclUploadUploadComment"];
        }
    }

    static fromJS(data: any): GetWholesaleEclDataPaymentScheduleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclDataPaymentScheduleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclDataPaymentSchedule"] = this.wholesaleEclDataPaymentSchedule ? this.wholesaleEclDataPaymentSchedule.toJSON() : <any>undefined;
        data["wholesaleEclUploadUploadComment"] = this.wholesaleEclUploadUploadComment;
        return data; 
    }
}

export interface IGetWholesaleEclDataPaymentScheduleForViewDto {
    wholesaleEclDataPaymentSchedule: WholesaleEclDataPaymentScheduleDto | undefined;
    wholesaleEclUploadUploadComment: string | undefined;
}

export class WholesaleEclDataPaymentScheduleDto implements IWholesaleEclDataPaymentScheduleDto {
    contractRefNo!: string | undefined;
    startDate!: moment.Moment | undefined;
    component!: string | undefined;
    noOfSchedules!: number | undefined;
    frequency!: string | undefined;
    amount!: number | undefined;
    wholesaleEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclDataPaymentScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractRefNo = data["contractRefNo"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.component = data["component"];
            this.noOfSchedules = data["noOfSchedules"];
            this.frequency = data["frequency"];
            this.amount = data["amount"];
            this.wholesaleEclUploadId = data["wholesaleEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclDataPaymentScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclDataPaymentScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractRefNo"] = this.contractRefNo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["component"] = this.component;
        data["noOfSchedules"] = this.noOfSchedules;
        data["frequency"] = this.frequency;
        data["amount"] = this.amount;
        data["wholesaleEclUploadId"] = this.wholesaleEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclDataPaymentScheduleDto {
    contractRefNo: string | undefined;
    startDate: moment.Moment | undefined;
    component: string | undefined;
    noOfSchedules: number | undefined;
    frequency: string | undefined;
    amount: number | undefined;
    wholesaleEclUploadId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclDataPaymentScheduleForEditOutput implements IGetWholesaleEclDataPaymentScheduleForEditOutput {
    wholesaleEclDataPaymentSchedule!: CreateOrEditWholesaleEclDataPaymentScheduleDto | undefined;
    wholesaleEclUploadUploadComment!: string | undefined;

    constructor(data?: IGetWholesaleEclDataPaymentScheduleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclDataPaymentSchedule = data["wholesaleEclDataPaymentSchedule"] ? CreateOrEditWholesaleEclDataPaymentScheduleDto.fromJS(data["wholesaleEclDataPaymentSchedule"]) : <any>undefined;
            this.wholesaleEclUploadUploadComment = data["wholesaleEclUploadUploadComment"];
        }
    }

    static fromJS(data: any): GetWholesaleEclDataPaymentScheduleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclDataPaymentScheduleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclDataPaymentSchedule"] = this.wholesaleEclDataPaymentSchedule ? this.wholesaleEclDataPaymentSchedule.toJSON() : <any>undefined;
        data["wholesaleEclUploadUploadComment"] = this.wholesaleEclUploadUploadComment;
        return data; 
    }
}

export interface IGetWholesaleEclDataPaymentScheduleForEditOutput {
    wholesaleEclDataPaymentSchedule: CreateOrEditWholesaleEclDataPaymentScheduleDto | undefined;
    wholesaleEclUploadUploadComment: string | undefined;
}

export class CreateOrEditWholesaleEclDataPaymentScheduleDto implements ICreateOrEditWholesaleEclDataPaymentScheduleDto {
    contractRefNo!: string | undefined;
    startDate!: moment.Moment | undefined;
    component!: string | undefined;
    noOfSchedules!: number | undefined;
    frequency!: string | undefined;
    amount!: number | undefined;
    wholesaleEclUploadId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclDataPaymentScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractRefNo = data["contractRefNo"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.component = data["component"];
            this.noOfSchedules = data["noOfSchedules"];
            this.frequency = data["frequency"];
            this.amount = data["amount"];
            this.wholesaleEclUploadId = data["wholesaleEclUploadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclDataPaymentScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclDataPaymentScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractRefNo"] = this.contractRefNo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["component"] = this.component;
        data["noOfSchedules"] = this.noOfSchedules;
        data["frequency"] = this.frequency;
        data["amount"] = this.amount;
        data["wholesaleEclUploadId"] = this.wholesaleEclUploadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclDataPaymentScheduleDto {
    contractRefNo: string | undefined;
    startDate: moment.Moment | undefined;
    component: string | undefined;
    noOfSchedules: number | undefined;
    frequency: string | undefined;
    amount: number | undefined;
    wholesaleEclUploadId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto implements IPagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto[] | undefined;
}

export class WholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto implements IWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclDataPaymentScheduleWholesaleEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto implements IPagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclLgdAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclLgdAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclLgdAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclLgdAssumptionForViewDto[] | undefined;
}

export class GetWholesaleEclLgdAssumptionForViewDto implements IGetWholesaleEclLgdAssumptionForViewDto {
    wholesaleEclLgdAssumption!: WholesaleEclLgdAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclLgdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclLgdAssumption = data["wholesaleEclLgdAssumption"] ? WholesaleEclLgdAssumptionDto.fromJS(data["wholesaleEclLgdAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclLgdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclLgdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclLgdAssumption"] = this.wholesaleEclLgdAssumption ? this.wholesaleEclLgdAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclLgdAssumptionForViewDto {
    wholesaleEclLgdAssumption: WholesaleEclLgdAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclLgdAssumptionDto implements IWholesaleEclLgdAssumptionDto {
    inputName!: string | undefined;
    value!: string | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclLgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclLgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclLgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclLgdAssumptionDto {
    inputName: string | undefined;
    value: string | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclLgdAssumptionForEditOutput implements IGetWholesaleEclLgdAssumptionForEditOutput {
    wholesaleEclLgdAssumption!: CreateOrEditWholesaleEclLgdAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclLgdAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclLgdAssumption = data["wholesaleEclLgdAssumption"] ? CreateOrEditWholesaleEclLgdAssumptionDto.fromJS(data["wholesaleEclLgdAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclLgdAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclLgdAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclLgdAssumption"] = this.wholesaleEclLgdAssumption ? this.wholesaleEclLgdAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclLgdAssumptionForEditOutput {
    wholesaleEclLgdAssumption: CreateOrEditWholesaleEclLgdAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclLgdAssumptionDto implements ICreateOrEditWholesaleEclLgdAssumptionDto {
    key!: string | undefined;
    inputName!: string | undefined;
    value!: string | undefined;
    dataType!: DataTypeEnum | undefined;
    isComputed!: boolean | undefined;
    lgdGroup!: LdgInputAssumptionGroupEnum | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclLgdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.inputName = data["inputName"];
            this.value = data["value"];
            this.dataType = data["dataType"];
            this.isComputed = data["isComputed"];
            this.lgdGroup = data["lgdGroup"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclLgdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclLgdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["inputName"] = this.inputName;
        data["value"] = this.value;
        data["dataType"] = this.dataType;
        data["isComputed"] = this.isComputed;
        data["lgdGroup"] = this.lgdGroup;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclLgdAssumptionDto {
    key: string | undefined;
    inputName: string | undefined;
    value: string | undefined;
    dataType: DataTypeEnum | undefined;
    isComputed: boolean | undefined;
    lgdGroup: LdgInputAssumptionGroupEnum | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclLgdAssumptionWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclLgdAssumptionWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclLgdAssumptionWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclLgdAssumptionWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclLgdAssumptionWholesaleEclLookupTableDto implements IWholesaleEclLgdAssumptionWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclLgdAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclLgdAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclLgdAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclLgdAssumptionWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto implements IPagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclPdAssumption12MonthsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclPdAssumption12MonthsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclPdAssumption12MonthsForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclPdAssumption12MonthsForViewDto[] | undefined;
}

export class GetWholesaleEclPdAssumption12MonthsForViewDto implements IGetWholesaleEclPdAssumption12MonthsForViewDto {
    wholesaleEclPdAssumption12Months!: WholesaleEclPdAssumption12MonthsDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumption12MonthsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumption12Months = data["wholesaleEclPdAssumption12Months"] ? WholesaleEclPdAssumption12MonthsDto.fromJS(data["wholesaleEclPdAssumption12Months"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumption12MonthsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumption12MonthsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumption12Months"] = this.wholesaleEclPdAssumption12Months ? this.wholesaleEclPdAssumption12Months.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumption12MonthsForViewDto {
    wholesaleEclPdAssumption12Months: WholesaleEclPdAssumption12MonthsDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclPdAssumption12MonthsDto implements IWholesaleEclPdAssumption12MonthsDto {
    credit!: number | undefined;
    pd!: number | undefined;
    snPMappingEtiCreditPolicy!: string | undefined;
    snPMappingBestFit!: string | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumption12MonthsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.credit = data["credit"];
            this.pd = data["pd"];
            this.snPMappingEtiCreditPolicy = data["snPMappingEtiCreditPolicy"];
            this.snPMappingBestFit = data["snPMappingBestFit"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumption12MonthsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumption12MonthsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["credit"] = this.credit;
        data["pd"] = this.pd;
        data["snPMappingEtiCreditPolicy"] = this.snPMappingEtiCreditPolicy;
        data["snPMappingBestFit"] = this.snPMappingBestFit;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclPdAssumption12MonthsDto {
    credit: number | undefined;
    pd: number | undefined;
    snPMappingEtiCreditPolicy: string | undefined;
    snPMappingBestFit: string | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclPdAssumption12MonthsForEditOutput implements IGetWholesaleEclPdAssumption12MonthsForEditOutput {
    wholesaleEclPdAssumption12Months!: CreateOrEditWholesaleEclPdAssumption12MonthsDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumption12MonthsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumption12Months = data["wholesaleEclPdAssumption12Months"] ? CreateOrEditWholesaleEclPdAssumption12MonthsDto.fromJS(data["wholesaleEclPdAssumption12Months"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumption12MonthsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumption12MonthsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumption12Months"] = this.wholesaleEclPdAssumption12Months ? this.wholesaleEclPdAssumption12Months.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumption12MonthsForEditOutput {
    wholesaleEclPdAssumption12Months: CreateOrEditWholesaleEclPdAssumption12MonthsDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclPdAssumption12MonthsDto implements ICreateOrEditWholesaleEclPdAssumption12MonthsDto {
    credit!: number;
    pd!: number | undefined;
    snPMappingEtiCreditPolicy!: string | undefined;
    snPMappingBestFit!: string | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclPdAssumption12MonthsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.credit = data["credit"];
            this.pd = data["pd"];
            this.snPMappingEtiCreditPolicy = data["snPMappingEtiCreditPolicy"];
            this.snPMappingBestFit = data["snPMappingBestFit"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclPdAssumption12MonthsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclPdAssumption12MonthsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["credit"] = this.credit;
        data["pd"] = this.pd;
        data["snPMappingEtiCreditPolicy"] = this.snPMappingEtiCreditPolicy;
        data["snPMappingBestFit"] = this.snPMappingBestFit;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclPdAssumption12MonthsDto {
    credit: number;
    pd: number | undefined;
    snPMappingEtiCreditPolicy: string | undefined;
    snPMappingBestFit: string | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto implements IWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclPdAssumption12MonthsWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto implements IPagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclPdAssumptionMacroeconomicInputForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclPdAssumptionMacroeconomicInputForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclPdAssumptionMacroeconomicInputForViewDto[] | undefined;
}

export class GetWholesaleEclPdAssumptionMacroeconomicInputForViewDto implements IGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto {
    wholesaleEclPdAssumptionMacroeconomicInput!: WholesaleEclPdAssumptionMacroeconomicInputDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumptionMacroeconomicInput = data["wholesaleEclPdAssumptionMacroeconomicInput"] ? WholesaleEclPdAssumptionMacroeconomicInputDto.fromJS(data["wholesaleEclPdAssumptionMacroeconomicInput"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionMacroeconomicInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionMacroeconomicInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumptionMacroeconomicInput"] = this.wholesaleEclPdAssumptionMacroeconomicInput ? this.wholesaleEclPdAssumptionMacroeconomicInput.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionMacroeconomicInputForViewDto {
    wholesaleEclPdAssumptionMacroeconomicInput: WholesaleEclPdAssumptionMacroeconomicInputDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclPdAssumptionMacroeconomicInputDto implements IWholesaleEclPdAssumptionMacroeconomicInputDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionMacroeconomicInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionMacroeconomicInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionMacroeconomicInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionMacroeconomicInputDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput implements IGetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput {
    wholesaleEclPdAssumptionMacroeconomicInput!: CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumptionMacroeconomicInput = data["wholesaleEclPdAssumptionMacroeconomicInput"] ? CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto.fromJS(data["wholesaleEclPdAssumptionMacroeconomicInput"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumptionMacroeconomicInput"] = this.wholesaleEclPdAssumptionMacroeconomicInput ? this.wholesaleEclPdAssumptionMacroeconomicInput.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionMacroeconomicInputForEditOutput {
    wholesaleEclPdAssumptionMacroeconomicInput: CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto implements ICreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclPdAssumptionMacroeconomicInputDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto implements IWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionMacroeconomicInputWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto implements IPagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto[] | undefined;
}

export class GetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto implements IGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto {
    wholesaleEclPdAssumptionMacroeconomicProjection!: WholesaleEclPdAssumptionMacroeconomicProjectionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumptionMacroeconomicProjection = data["wholesaleEclPdAssumptionMacroeconomicProjection"] ? WholesaleEclPdAssumptionMacroeconomicProjectionDto.fromJS(data["wholesaleEclPdAssumptionMacroeconomicProjection"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumptionMacroeconomicProjection"] = this.wholesaleEclPdAssumptionMacroeconomicProjection ? this.wholesaleEclPdAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionMacroeconomicProjectionForViewDto {
    wholesaleEclPdAssumptionMacroeconomicProjection: WholesaleEclPdAssumptionMacroeconomicProjectionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclPdAssumptionMacroeconomicProjectionDto implements IWholesaleEclPdAssumptionMacroeconomicProjectionDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionMacroeconomicProjectionDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput implements IGetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput {
    wholesaleEclPdAssumptionMacroeconomicProjection!: CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumptionMacroeconomicProjection = data["wholesaleEclPdAssumptionMacroeconomicProjection"] ? CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto.fromJS(data["wholesaleEclPdAssumptionMacroeconomicProjection"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumptionMacroeconomicProjection"] = this.wholesaleEclPdAssumptionMacroeconomicProjection ? this.wholesaleEclPdAssumptionMacroeconomicProjection.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionMacroeconomicProjectionForEditOutput {
    wholesaleEclPdAssumptionMacroeconomicProjection: CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto implements ICreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclPdAssumptionMacroeconomicProjectionDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto implements IWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionMacroeconomicProjectionWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto implements IPagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclPdAssumptionNplIndexForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclPdAssumptionNplIndexForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclPdAssumptionNplIndexForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclPdAssumptionNplIndexForViewDto[] | undefined;
}

export class GetWholesaleEclPdAssumptionNplIndexForViewDto implements IGetWholesaleEclPdAssumptionNplIndexForViewDto {
    wholesaleEclPdAssumptionNplIndex!: WholesaleEclPdAssumptionNplIndexDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionNplIndexForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumptionNplIndex = data["wholesaleEclPdAssumptionNplIndex"] ? WholesaleEclPdAssumptionNplIndexDto.fromJS(data["wholesaleEclPdAssumptionNplIndex"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionNplIndexForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionNplIndexForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumptionNplIndex"] = this.wholesaleEclPdAssumptionNplIndex ? this.wholesaleEclPdAssumptionNplIndex.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionNplIndexForViewDto {
    wholesaleEclPdAssumptionNplIndex: WholesaleEclPdAssumptionNplIndexDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclPdAssumptionNplIndexDto implements IWholesaleEclPdAssumptionNplIndexDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionNplIndexDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclPdAssumptionNplIndexForEditOutput implements IGetWholesaleEclPdAssumptionNplIndexForEditOutput {
    wholesaleEclPdAssumptionNplIndex!: CreateOrEditWholesaleEclPdAssumptionNplIndexDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionNplIndexForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumptionNplIndex = data["wholesaleEclPdAssumptionNplIndex"] ? CreateOrEditWholesaleEclPdAssumptionNplIndexDto.fromJS(data["wholesaleEclPdAssumptionNplIndex"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionNplIndexForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionNplIndexForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumptionNplIndex"] = this.wholesaleEclPdAssumptionNplIndex ? this.wholesaleEclPdAssumptionNplIndex.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionNplIndexForEditOutput {
    wholesaleEclPdAssumptionNplIndex: CreateOrEditWholesaleEclPdAssumptionNplIndexDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclPdAssumptionNplIndexDto implements ICreateOrEditWholesaleEclPdAssumptionNplIndexDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclPdAssumptionNplIndexDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclPdAssumptionNplIndexDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclPdAssumptionNplIndexDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclPdAssumptionNplIndexDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto implements IWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionNplIndexWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto implements IPagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclPdAssumptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclPdAssumptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclPdAssumptionForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclPdAssumptionForViewDto[] | undefined;
}

export class GetWholesaleEclPdAssumptionForViewDto implements IGetWholesaleEclPdAssumptionForViewDto {
    wholesaleEclPdAssumption!: WholesaleEclPdAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumption = data["wholesaleEclPdAssumption"] ? WholesaleEclPdAssumptionDto.fromJS(data["wholesaleEclPdAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumption"] = this.wholesaleEclPdAssumption ? this.wholesaleEclPdAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionForViewDto {
    wholesaleEclPdAssumption: WholesaleEclPdAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclPdAssumptionDto implements IWholesaleEclPdAssumptionDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclPdAssumptionForEditOutput implements IGetWholesaleEclPdAssumptionForEditOutput {
    wholesaleEclPdAssumption!: CreateOrEditWholesaleEclPdAssumptionDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdAssumptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdAssumption = data["wholesaleEclPdAssumption"] ? CreateOrEditWholesaleEclPdAssumptionDto.fromJS(data["wholesaleEclPdAssumption"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdAssumptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdAssumptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdAssumption"] = this.wholesaleEclPdAssumption ? this.wholesaleEclPdAssumption.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdAssumptionForEditOutput {
    wholesaleEclPdAssumption: CreateOrEditWholesaleEclPdAssumptionDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclPdAssumptionDto implements ICreateOrEditWholesaleEclPdAssumptionDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclPdAssumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclPdAssumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclPdAssumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclPdAssumptionDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclPdAssumptionWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclPdAssumptionWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclPdAssumptionWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclPdAssumptionWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclPdAssumptionWholesaleEclLookupTableDto implements IWholesaleEclPdAssumptionWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclPdAssumptionWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclPdAssumptionWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdAssumptionWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclPdAssumptionWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto implements IPagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto[] | undefined;
}

export class GetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto implements IGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto {
    wholesaleEclPdSnPCummulativeDefaultRates!: WholesaleEclPdSnPCummulativeDefaultRatesDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdSnPCummulativeDefaultRates = data["wholesaleEclPdSnPCummulativeDefaultRates"] ? WholesaleEclPdSnPCummulativeDefaultRatesDto.fromJS(data["wholesaleEclPdSnPCummulativeDefaultRates"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdSnPCummulativeDefaultRates"] = this.wholesaleEclPdSnPCummulativeDefaultRates ? this.wholesaleEclPdSnPCummulativeDefaultRates.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdSnPCummulativeDefaultRatesForViewDto {
    wholesaleEclPdSnPCummulativeDefaultRates: WholesaleEclPdSnPCummulativeDefaultRatesDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclPdSnPCummulativeDefaultRatesDto implements IWholesaleEclPdSnPCummulativeDefaultRatesDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclPdSnPCummulativeDefaultRatesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclPdSnPCummulativeDefaultRatesDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdSnPCummulativeDefaultRatesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclPdSnPCummulativeDefaultRatesDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput implements IGetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput {
    wholesaleEclPdSnPCummulativeDefaultRates!: CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclPdSnPCummulativeDefaultRates = data["wholesaleEclPdSnPCummulativeDefaultRates"] ? CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto.fromJS(data["wholesaleEclPdSnPCummulativeDefaultRates"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclPdSnPCummulativeDefaultRates"] = this.wholesaleEclPdSnPCummulativeDefaultRates ? this.wholesaleEclPdSnPCummulativeDefaultRates.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclPdSnPCummulativeDefaultRatesForEditOutput {
    wholesaleEclPdSnPCummulativeDefaultRates: CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto implements ICreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto {
    key!: string | undefined;
    rating!: string | undefined;
    years!: number | undefined;
    value!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.rating = data["rating"];
            this.years = data["years"];
            this.value = data["value"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["rating"] = this.rating;
        data["years"] = this.years;
        data["value"] = this.value;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclPdSnPCummulativeDefaultRatesDto {
    key: string | undefined;
    rating: string | undefined;
    years: number | undefined;
    value: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto implements IWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclPdSnPCummulativeDefaultRatesWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclResultDetailForViewDto implements IPagedResultDtoOfGetWholesaleEclResultDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclResultDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclResultDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclResultDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclResultDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclResultDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclResultDetailForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclResultDetailForViewDto[] | undefined;
}

export class GetWholesaleEclResultDetailForViewDto implements IGetWholesaleEclResultDetailForViewDto {
    wholesaleEclResultDetail!: WholesaleEclResultDetailDto | undefined;
    wholesaleEclTenantId!: string | undefined;
    wholesaleEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetWholesaleEclResultDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultDetail = data["wholesaleEclResultDetail"] ? WholesaleEclResultDetailDto.fromJS(data["wholesaleEclResultDetail"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
            this.wholesaleEclDataLoanBookCustomerName = data["wholesaleEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultDetail"] = this.wholesaleEclResultDetail ? this.wholesaleEclResultDetail.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        data["wholesaleEclDataLoanBookCustomerName"] = this.wholesaleEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetWholesaleEclResultDetailForViewDto {
    wholesaleEclResultDetail: WholesaleEclResultDetailDto | undefined;
    wholesaleEclTenantId: string | undefined;
    wholesaleEclDataLoanBookCustomerName: string | undefined;
}

export class WholesaleEclResultDetailDto implements IWholesaleEclResultDetailDto {
    contractID!: string | undefined;
    accountNo!: string | undefined;
    customerNo!: string | undefined;
    segment!: string | undefined;
    productType!: string | undefined;
    sector!: string | undefined;
    stage!: number | undefined;
    outstandingBalance!: number | undefined;
    preOverrideEclBest!: number | undefined;
    preOverrideEclOptimistic!: number | undefined;
    preOverrideEclDownturn!: number | undefined;
    overrideStage!: number | undefined;
    overrideTTRYears!: number | undefined;
    overrideFSV!: number | undefined;
    overrideOverlay!: number | undefined;
    postOverrideEclBest!: number | undefined;
    postOverrideEclOptimistic!: number | undefined;
    postOverrideEclDownturn!: number | undefined;
    preOverrideImpairment!: number | undefined;
    postOverrideImpairment!: number | undefined;
    wholesaleEclId!: string | undefined;
    wholesaleEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractID = data["contractID"];
            this.accountNo = data["accountNo"];
            this.customerNo = data["customerNo"];
            this.segment = data["segment"];
            this.productType = data["productType"];
            this.sector = data["sector"];
            this.stage = data["stage"];
            this.outstandingBalance = data["outstandingBalance"];
            this.preOverrideEclBest = data["preOverrideEclBest"];
            this.preOverrideEclOptimistic = data["preOverrideEclOptimistic"];
            this.preOverrideEclDownturn = data["preOverrideEclDownturn"];
            this.overrideStage = data["overrideStage"];
            this.overrideTTRYears = data["overrideTTRYears"];
            this.overrideFSV = data["overrideFSV"];
            this.overrideOverlay = data["overrideOverlay"];
            this.postOverrideEclBest = data["postOverrideEclBest"];
            this.postOverrideEclOptimistic = data["postOverrideEclOptimistic"];
            this.postOverrideEclDownturn = data["postOverrideEclDownturn"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.wholesaleEclDataLoanBookId = data["wholesaleEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractID"] = this.contractID;
        data["accountNo"] = this.accountNo;
        data["customerNo"] = this.customerNo;
        data["segment"] = this.segment;
        data["productType"] = this.productType;
        data["sector"] = this.sector;
        data["stage"] = this.stage;
        data["outstandingBalance"] = this.outstandingBalance;
        data["preOverrideEclBest"] = this.preOverrideEclBest;
        data["preOverrideEclOptimistic"] = this.preOverrideEclOptimistic;
        data["preOverrideEclDownturn"] = this.preOverrideEclDownturn;
        data["overrideStage"] = this.overrideStage;
        data["overrideTTRYears"] = this.overrideTTRYears;
        data["overrideFSV"] = this.overrideFSV;
        data["overrideOverlay"] = this.overrideOverlay;
        data["postOverrideEclBest"] = this.postOverrideEclBest;
        data["postOverrideEclOptimistic"] = this.postOverrideEclOptimistic;
        data["postOverrideEclDownturn"] = this.postOverrideEclDownturn;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["wholesaleEclDataLoanBookId"] = this.wholesaleEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclResultDetailDto {
    contractID: string | undefined;
    accountNo: string | undefined;
    customerNo: string | undefined;
    segment: string | undefined;
    productType: string | undefined;
    sector: string | undefined;
    stage: number | undefined;
    outstandingBalance: number | undefined;
    preOverrideEclBest: number | undefined;
    preOverrideEclOptimistic: number | undefined;
    preOverrideEclDownturn: number | undefined;
    overrideStage: number | undefined;
    overrideTTRYears: number | undefined;
    overrideFSV: number | undefined;
    overrideOverlay: number | undefined;
    postOverrideEclBest: number | undefined;
    postOverrideEclOptimistic: number | undefined;
    postOverrideEclDownturn: number | undefined;
    preOverrideImpairment: number | undefined;
    postOverrideImpairment: number | undefined;
    wholesaleEclId: string | undefined;
    wholesaleEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclResultDetailForEditOutput implements IGetWholesaleEclResultDetailForEditOutput {
    wholesaleEclResultDetail!: CreateOrEditWholesaleEclResultDetailDto | undefined;
    wholesaleEclTenantId!: string | undefined;
    wholesaleEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetWholesaleEclResultDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultDetail = data["wholesaleEclResultDetail"] ? CreateOrEditWholesaleEclResultDetailDto.fromJS(data["wholesaleEclResultDetail"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
            this.wholesaleEclDataLoanBookCustomerName = data["wholesaleEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultDetail"] = this.wholesaleEclResultDetail ? this.wholesaleEclResultDetail.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        data["wholesaleEclDataLoanBookCustomerName"] = this.wholesaleEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetWholesaleEclResultDetailForEditOutput {
    wholesaleEclResultDetail: CreateOrEditWholesaleEclResultDetailDto | undefined;
    wholesaleEclTenantId: string | undefined;
    wholesaleEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditWholesaleEclResultDetailDto implements ICreateOrEditWholesaleEclResultDetailDto {
    contractID!: string | undefined;
    accountNo!: string | undefined;
    customerNo!: string | undefined;
    segment!: string | undefined;
    productType!: string | undefined;
    sector!: string | undefined;
    stage!: number | undefined;
    outstandingBalance!: number | undefined;
    preOverrideEclBest!: number | undefined;
    preOverrideEclOptimistic!: number | undefined;
    preOverrideEclDownturn!: number | undefined;
    overrideStage!: number | undefined;
    overrideTTRYears!: number | undefined;
    overrideFSV!: number | undefined;
    overrideOverlay!: number | undefined;
    postOverrideEclBest!: number | undefined;
    postOverrideEclOptimistic!: number | undefined;
    postOverrideEclDownturn!: number | undefined;
    preOverrideImpairment!: number | undefined;
    postOverrideImpairment!: number | undefined;
    wholesaleEclId!: string | undefined;
    wholesaleEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contractID = data["contractID"];
            this.accountNo = data["accountNo"];
            this.customerNo = data["customerNo"];
            this.segment = data["segment"];
            this.productType = data["productType"];
            this.sector = data["sector"];
            this.stage = data["stage"];
            this.outstandingBalance = data["outstandingBalance"];
            this.preOverrideEclBest = data["preOverrideEclBest"];
            this.preOverrideEclOptimistic = data["preOverrideEclOptimistic"];
            this.preOverrideEclDownturn = data["preOverrideEclDownturn"];
            this.overrideStage = data["overrideStage"];
            this.overrideTTRYears = data["overrideTTRYears"];
            this.overrideFSV = data["overrideFSV"];
            this.overrideOverlay = data["overrideOverlay"];
            this.postOverrideEclBest = data["postOverrideEclBest"];
            this.postOverrideEclOptimistic = data["postOverrideEclOptimistic"];
            this.postOverrideEclDownturn = data["postOverrideEclDownturn"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.wholesaleEclDataLoanBookId = data["wholesaleEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractID"] = this.contractID;
        data["accountNo"] = this.accountNo;
        data["customerNo"] = this.customerNo;
        data["segment"] = this.segment;
        data["productType"] = this.productType;
        data["sector"] = this.sector;
        data["stage"] = this.stage;
        data["outstandingBalance"] = this.outstandingBalance;
        data["preOverrideEclBest"] = this.preOverrideEclBest;
        data["preOverrideEclOptimistic"] = this.preOverrideEclOptimistic;
        data["preOverrideEclDownturn"] = this.preOverrideEclDownturn;
        data["overrideStage"] = this.overrideStage;
        data["overrideTTRYears"] = this.overrideTTRYears;
        data["overrideFSV"] = this.overrideFSV;
        data["overrideOverlay"] = this.overrideOverlay;
        data["postOverrideEclBest"] = this.postOverrideEclBest;
        data["postOverrideEclOptimistic"] = this.postOverrideEclOptimistic;
        data["postOverrideEclDownturn"] = this.postOverrideEclDownturn;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["wholesaleEclDataLoanBookId"] = this.wholesaleEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclResultDetailDto {
    contractID: string | undefined;
    accountNo: string | undefined;
    customerNo: string | undefined;
    segment: string | undefined;
    productType: string | undefined;
    sector: string | undefined;
    stage: number | undefined;
    outstandingBalance: number | undefined;
    preOverrideEclBest: number | undefined;
    preOverrideEclOptimistic: number | undefined;
    preOverrideEclDownturn: number | undefined;
    overrideStage: number | undefined;
    overrideTTRYears: number | undefined;
    overrideFSV: number | undefined;
    overrideOverlay: number | undefined;
    postOverrideEclBest: number | undefined;
    postOverrideEclOptimistic: number | undefined;
    postOverrideEclDownturn: number | undefined;
    preOverrideImpairment: number | undefined;
    postOverrideImpairment: number | undefined;
    wholesaleEclId: string | undefined;
    wholesaleEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclResultDetailWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclResultDetailWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclResultDetailWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclResultDetailWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclResultDetailWholesaleEclLookupTableDto implements IWholesaleEclResultDetailWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclResultDetailWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclResultDetailWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultDetailWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclResultDetailWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto implements IPagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto[] | undefined;
}

export class WholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto implements IWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclResultDetailWholesaleEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto implements IPagedResultDtoOfGetWholesaleEclResultSummaryForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclResultSummaryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclResultSummaryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclResultSummaryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclResultSummaryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclResultSummaryForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclResultSummaryForViewDto[] | undefined;
}

export class GetWholesaleEclResultSummaryForViewDto implements IGetWholesaleEclResultSummaryForViewDto {
    wholesaleEclResultSummary!: WholesaleEclResultSummaryDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclResultSummaryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultSummary = data["wholesaleEclResultSummary"] ? WholesaleEclResultSummaryDto.fromJS(data["wholesaleEclResultSummary"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultSummaryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultSummaryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultSummary"] = this.wholesaleEclResultSummary ? this.wholesaleEclResultSummary.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclResultSummaryForViewDto {
    wholesaleEclResultSummary: WholesaleEclResultSummaryDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclResultSummaryDto implements IWholesaleEclResultSummaryDto {
    summaryType!: ResultSummaryTypeEnum | undefined;
    title!: string | undefined;
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.summaryType = data["summaryType"];
            this.title = data["title"];
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summaryType"] = this.summaryType;
        data["title"] = this.title;
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryDto {
    summaryType: ResultSummaryTypeEnum | undefined;
    title: string | undefined;
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclResultSummaryForEditOutput implements IGetWholesaleEclResultSummaryForEditOutput {
    wholesaleEclResultSummary!: CreateOrEditWholesaleEclResultSummaryDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclResultSummaryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultSummary = data["wholesaleEclResultSummary"] ? CreateOrEditWholesaleEclResultSummaryDto.fromJS(data["wholesaleEclResultSummary"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultSummaryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultSummaryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultSummary"] = this.wholesaleEclResultSummary ? this.wholesaleEclResultSummary.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclResultSummaryForEditOutput {
    wholesaleEclResultSummary: CreateOrEditWholesaleEclResultSummaryDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclResultSummaryDto implements ICreateOrEditWholesaleEclResultSummaryDto {
    summaryType!: ResultSummaryTypeEnum | undefined;
    title!: string | undefined;
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclResultSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.summaryType = data["summaryType"];
            this.title = data["title"];
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclResultSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclResultSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summaryType"] = this.summaryType;
        data["title"] = this.title;
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclResultSummaryDto {
    summaryType: ResultSummaryTypeEnum | undefined;
    title: string | undefined;
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclResultSummaryWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclResultSummaryWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclResultSummaryWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclResultSummaryWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclResultSummaryWholesaleEclLookupTableDto implements IWholesaleEclResultSummaryWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto implements IPagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclResultSummaryKeyInputForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclResultSummaryKeyInputForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclResultSummaryKeyInputForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclResultSummaryKeyInputForViewDto[] | undefined;
}

export class GetWholesaleEclResultSummaryKeyInputForViewDto implements IGetWholesaleEclResultSummaryKeyInputForViewDto {
    wholesaleEclResultSummaryKeyInput!: WholesaleEclResultSummaryKeyInputDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclResultSummaryKeyInputForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultSummaryKeyInput = data["wholesaleEclResultSummaryKeyInput"] ? WholesaleEclResultSummaryKeyInputDto.fromJS(data["wholesaleEclResultSummaryKeyInput"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultSummaryKeyInputForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultSummaryKeyInputForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultSummaryKeyInput"] = this.wholesaleEclResultSummaryKeyInput ? this.wholesaleEclResultSummaryKeyInput.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclResultSummaryKeyInputForViewDto {
    wholesaleEclResultSummaryKeyInput: WholesaleEclResultSummaryKeyInputDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclResultSummaryKeyInputDto implements IWholesaleEclResultSummaryKeyInputDto {
    pdGrouping!: string | undefined;
    exposure!: number | undefined;
    collateral!: number | undefined;
    unsecuredPercentage!: number | undefined;
    percentageOfBook!: number | undefined;
    months6CummulativeBestPDs!: number | undefined;
    months12CummulativeBestPDs!: number | undefined;
    months24CummulativeBestPDs!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryKeyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdGrouping = data["pdGrouping"];
            this.exposure = data["exposure"];
            this.collateral = data["collateral"];
            this.unsecuredPercentage = data["unsecuredPercentage"];
            this.percentageOfBook = data["percentageOfBook"];
            this.months6CummulativeBestPDs = data["months6CummulativeBestPDs"];
            this.months12CummulativeBestPDs = data["months12CummulativeBestPDs"];
            this.months24CummulativeBestPDs = data["months24CummulativeBestPDs"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryKeyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryKeyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdGrouping"] = this.pdGrouping;
        data["exposure"] = this.exposure;
        data["collateral"] = this.collateral;
        data["unsecuredPercentage"] = this.unsecuredPercentage;
        data["percentageOfBook"] = this.percentageOfBook;
        data["months6CummulativeBestPDs"] = this.months6CummulativeBestPDs;
        data["months12CummulativeBestPDs"] = this.months12CummulativeBestPDs;
        data["months24CummulativeBestPDs"] = this.months24CummulativeBestPDs;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryKeyInputDto {
    pdGrouping: string | undefined;
    exposure: number | undefined;
    collateral: number | undefined;
    unsecuredPercentage: number | undefined;
    percentageOfBook: number | undefined;
    months6CummulativeBestPDs: number | undefined;
    months12CummulativeBestPDs: number | undefined;
    months24CummulativeBestPDs: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclResultSummaryKeyInputForEditOutput implements IGetWholesaleEclResultSummaryKeyInputForEditOutput {
    wholesaleEclResultSummaryKeyInput!: CreateOrEditWholesaleEclResultSummaryKeyInputDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclResultSummaryKeyInputForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultSummaryKeyInput = data["wholesaleEclResultSummaryKeyInput"] ? CreateOrEditWholesaleEclResultSummaryKeyInputDto.fromJS(data["wholesaleEclResultSummaryKeyInput"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultSummaryKeyInputForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultSummaryKeyInputForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultSummaryKeyInput"] = this.wholesaleEclResultSummaryKeyInput ? this.wholesaleEclResultSummaryKeyInput.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclResultSummaryKeyInputForEditOutput {
    wholesaleEclResultSummaryKeyInput: CreateOrEditWholesaleEclResultSummaryKeyInputDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclResultSummaryKeyInputDto implements ICreateOrEditWholesaleEclResultSummaryKeyInputDto {
    pdGrouping!: string | undefined;
    exposure!: number | undefined;
    collateral!: number | undefined;
    unsecuredPercentage!: number | undefined;
    percentageOfBook!: number | undefined;
    months6CummulativeBestPDs!: number | undefined;
    months12CummulativeBestPDs!: number | undefined;
    months24CummulativeBestPDs!: number | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclResultSummaryKeyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdGrouping = data["pdGrouping"];
            this.exposure = data["exposure"];
            this.collateral = data["collateral"];
            this.unsecuredPercentage = data["unsecuredPercentage"];
            this.percentageOfBook = data["percentageOfBook"];
            this.months6CummulativeBestPDs = data["months6CummulativeBestPDs"];
            this.months12CummulativeBestPDs = data["months12CummulativeBestPDs"];
            this.months24CummulativeBestPDs = data["months24CummulativeBestPDs"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclResultSummaryKeyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclResultSummaryKeyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdGrouping"] = this.pdGrouping;
        data["exposure"] = this.exposure;
        data["collateral"] = this.collateral;
        data["unsecuredPercentage"] = this.unsecuredPercentage;
        data["percentageOfBook"] = this.percentageOfBook;
        data["months6CummulativeBestPDs"] = this.months6CummulativeBestPDs;
        data["months12CummulativeBestPDs"] = this.months12CummulativeBestPDs;
        data["months24CummulativeBestPDs"] = this.months24CummulativeBestPDs;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclResultSummaryKeyInputDto {
    pdGrouping: string | undefined;
    exposure: number | undefined;
    collateral: number | undefined;
    unsecuredPercentage: number | undefined;
    percentageOfBook: number | undefined;
    months6CummulativeBestPDs: number | undefined;
    months12CummulativeBestPDs: number | undefined;
    months24CummulativeBestPDs: number | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto implements IWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryKeyInputWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto implements IPagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclResultSummaryTopExposureForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclResultSummaryTopExposureForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclResultSummaryTopExposureForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclResultSummaryTopExposureForViewDto[] | undefined;
}

export class GetWholesaleEclResultSummaryTopExposureForViewDto implements IGetWholesaleEclResultSummaryTopExposureForViewDto {
    wholesaleEclResultSummaryTopExposure!: WholesaleEclResultSummaryTopExposureDto | undefined;
    wholesaleEclTenantId!: string | undefined;
    wholesaleEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetWholesaleEclResultSummaryTopExposureForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultSummaryTopExposure = data["wholesaleEclResultSummaryTopExposure"] ? WholesaleEclResultSummaryTopExposureDto.fromJS(data["wholesaleEclResultSummaryTopExposure"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
            this.wholesaleEclDataLoanBookCustomerName = data["wholesaleEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultSummaryTopExposureForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultSummaryTopExposureForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultSummaryTopExposure"] = this.wholesaleEclResultSummaryTopExposure ? this.wholesaleEclResultSummaryTopExposure.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        data["wholesaleEclDataLoanBookCustomerName"] = this.wholesaleEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetWholesaleEclResultSummaryTopExposureForViewDto {
    wholesaleEclResultSummaryTopExposure: WholesaleEclResultSummaryTopExposureDto | undefined;
    wholesaleEclTenantId: string | undefined;
    wholesaleEclDataLoanBookCustomerName: string | undefined;
}

export class WholesaleEclResultSummaryTopExposureDto implements IWholesaleEclResultSummaryTopExposureDto {
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    contractId!: string | undefined;
    wholesaleEclId!: string | undefined;
    wholesaleEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryTopExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.contractId = data["contractId"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.wholesaleEclDataLoanBookId = data["wholesaleEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryTopExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryTopExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["contractId"] = this.contractId;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["wholesaleEclDataLoanBookId"] = this.wholesaleEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryTopExposureDto {
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    contractId: string | undefined;
    wholesaleEclId: string | undefined;
    wholesaleEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclResultSummaryTopExposureForEditOutput implements IGetWholesaleEclResultSummaryTopExposureForEditOutput {
    wholesaleEclResultSummaryTopExposure!: CreateOrEditWholesaleEclResultSummaryTopExposureDto | undefined;
    wholesaleEclTenantId!: string | undefined;
    wholesaleEclDataLoanBookCustomerName!: string | undefined;

    constructor(data?: IGetWholesaleEclResultSummaryTopExposureForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclResultSummaryTopExposure = data["wholesaleEclResultSummaryTopExposure"] ? CreateOrEditWholesaleEclResultSummaryTopExposureDto.fromJS(data["wholesaleEclResultSummaryTopExposure"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
            this.wholesaleEclDataLoanBookCustomerName = data["wholesaleEclDataLoanBookCustomerName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclResultSummaryTopExposureForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclResultSummaryTopExposureForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclResultSummaryTopExposure"] = this.wholesaleEclResultSummaryTopExposure ? this.wholesaleEclResultSummaryTopExposure.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        data["wholesaleEclDataLoanBookCustomerName"] = this.wholesaleEclDataLoanBookCustomerName;
        return data; 
    }
}

export interface IGetWholesaleEclResultSummaryTopExposureForEditOutput {
    wholesaleEclResultSummaryTopExposure: CreateOrEditWholesaleEclResultSummaryTopExposureDto | undefined;
    wholesaleEclTenantId: string | undefined;
    wholesaleEclDataLoanBookCustomerName: string | undefined;
}

export class CreateOrEditWholesaleEclResultSummaryTopExposureDto implements ICreateOrEditWholesaleEclResultSummaryTopExposureDto {
    preOverrideExposure!: number | undefined;
    preOverrideImpairment!: number | undefined;
    preOverrideCoverageRatio!: number | undefined;
    postOverrideExposure!: number | undefined;
    postOverrideImpairment!: number | undefined;
    postOverrideCoverageRatio!: number | undefined;
    contractId!: string | undefined;
    wholesaleEclId!: string | undefined;
    wholesaleEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclResultSummaryTopExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preOverrideExposure = data["preOverrideExposure"];
            this.preOverrideImpairment = data["preOverrideImpairment"];
            this.preOverrideCoverageRatio = data["preOverrideCoverageRatio"];
            this.postOverrideExposure = data["postOverrideExposure"];
            this.postOverrideImpairment = data["postOverrideImpairment"];
            this.postOverrideCoverageRatio = data["postOverrideCoverageRatio"];
            this.contractId = data["contractId"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.wholesaleEclDataLoanBookId = data["wholesaleEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclResultSummaryTopExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclResultSummaryTopExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOverrideExposure"] = this.preOverrideExposure;
        data["preOverrideImpairment"] = this.preOverrideImpairment;
        data["preOverrideCoverageRatio"] = this.preOverrideCoverageRatio;
        data["postOverrideExposure"] = this.postOverrideExposure;
        data["postOverrideImpairment"] = this.postOverrideImpairment;
        data["postOverrideCoverageRatio"] = this.postOverrideCoverageRatio;
        data["contractId"] = this.contractId;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["wholesaleEclDataLoanBookId"] = this.wholesaleEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclResultSummaryTopExposureDto {
    preOverrideExposure: number | undefined;
    preOverrideImpairment: number | undefined;
    preOverrideCoverageRatio: number | undefined;
    postOverrideExposure: number | undefined;
    postOverrideImpairment: number | undefined;
    postOverrideCoverageRatio: number | undefined;
    contractId: string | undefined;
    wholesaleEclId: string | undefined;
    wholesaleEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto implements IWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryTopExposureWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto implements IPagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto[] | undefined;
}

export class WholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto implements IWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclResultSummaryTopExposureWholesaleEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclForViewDto implements IPagedResultDtoOfGetWholesaleEclForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclForViewDto[] | undefined;
}

export class GetWholesaleEclForViewDto implements IGetWholesaleEclForViewDto {
    wholesaleEcl!: WholesaleEclDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetWholesaleEclForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEcl = data["wholesaleEcl"] ? WholesaleEclDto.fromJS(data["wholesaleEcl"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEcl"] = this.wholesaleEcl ? this.wholesaleEcl.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetWholesaleEclForViewDto {
    wholesaleEcl: WholesaleEclDto | undefined;
    userName: string | undefined;
}

export class WholesaleEclDto implements IWholesaleEclDto {
    reportingDate!: moment.Moment | undefined;
    closedDate!: moment.Moment | undefined;
    isApproved!: boolean | undefined;
    status!: EclStatusEnum | undefined;
    closedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.closedDate = data["closedDate"] ? moment(data["closedDate"].toString()) : <any>undefined;
            this.isApproved = data["isApproved"];
            this.status = data["status"];
            this.closedByUserId = data["closedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["closedDate"] = this.closedDate ? this.closedDate.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["closedByUserId"] = this.closedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclDto {
    reportingDate: moment.Moment | undefined;
    closedDate: moment.Moment | undefined;
    isApproved: boolean | undefined;
    status: EclStatusEnum | undefined;
    closedByUserId: number | undefined;
    id: string | undefined;
}

export class GetWholesaleEclForEditOutput implements IGetWholesaleEclForEditOutput {
    wholesaleEcl!: CreateOrEditWholesaleEclDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetWholesaleEclForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEcl = data["wholesaleEcl"] ? CreateOrEditWholesaleEclDto.fromJS(data["wholesaleEcl"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEcl"] = this.wholesaleEcl ? this.wholesaleEcl.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetWholesaleEclForEditOutput {
    wholesaleEcl: CreateOrEditWholesaleEclDto | undefined;
    userName: string | undefined;
}

export class CreateOrEditWholesaleEclDto implements ICreateOrEditWholesaleEclDto {
    reportingDate!: moment.Moment;
    closedDate!: moment.Moment | undefined;
    isApproved!: boolean;
    status!: EclStatusEnum | undefined;
    closedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportingDate = data["reportingDate"] ? moment(data["reportingDate"].toString()) : <any>undefined;
            this.closedDate = data["closedDate"] ? moment(data["closedDate"].toString()) : <any>undefined;
            this.isApproved = data["isApproved"];
            this.status = data["status"];
            this.closedByUserId = data["closedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["closedDate"] = this.closedDate ? this.closedDate.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["closedByUserId"] = this.closedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclDto {
    reportingDate: moment.Moment;
    closedDate: moment.Moment | undefined;
    isApproved: boolean;
    status: EclStatusEnum | undefined;
    closedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclUserLookupTableDto implements IPagedResultDtoOfWholesaleEclUserLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclUserLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclUserLookupTableDto[] | undefined;
}

export class WholesaleEclUserLookupTableDto implements IWholesaleEclUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto implements IPagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclSicrApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclSicrApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclSicrApprovalForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclSicrApprovalForViewDto[] | undefined;
}

export class GetWholesaleEclSicrApprovalForViewDto implements IGetWholesaleEclSicrApprovalForViewDto {
    wholesaleEclSicrApproval!: WholesaleEclSicrApprovalDto | undefined;
    userName!: string | undefined;
    wholesaleEclSicrOverrideComment!: string | undefined;

    constructor(data?: IGetWholesaleEclSicrApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclSicrApproval = data["wholesaleEclSicrApproval"] ? WholesaleEclSicrApprovalDto.fromJS(data["wholesaleEclSicrApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.wholesaleEclSicrOverrideComment = data["wholesaleEclSicrOverrideComment"];
        }
    }

    static fromJS(data: any): GetWholesaleEclSicrApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclSicrApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclSicrApproval"] = this.wholesaleEclSicrApproval ? this.wholesaleEclSicrApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["wholesaleEclSicrOverrideComment"] = this.wholesaleEclSicrOverrideComment;
        return data; 
    }
}

export interface IGetWholesaleEclSicrApprovalForViewDto {
    wholesaleEclSicrApproval: WholesaleEclSicrApprovalDto | undefined;
    userName: string | undefined;
    wholesaleEclSicrOverrideComment: string | undefined;
}

export class WholesaleEclSicrApprovalDto implements IWholesaleEclSicrApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    wholesaleEclSicrId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclSicrApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.wholesaleEclSicrId = data["wholesaleEclSicrId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclSicrApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclSicrApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["wholesaleEclSicrId"] = this.wholesaleEclSicrId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclSicrApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    wholesaleEclSicrId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclSicrApprovalForEditOutput implements IGetWholesaleEclSicrApprovalForEditOutput {
    wholesaleEclSicrApproval!: CreateOrEditWholesaleEclSicrApprovalDto | undefined;
    userName!: string | undefined;
    wholesaleEclSicrOverrideComment!: string | undefined;

    constructor(data?: IGetWholesaleEclSicrApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclSicrApproval = data["wholesaleEclSicrApproval"] ? CreateOrEditWholesaleEclSicrApprovalDto.fromJS(data["wholesaleEclSicrApproval"]) : <any>undefined;
            this.userName = data["userName"];
            this.wholesaleEclSicrOverrideComment = data["wholesaleEclSicrOverrideComment"];
        }
    }

    static fromJS(data: any): GetWholesaleEclSicrApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclSicrApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclSicrApproval"] = this.wholesaleEclSicrApproval ? this.wholesaleEclSicrApproval.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["wholesaleEclSicrOverrideComment"] = this.wholesaleEclSicrOverrideComment;
        return data; 
    }
}

export interface IGetWholesaleEclSicrApprovalForEditOutput {
    wholesaleEclSicrApproval: CreateOrEditWholesaleEclSicrApprovalDto | undefined;
    userName: string | undefined;
    wholesaleEclSicrOverrideComment: string | undefined;
}

export class CreateOrEditWholesaleEclSicrApprovalDto implements ICreateOrEditWholesaleEclSicrApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    reviewedByUserId!: number | undefined;
    wholesaleEclSicrId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclSicrApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.wholesaleEclSicrId = data["wholesaleEclSicrId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclSicrApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclSicrApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["wholesaleEclSicrId"] = this.wholesaleEclSicrId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclSicrApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    reviewedByUserId: number | undefined;
    wholesaleEclSicrId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto implements IPagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclSicrApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclSicrApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclSicrApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclSicrApprovalUserLookupTableDto[] | undefined;
}

export class WholesaleEclSicrApprovalUserLookupTableDto implements IWholesaleEclSicrApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclSicrApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclSicrApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclSicrApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclSicrApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto implements IPagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto[] | undefined;
}

export class WholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto implements IWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclSicrApprovalWholesaleEclSicrLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclSicrForViewDto implements IPagedResultDtoOfGetWholesaleEclSicrForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclSicrForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclSicrForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclSicrForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclSicrForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclSicrForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclSicrForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclSicrForViewDto[] | undefined;
}

export class GetWholesaleEclSicrForViewDto implements IGetWholesaleEclSicrForViewDto {
    wholesaleEclSicr!: WholesaleEclSicrDto | undefined;
    wholesaleEclDataLoanBookContractNo!: string | undefined;

    constructor(data?: IGetWholesaleEclSicrForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclSicr = data["wholesaleEclSicr"] ? WholesaleEclSicrDto.fromJS(data["wholesaleEclSicr"]) : <any>undefined;
            this.wholesaleEclDataLoanBookContractNo = data["wholesaleEclDataLoanBookContractNo"];
        }
    }

    static fromJS(data: any): GetWholesaleEclSicrForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclSicrForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclSicr"] = this.wholesaleEclSicr ? this.wholesaleEclSicr.toJSON() : <any>undefined;
        data["wholesaleEclDataLoanBookContractNo"] = this.wholesaleEclDataLoanBookContractNo;
        return data; 
    }
}

export interface IGetWholesaleEclSicrForViewDto {
    wholesaleEclSicr: WholesaleEclSicrDto | undefined;
    wholesaleEclDataLoanBookContractNo: string | undefined;
}

export class WholesaleEclSicrDto implements IWholesaleEclSicrDto {
    computedSICR!: number | undefined;
    overrideSICR!: string | undefined;
    overrideComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclSicrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.computedSICR = data["computedSICR"];
            this.overrideSICR = data["overrideSICR"];
            this.overrideComment = data["overrideComment"];
            this.status = data["status"];
            this.wholesaleEclDataLoanBookId = data["wholesaleEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclSicrDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclSicrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["computedSICR"] = this.computedSICR;
        data["overrideSICR"] = this.overrideSICR;
        data["overrideComment"] = this.overrideComment;
        data["status"] = this.status;
        data["wholesaleEclDataLoanBookId"] = this.wholesaleEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclSicrDto {
    computedSICR: number | undefined;
    overrideSICR: string | undefined;
    overrideComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclSicrForEditOutput implements IGetWholesaleEclSicrForEditOutput {
    wholesaleEclSicr!: CreateOrEditWholesaleEclSicrDto | undefined;
    wholesaleEclDataLoanBookContractNo!: string | undefined;

    constructor(data?: IGetWholesaleEclSicrForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclSicr = data["wholesaleEclSicr"] ? CreateOrEditWholesaleEclSicrDto.fromJS(data["wholesaleEclSicr"]) : <any>undefined;
            this.wholesaleEclDataLoanBookContractNo = data["wholesaleEclDataLoanBookContractNo"];
        }
    }

    static fromJS(data: any): GetWholesaleEclSicrForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclSicrForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclSicr"] = this.wholesaleEclSicr ? this.wholesaleEclSicr.toJSON() : <any>undefined;
        data["wholesaleEclDataLoanBookContractNo"] = this.wholesaleEclDataLoanBookContractNo;
        return data; 
    }
}

export interface IGetWholesaleEclSicrForEditOutput {
    wholesaleEclSicr: CreateOrEditWholesaleEclSicrDto | undefined;
    wholesaleEclDataLoanBookContractNo: string | undefined;
}

export class CreateOrEditWholesaleEclSicrDto implements ICreateOrEditWholesaleEclSicrDto {
    computedSICR!: number;
    overrideSICR!: string | undefined;
    overrideComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclDataLoanBookId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclSicrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.computedSICR = data["computedSICR"];
            this.overrideSICR = data["overrideSICR"];
            this.overrideComment = data["overrideComment"];
            this.status = data["status"];
            this.wholesaleEclDataLoanBookId = data["wholesaleEclDataLoanBookId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclSicrDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclSicrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["computedSICR"] = this.computedSICR;
        data["overrideSICR"] = this.overrideSICR;
        data["overrideComment"] = this.overrideComment;
        data["status"] = this.status;
        data["wholesaleEclDataLoanBookId"] = this.wholesaleEclDataLoanBookId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclSicrDto {
    computedSICR: number;
    overrideSICR: string | undefined;
    overrideComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclDataLoanBookId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto implements IPagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto[] | undefined;
}

export class WholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto implements IWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclSicrWholesaleEclDataLoanBookLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto implements IPagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclUploadApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclUploadApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclUploadApprovalForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclUploadApprovalForViewDto[] | undefined;
}

export class GetWholesaleEclUploadApprovalForViewDto implements IGetWholesaleEclUploadApprovalForViewDto {
    wholesaleEclUploadApproval!: WholesaleEclUploadApprovalDto | undefined;
    wholesaleEclUploadUploadComment!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetWholesaleEclUploadApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclUploadApproval = data["wholesaleEclUploadApproval"] ? WholesaleEclUploadApprovalDto.fromJS(data["wholesaleEclUploadApproval"]) : <any>undefined;
            this.wholesaleEclUploadUploadComment = data["wholesaleEclUploadUploadComment"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclUploadApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclUploadApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclUploadApproval"] = this.wholesaleEclUploadApproval ? this.wholesaleEclUploadApproval.toJSON() : <any>undefined;
        data["wholesaleEclUploadUploadComment"] = this.wholesaleEclUploadUploadComment;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetWholesaleEclUploadApprovalForViewDto {
    wholesaleEclUploadApproval: WholesaleEclUploadApprovalDto | undefined;
    wholesaleEclUploadUploadComment: string | undefined;
    userName: string | undefined;
}

export class WholesaleEclUploadApprovalDto implements IWholesaleEclUploadApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclUploadId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclUploadApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.wholesaleEclUploadId = data["wholesaleEclUploadId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclUploadApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclUploadApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["wholesaleEclUploadId"] = this.wholesaleEclUploadId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclUploadApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclUploadId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class GetWholesaleEclUploadApprovalForEditOutput implements IGetWholesaleEclUploadApprovalForEditOutput {
    wholesaleEclUploadApproval!: CreateOrEditWholesaleEclUploadApprovalDto | undefined;
    wholesaleEclUploadUploadComment!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetWholesaleEclUploadApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclUploadApproval = data["wholesaleEclUploadApproval"] ? CreateOrEditWholesaleEclUploadApprovalDto.fromJS(data["wholesaleEclUploadApproval"]) : <any>undefined;
            this.wholesaleEclUploadUploadComment = data["wholesaleEclUploadUploadComment"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetWholesaleEclUploadApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclUploadApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclUploadApproval"] = this.wholesaleEclUploadApproval ? this.wholesaleEclUploadApproval.toJSON() : <any>undefined;
        data["wholesaleEclUploadUploadComment"] = this.wholesaleEclUploadUploadComment;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetWholesaleEclUploadApprovalForEditOutput {
    wholesaleEclUploadApproval: CreateOrEditWholesaleEclUploadApprovalDto | undefined;
    wholesaleEclUploadUploadComment: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditWholesaleEclUploadApprovalDto implements ICreateOrEditWholesaleEclUploadApprovalDto {
    reviewedDate!: moment.Moment | undefined;
    reviewComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclUploadId!: string | undefined;
    reviewedByUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclUploadApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reviewedDate = data["reviewedDate"] ? moment(data["reviewedDate"].toString()) : <any>undefined;
            this.reviewComment = data["reviewComment"];
            this.status = data["status"];
            this.wholesaleEclUploadId = data["wholesaleEclUploadId"];
            this.reviewedByUserId = data["reviewedByUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclUploadApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclUploadApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewedDate"] = this.reviewedDate ? this.reviewedDate.toISOString() : <any>undefined;
        data["reviewComment"] = this.reviewComment;
        data["status"] = this.status;
        data["wholesaleEclUploadId"] = this.wholesaleEclUploadId;
        data["reviewedByUserId"] = this.reviewedByUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclUploadApprovalDto {
    reviewedDate: moment.Moment | undefined;
    reviewComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclUploadId: string | undefined;
    reviewedByUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto implements IPagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto[] | undefined;
}

export class WholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto implements IWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclUploadApprovalWholesaleEclUploadLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto implements IPagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclUploadApprovalUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclUploadApprovalUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclUploadApprovalUserLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclUploadApprovalUserLookupTableDto[] | undefined;
}

export class WholesaleEclUploadApprovalUserLookupTableDto implements IWholesaleEclUploadApprovalUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclUploadApprovalUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclUploadApprovalUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclUploadApprovalUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclUploadApprovalUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesaleEclUploadForViewDto implements IPagedResultDtoOfGetWholesaleEclUploadForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesaleEclUploadForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesaleEclUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesaleEclUploadForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesaleEclUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesaleEclUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesaleEclUploadForViewDto {
    totalCount: number | undefined;
    items: GetWholesaleEclUploadForViewDto[] | undefined;
}

export class GetWholesaleEclUploadForViewDto implements IGetWholesaleEclUploadForViewDto {
    wholesaleEclUpload!: WholesaleEclUploadDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclUploadForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclUpload = data["wholesaleEclUpload"] ? WholesaleEclUploadDto.fromJS(data["wholesaleEclUpload"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclUploadForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclUploadForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclUpload"] = this.wholesaleEclUpload ? this.wholesaleEclUpload.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclUploadForViewDto {
    wholesaleEclUpload: WholesaleEclUploadDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesaleEclUploadDto implements IWholesaleEclUploadDto {
    docType!: UploadDocTypeEnum | undefined;
    uploadComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesaleEclUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docType = data["docType"];
            this.uploadComment = data["uploadComment"];
            this.status = data["status"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesaleEclUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["uploadComment"] = this.uploadComment;
        data["status"] = this.status;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesaleEclUploadDto {
    docType: UploadDocTypeEnum | undefined;
    uploadComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesaleEclUploadForEditOutput implements IGetWholesaleEclUploadForEditOutput {
    wholesaleEclUpload!: CreateOrEditWholesaleEclUploadDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesaleEclUploadForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclUpload = data["wholesaleEclUpload"] ? CreateOrEditWholesaleEclUploadDto.fromJS(data["wholesaleEclUpload"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesaleEclUploadForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesaleEclUploadForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclUpload"] = this.wholesaleEclUpload ? this.wholesaleEclUpload.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesaleEclUploadForEditOutput {
    wholesaleEclUpload: CreateOrEditWholesaleEclUploadDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesaleEclUploadDto implements ICreateOrEditWholesaleEclUploadDto {
    docType!: UploadDocTypeEnum | undefined;
    uploadComment!: string | undefined;
    status!: GeneralStatusEnum | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesaleEclUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docType = data["docType"];
            this.uploadComment = data["uploadComment"];
            this.status = data["status"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesaleEclUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesaleEclUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["uploadComment"] = this.uploadComment;
        data["status"] = this.status;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesaleEclUploadDto {
    docType: UploadDocTypeEnum | undefined;
    uploadComment: string | undefined;
    status: GeneralStatusEnum | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesaleEclUploadWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesaleEclUploadWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesaleEclUploadWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesaleEclUploadWholesaleEclLookupTableDto[] | undefined;
}

export class WholesaleEclUploadWholesaleEclLookupTableDto implements IWholesaleEclUploadWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesaleEclUploadWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesaleEclUploadWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesaleEclUploadWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesaleEclUploadWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto implements IPagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto {
    totalCount!: number | undefined;
    items!: GetWholesalePdAssumptionNonInternalModelForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWholesalePdAssumptionNonInternalModelForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWholesalePdAssumptionNonInternalModelForViewDto {
    totalCount: number | undefined;
    items: GetWholesalePdAssumptionNonInternalModelForViewDto[] | undefined;
}

export class GetWholesalePdAssumptionNonInternalModelForViewDto implements IGetWholesalePdAssumptionNonInternalModelForViewDto {
    wholesalePdAssumptionNonInternalModel!: WholesalePdAssumptionNonInternalModelDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesalePdAssumptionNonInternalModelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesalePdAssumptionNonInternalModel = data["wholesalePdAssumptionNonInternalModel"] ? WholesalePdAssumptionNonInternalModelDto.fromJS(data["wholesalePdAssumptionNonInternalModel"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesalePdAssumptionNonInternalModelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesalePdAssumptionNonInternalModelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesalePdAssumptionNonInternalModel"] = this.wholesalePdAssumptionNonInternalModel ? this.wholesalePdAssumptionNonInternalModel.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesalePdAssumptionNonInternalModelForViewDto {
    wholesalePdAssumptionNonInternalModel: WholesalePdAssumptionNonInternalModelDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class WholesalePdAssumptionNonInternalModelDto implements IWholesalePdAssumptionNonInternalModelDto {
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IWholesalePdAssumptionNonInternalModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WholesalePdAssumptionNonInternalModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesalePdAssumptionNonInternalModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWholesalePdAssumptionNonInternalModelDto {
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class GetWholesalePdAssumptionNonInternalModelForEditOutput implements IGetWholesalePdAssumptionNonInternalModelForEditOutput {
    wholesalePdAssumptionNonInternalModel!: CreateOrEditWholesalePdAssumptionNonInternalModelDto | undefined;
    wholesaleEclTenantId!: string | undefined;

    constructor(data?: IGetWholesalePdAssumptionNonInternalModelForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wholesalePdAssumptionNonInternalModel = data["wholesalePdAssumptionNonInternalModel"] ? CreateOrEditWholesalePdAssumptionNonInternalModelDto.fromJS(data["wholesalePdAssumptionNonInternalModel"]) : <any>undefined;
            this.wholesaleEclTenantId = data["wholesaleEclTenantId"];
        }
    }

    static fromJS(data: any): GetWholesalePdAssumptionNonInternalModelForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWholesalePdAssumptionNonInternalModelForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wholesalePdAssumptionNonInternalModel"] = this.wholesalePdAssumptionNonInternalModel ? this.wholesalePdAssumptionNonInternalModel.toJSON() : <any>undefined;
        data["wholesaleEclTenantId"] = this.wholesaleEclTenantId;
        return data; 
    }
}

export interface IGetWholesalePdAssumptionNonInternalModelForEditOutput {
    wholesalePdAssumptionNonInternalModel: CreateOrEditWholesalePdAssumptionNonInternalModelDto | undefined;
    wholesaleEclTenantId: string | undefined;
}

export class CreateOrEditWholesalePdAssumptionNonInternalModelDto implements ICreateOrEditWholesalePdAssumptionNonInternalModelDto {
    canAffiliateEdit!: boolean | undefined;
    wholesaleEclId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditWholesalePdAssumptionNonInternalModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canAffiliateEdit = data["canAffiliateEdit"];
            this.wholesaleEclId = data["wholesaleEclId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWholesalePdAssumptionNonInternalModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWholesalePdAssumptionNonInternalModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canAffiliateEdit"] = this.canAffiliateEdit;
        data["wholesaleEclId"] = this.wholesaleEclId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWholesalePdAssumptionNonInternalModelDto {
    canAffiliateEdit: boolean | undefined;
    wholesaleEclId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto implements IPagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto {
    totalCount!: number | undefined;
    items!: WholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto {
    totalCount: number | undefined;
    items: WholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto[] | undefined;
}

export class WholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto implements IWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWholesalePdAssumptionNonInternalModelWholesaleEclLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string] : string; } | undefined;
    stripe!: { [key: string] : string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
    stripe: { [key: string] : string; } | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}